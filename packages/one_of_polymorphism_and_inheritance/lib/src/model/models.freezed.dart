// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

IntInUnion _$IntInUnionFromJson(Map<String, dynamic> json) {
  return _IntInUnion.fromJson(json);
}

/// @nodoc
mixin _$IntInUnion {
  int get intValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IntInUnionCopyWith<IntInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntInUnionCopyWith<$Res> {
  factory $IntInUnionCopyWith(
          IntInUnion value, $Res Function(IntInUnion) then) =
      _$IntInUnionCopyWithImpl<$Res, IntInUnion>;
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class _$IntInUnionCopyWithImpl<$Res, $Val extends IntInUnion>
    implements $IntInUnionCopyWith<$Res> {
  _$IntInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_value.copyWith(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_IntInUnionCopyWith<$Res>
    implements $IntInUnionCopyWith<$Res> {
  factory _$$_IntInUnionCopyWith(
          _$_IntInUnion value, $Res Function(_$_IntInUnion) then) =
      __$$_IntInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class __$$_IntInUnionCopyWithImpl<$Res>
    extends _$IntInUnionCopyWithImpl<$Res, _$_IntInUnion>
    implements _$$_IntInUnionCopyWith<$Res> {
  __$$_IntInUnionCopyWithImpl(
      _$_IntInUnion _value, $Res Function(_$_IntInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_$_IntInUnion(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IntInUnion implements _IntInUnion {
  const _$_IntInUnion({required this.intValue});

  factory _$_IntInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_IntInUnionFromJson(json);

  @override
  final int intValue;

  @override
  String toString() {
    return 'IntInUnion(intValue: $intValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IntInUnion &&
            (identical(other.intValue, intValue) ||
                other.intValue == intValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, intValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IntInUnionCopyWith<_$_IntInUnion> get copyWith =>
      __$$_IntInUnionCopyWithImpl<_$_IntInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IntInUnionToJson(
      this,
    );
  }
}

abstract class _IntInUnion implements IntInUnion {
  const factory _IntInUnion({required final int intValue}) = _$_IntInUnion;

  factory _IntInUnion.fromJson(Map<String, dynamic> json) =
      _$_IntInUnion.fromJson;

  @override
  int get intValue;
  @override
  @JsonKey(ignore: true)
  _$$_IntInUnionCopyWith<_$_IntInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

StringInUnion _$StringInUnionFromJson(Map<String, dynamic> json) {
  return _StringInUnion.fromJson(json);
}

/// @nodoc
mixin _$StringInUnion {
  String get stringValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StringInUnionCopyWith<StringInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringInUnionCopyWith<$Res> {
  factory $StringInUnionCopyWith(
          StringInUnion value, $Res Function(StringInUnion) then) =
      _$StringInUnionCopyWithImpl<$Res, StringInUnion>;
  @useResult
  $Res call({String stringValue});
}

/// @nodoc
class _$StringInUnionCopyWithImpl<$Res, $Val extends StringInUnion>
    implements $StringInUnionCopyWith<$Res> {
  _$StringInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stringValue = null,
  }) {
    return _then(_value.copyWith(
      stringValue: null == stringValue
          ? _value.stringValue
          : stringValue // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_StringInUnionCopyWith<$Res>
    implements $StringInUnionCopyWith<$Res> {
  factory _$$_StringInUnionCopyWith(
          _$_StringInUnion value, $Res Function(_$_StringInUnion) then) =
      __$$_StringInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String stringValue});
}

/// @nodoc
class __$$_StringInUnionCopyWithImpl<$Res>
    extends _$StringInUnionCopyWithImpl<$Res, _$_StringInUnion>
    implements _$$_StringInUnionCopyWith<$Res> {
  __$$_StringInUnionCopyWithImpl(
      _$_StringInUnion _value, $Res Function(_$_StringInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stringValue = null,
  }) {
    return _then(_$_StringInUnion(
      stringValue: null == stringValue
          ? _value.stringValue
          : stringValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_StringInUnion implements _StringInUnion {
  const _$_StringInUnion({required this.stringValue});

  factory _$_StringInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_StringInUnionFromJson(json);

  @override
  final String stringValue;

  @override
  String toString() {
    return 'StringInUnion(stringValue: $stringValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StringInUnion &&
            (identical(other.stringValue, stringValue) ||
                other.stringValue == stringValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, stringValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StringInUnionCopyWith<_$_StringInUnion> get copyWith =>
      __$$_StringInUnionCopyWithImpl<_$_StringInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_StringInUnionToJson(
      this,
    );
  }
}

abstract class _StringInUnion implements StringInUnion {
  const factory _StringInUnion({required final String stringValue}) =
      _$_StringInUnion;

  factory _StringInUnion.fromJson(Map<String, dynamic> json) =
      _$_StringInUnion.fromJson;

  @override
  String get stringValue;
  @override
  @JsonKey(ignore: true)
  _$$_StringInUnionCopyWith<_$_StringInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

BoolInUnion _$BoolInUnionFromJson(Map<String, dynamic> json) {
  return _BoolInUnion.fromJson(json);
}

/// @nodoc
mixin _$BoolInUnion {
  bool get boolValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BoolInUnionCopyWith<BoolInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BoolInUnionCopyWith<$Res> {
  factory $BoolInUnionCopyWith(
          BoolInUnion value, $Res Function(BoolInUnion) then) =
      _$BoolInUnionCopyWithImpl<$Res, BoolInUnion>;
  @useResult
  $Res call({bool boolValue});
}

/// @nodoc
class _$BoolInUnionCopyWithImpl<$Res, $Val extends BoolInUnion>
    implements $BoolInUnionCopyWith<$Res> {
  _$BoolInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boolValue = null,
  }) {
    return _then(_value.copyWith(
      boolValue: null == boolValue
          ? _value.boolValue
          : boolValue // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BoolInUnionCopyWith<$Res>
    implements $BoolInUnionCopyWith<$Res> {
  factory _$$_BoolInUnionCopyWith(
          _$_BoolInUnion value, $Res Function(_$_BoolInUnion) then) =
      __$$_BoolInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool boolValue});
}

/// @nodoc
class __$$_BoolInUnionCopyWithImpl<$Res>
    extends _$BoolInUnionCopyWithImpl<$Res, _$_BoolInUnion>
    implements _$$_BoolInUnionCopyWith<$Res> {
  __$$_BoolInUnionCopyWithImpl(
      _$_BoolInUnion _value, $Res Function(_$_BoolInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boolValue = null,
  }) {
    return _then(_$_BoolInUnion(
      boolValue: null == boolValue
          ? _value.boolValue
          : boolValue // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BoolInUnion implements _BoolInUnion {
  const _$_BoolInUnion({required this.boolValue});

  factory _$_BoolInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_BoolInUnionFromJson(json);

  @override
  final bool boolValue;

  @override
  String toString() {
    return 'BoolInUnion(boolValue: $boolValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BoolInUnion &&
            (identical(other.boolValue, boolValue) ||
                other.boolValue == boolValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, boolValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BoolInUnionCopyWith<_$_BoolInUnion> get copyWith =>
      __$$_BoolInUnionCopyWithImpl<_$_BoolInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BoolInUnionToJson(
      this,
    );
  }
}

abstract class _BoolInUnion implements BoolInUnion {
  const factory _BoolInUnion({required final bool boolValue}) = _$_BoolInUnion;

  factory _BoolInUnion.fromJson(Map<String, dynamic> json) =
      _$_BoolInUnion.fromJson;

  @override
  bool get boolValue;
  @override
  @JsonKey(ignore: true)
  _$$_BoolInUnionCopyWith<_$_BoolInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

DoubleInUnion _$DoubleInUnionFromJson(Map<String, dynamic> json) {
  return _DoubleInUnion.fromJson(json);
}

/// @nodoc
mixin _$DoubleInUnion {
  double get doubleValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DoubleInUnionCopyWith<DoubleInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DoubleInUnionCopyWith<$Res> {
  factory $DoubleInUnionCopyWith(
          DoubleInUnion value, $Res Function(DoubleInUnion) then) =
      _$DoubleInUnionCopyWithImpl<$Res, DoubleInUnion>;
  @useResult
  $Res call({double doubleValue});
}

/// @nodoc
class _$DoubleInUnionCopyWithImpl<$Res, $Val extends DoubleInUnion>
    implements $DoubleInUnionCopyWith<$Res> {
  _$DoubleInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? doubleValue = null,
  }) {
    return _then(_value.copyWith(
      doubleValue: null == doubleValue
          ? _value.doubleValue
          : doubleValue // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DoubleInUnionCopyWith<$Res>
    implements $DoubleInUnionCopyWith<$Res> {
  factory _$$_DoubleInUnionCopyWith(
          _$_DoubleInUnion value, $Res Function(_$_DoubleInUnion) then) =
      __$$_DoubleInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double doubleValue});
}

/// @nodoc
class __$$_DoubleInUnionCopyWithImpl<$Res>
    extends _$DoubleInUnionCopyWithImpl<$Res, _$_DoubleInUnion>
    implements _$$_DoubleInUnionCopyWith<$Res> {
  __$$_DoubleInUnionCopyWithImpl(
      _$_DoubleInUnion _value, $Res Function(_$_DoubleInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? doubleValue = null,
  }) {
    return _then(_$_DoubleInUnion(
      doubleValue: null == doubleValue
          ? _value.doubleValue
          : doubleValue // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DoubleInUnion implements _DoubleInUnion {
  const _$_DoubleInUnion({required this.doubleValue});

  factory _$_DoubleInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_DoubleInUnionFromJson(json);

  @override
  final double doubleValue;

  @override
  String toString() {
    return 'DoubleInUnion(doubleValue: $doubleValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DoubleInUnion &&
            (identical(other.doubleValue, doubleValue) ||
                other.doubleValue == doubleValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, doubleValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DoubleInUnionCopyWith<_$_DoubleInUnion> get copyWith =>
      __$$_DoubleInUnionCopyWithImpl<_$_DoubleInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DoubleInUnionToJson(
      this,
    );
  }
}

abstract class _DoubleInUnion implements DoubleInUnion {
  const factory _DoubleInUnion({required final double doubleValue}) =
      _$_DoubleInUnion;

  factory _DoubleInUnion.fromJson(Map<String, dynamic> json) =
      _$_DoubleInUnion.fromJson;

  @override
  double get doubleValue;
  @override
  @JsonKey(ignore: true)
  _$$_DoubleInUnionCopyWith<_$_DoubleInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

ObjectInUnion _$ObjectInUnionFromJson(Map<String, dynamic> json) {
  return _ObjectInUnion.fromJson(json);
}

/// @nodoc
mixin _$ObjectInUnion {
  Object get objectValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ObjectInUnionCopyWith<ObjectInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ObjectInUnionCopyWith<$Res> {
  factory $ObjectInUnionCopyWith(
          ObjectInUnion value, $Res Function(ObjectInUnion) then) =
      _$ObjectInUnionCopyWithImpl<$Res, ObjectInUnion>;
  @useResult
  $Res call({Object objectValue});
}

/// @nodoc
class _$ObjectInUnionCopyWithImpl<$Res, $Val extends ObjectInUnion>
    implements $ObjectInUnionCopyWith<$Res> {
  _$ObjectInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? objectValue = null,
  }) {
    return _then(_value.copyWith(
      objectValue: null == objectValue ? _value.objectValue : objectValue,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ObjectInUnionCopyWith<$Res>
    implements $ObjectInUnionCopyWith<$Res> {
  factory _$$_ObjectInUnionCopyWith(
          _$_ObjectInUnion value, $Res Function(_$_ObjectInUnion) then) =
      __$$_ObjectInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Object objectValue});
}

/// @nodoc
class __$$_ObjectInUnionCopyWithImpl<$Res>
    extends _$ObjectInUnionCopyWithImpl<$Res, _$_ObjectInUnion>
    implements _$$_ObjectInUnionCopyWith<$Res> {
  __$$_ObjectInUnionCopyWithImpl(
      _$_ObjectInUnion _value, $Res Function(_$_ObjectInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? objectValue = null,
  }) {
    return _then(_$_ObjectInUnion(
      objectValue: null == objectValue ? _value.objectValue : objectValue,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ObjectInUnion implements _ObjectInUnion {
  const _$_ObjectInUnion({required this.objectValue});

  factory _$_ObjectInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_ObjectInUnionFromJson(json);

  @override
  final Object objectValue;

  @override
  String toString() {
    return 'ObjectInUnion(objectValue: $objectValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ObjectInUnion &&
            const DeepCollectionEquality()
                .equals(other.objectValue, objectValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(objectValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ObjectInUnionCopyWith<_$_ObjectInUnion> get copyWith =>
      __$$_ObjectInUnionCopyWithImpl<_$_ObjectInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ObjectInUnionToJson(
      this,
    );
  }
}

abstract class _ObjectInUnion implements ObjectInUnion {
  const factory _ObjectInUnion({required final Object objectValue}) =
      _$_ObjectInUnion;

  factory _ObjectInUnion.fromJson(Map<String, dynamic> json) =
      _$_ObjectInUnion.fromJson;

  @override
  Object get objectValue;
  @override
  @JsonKey(ignore: true)
  _$$_ObjectInUnionCopyWith<_$_ObjectInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

NumInUnion _$NumInUnionFromJson(Map<String, dynamic> json) {
  return _NumInUnion.fromJson(json);
}

/// @nodoc
mixin _$NumInUnion {
  num get numValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NumInUnionCopyWith<NumInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NumInUnionCopyWith<$Res> {
  factory $NumInUnionCopyWith(
          NumInUnion value, $Res Function(NumInUnion) then) =
      _$NumInUnionCopyWithImpl<$Res, NumInUnion>;
  @useResult
  $Res call({num numValue});
}

/// @nodoc
class _$NumInUnionCopyWithImpl<$Res, $Val extends NumInUnion>
    implements $NumInUnionCopyWith<$Res> {
  _$NumInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? numValue = null,
  }) {
    return _then(_value.copyWith(
      numValue: null == numValue
          ? _value.numValue
          : numValue // ignore: cast_nullable_to_non_nullable
              as num,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_NumInUnionCopyWith<$Res>
    implements $NumInUnionCopyWith<$Res> {
  factory _$$_NumInUnionCopyWith(
          _$_NumInUnion value, $Res Function(_$_NumInUnion) then) =
      __$$_NumInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({num numValue});
}

/// @nodoc
class __$$_NumInUnionCopyWithImpl<$Res>
    extends _$NumInUnionCopyWithImpl<$Res, _$_NumInUnion>
    implements _$$_NumInUnionCopyWith<$Res> {
  __$$_NumInUnionCopyWithImpl(
      _$_NumInUnion _value, $Res Function(_$_NumInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? numValue = null,
  }) {
    return _then(_$_NumInUnion(
      numValue: null == numValue
          ? _value.numValue
          : numValue // ignore: cast_nullable_to_non_nullable
              as num,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NumInUnion implements _NumInUnion {
  const _$_NumInUnion({required this.numValue});

  factory _$_NumInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_NumInUnionFromJson(json);

  @override
  final num numValue;

  @override
  String toString() {
    return 'NumInUnion(numValue: $numValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NumInUnion &&
            (identical(other.numValue, numValue) ||
                other.numValue == numValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, numValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NumInUnionCopyWith<_$_NumInUnion> get copyWith =>
      __$$_NumInUnionCopyWithImpl<_$_NumInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NumInUnionToJson(
      this,
    );
  }
}

abstract class _NumInUnion implements NumInUnion {
  const factory _NumInUnion({required final num numValue}) = _$_NumInUnion;

  factory _NumInUnion.fromJson(Map<String, dynamic> json) =
      _$_NumInUnion.fromJson;

  @override
  num get numValue;
  @override
  @JsonKey(ignore: true)
  _$$_NumInUnionCopyWith<_$_NumInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

DateTimeInUnion _$DateTimeInUnionFromJson(Map<String, dynamic> json) {
  return _DateTimeInUnion.fromJson(json);
}

/// @nodoc
mixin _$DateTimeInUnion {
  DateTime get dateTimeValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DateTimeInUnionCopyWith<DateTimeInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DateTimeInUnionCopyWith<$Res> {
  factory $DateTimeInUnionCopyWith(
          DateTimeInUnion value, $Res Function(DateTimeInUnion) then) =
      _$DateTimeInUnionCopyWithImpl<$Res, DateTimeInUnion>;
  @useResult
  $Res call({DateTime dateTimeValue});
}

/// @nodoc
class _$DateTimeInUnionCopyWithImpl<$Res, $Val extends DateTimeInUnion>
    implements $DateTimeInUnionCopyWith<$Res> {
  _$DateTimeInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dateTimeValue = null,
  }) {
    return _then(_value.copyWith(
      dateTimeValue: null == dateTimeValue
          ? _value.dateTimeValue
          : dateTimeValue // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DateTimeInUnionCopyWith<$Res>
    implements $DateTimeInUnionCopyWith<$Res> {
  factory _$$_DateTimeInUnionCopyWith(
          _$_DateTimeInUnion value, $Res Function(_$_DateTimeInUnion) then) =
      __$$_DateTimeInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DateTime dateTimeValue});
}

/// @nodoc
class __$$_DateTimeInUnionCopyWithImpl<$Res>
    extends _$DateTimeInUnionCopyWithImpl<$Res, _$_DateTimeInUnion>
    implements _$$_DateTimeInUnionCopyWith<$Res> {
  __$$_DateTimeInUnionCopyWithImpl(
      _$_DateTimeInUnion _value, $Res Function(_$_DateTimeInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dateTimeValue = null,
  }) {
    return _then(_$_DateTimeInUnion(
      dateTimeValue: null == dateTimeValue
          ? _value.dateTimeValue
          : dateTimeValue // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DateTimeInUnion implements _DateTimeInUnion {
  const _$_DateTimeInUnion({required this.dateTimeValue});

  factory _$_DateTimeInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_DateTimeInUnionFromJson(json);

  @override
  final DateTime dateTimeValue;

  @override
  String toString() {
    return 'DateTimeInUnion(dateTimeValue: $dateTimeValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DateTimeInUnion &&
            (identical(other.dateTimeValue, dateTimeValue) ||
                other.dateTimeValue == dateTimeValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, dateTimeValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DateTimeInUnionCopyWith<_$_DateTimeInUnion> get copyWith =>
      __$$_DateTimeInUnionCopyWithImpl<_$_DateTimeInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DateTimeInUnionToJson(
      this,
    );
  }
}

abstract class _DateTimeInUnion implements DateTimeInUnion {
  const factory _DateTimeInUnion({required final DateTime dateTimeValue}) =
      _$_DateTimeInUnion;

  factory _DateTimeInUnion.fromJson(Map<String, dynamic> json) =
      _$_DateTimeInUnion.fromJson;

  @override
  DateTime get dateTimeValue;
  @override
  @JsonKey(ignore: true)
  _$$_DateTimeInUnionCopyWith<_$_DateTimeInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

Addressable _$AddressableFromJson(Map<String, dynamic> json) {
  return _Addressable.fromJson(json);
}

/// @nodoc
mixin _$Addressable {
  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href => throw _privateConstructorUsedError;

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AddressableCopyWith<Addressable> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddressableCopyWith<$Res> {
  factory $AddressableCopyWith(
          Addressable value, $Res Function(Addressable) then) =
      _$AddressableCopyWithImpl<$Res, Addressable>;
  @useResult
  $Res call(
      {@JsonKey(name: r'href') String? href, @JsonKey(name: r'id') String? id});
}

/// @nodoc
class _$AddressableCopyWithImpl<$Res, $Val extends Addressable>
    implements $AddressableCopyWith<$Res> {
  _$AddressableCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? href = freezed,
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AddressableCopyWith<$Res>
    implements $AddressableCopyWith<$Res> {
  factory _$$_AddressableCopyWith(
          _$_Addressable value, $Res Function(_$_Addressable) then) =
      __$$_AddressableCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'href') String? href, @JsonKey(name: r'id') String? id});
}

/// @nodoc
class __$$_AddressableCopyWithImpl<$Res>
    extends _$AddressableCopyWithImpl<$Res, _$_Addressable>
    implements _$$_AddressableCopyWith<$Res> {
  __$$_AddressableCopyWithImpl(
      _$_Addressable _value, $Res Function(_$_Addressable) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? href = freezed,
    Object? id = freezed,
  }) {
    return _then(_$_Addressable(
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Addressable extends _Addressable {
  const _$_Addressable(
      {@JsonKey(name: r'href') this.href, @JsonKey(name: r'id') this.id})
      : super._();

  factory _$_Addressable.fromJson(Map<String, dynamic> json) =>
      _$$_AddressableFromJson(json);

  /// Hyperlink reference
  @override
  @JsonKey(name: r'href')
  final String? href;

  /// unique identifier
  @override
  @JsonKey(name: r'id')
  final String? id;

  @override
  String toString() {
    return 'Addressable(href: $href, id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Addressable &&
            (identical(other.href, href) || other.href == href) &&
            (identical(other.id, id) || other.id == id));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, href, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AddressableCopyWith<_$_Addressable> get copyWith =>
      __$$_AddressableCopyWithImpl<_$_Addressable>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AddressableToJson(
      this,
    );
  }
}

abstract class _Addressable extends Addressable {
  const factory _Addressable(
      {@JsonKey(name: r'href') final String? href,
      @JsonKey(name: r'id') final String? id}) = _$_Addressable;
  const _Addressable._() : super._();

  factory _Addressable.fromJson(Map<String, dynamic> json) =
      _$_Addressable.fromJson;

  @override

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href;
  @override

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id;
  @override
  @JsonKey(ignore: true)
  _$$_AddressableCopyWith<_$_Addressable> get copyWith =>
      throw _privateConstructorUsedError;
}

Bar _$BarFromJson(Map<String, dynamic> json) {
  return _Bar.fromJson(json);
}

/// @nodoc
mixin _$Bar {
  @JsonKey(name: r'id')
  String get id => throw _privateConstructorUsedError;
  @JsonKey(name: r'barPropA')
  String? get barPropA => throw _privateConstructorUsedError;
  @JsonKey(name: r'fooPropB')
  String? get fooPropB => throw _privateConstructorUsedError;
  @JsonKey(name: r'foo')
  FooRefOrValue? get foo => throw _privateConstructorUsedError;

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href => throw _privateConstructorUsedError;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BarCopyWith<Bar> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BarCopyWith<$Res> {
  factory $BarCopyWith(Bar value, $Res Function(Bar) then) =
      _$BarCopyWithImpl<$Res, Bar>;
  @useResult
  $Res call(
      {@JsonKey(name: r'id') String id,
      @JsonKey(name: r'barPropA') String? barPropA,
      @JsonKey(name: r'fooPropB') String? fooPropB,
      @JsonKey(name: r'foo') FooRefOrValue? foo,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});

  $FooRefOrValueCopyWith<$Res>? get foo;
}

/// @nodoc
class _$BarCopyWithImpl<$Res, $Val extends Bar> implements $BarCopyWith<$Res> {
  _$BarCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? barPropA = freezed,
    Object? fooPropB = freezed,
    Object? foo = freezed,
    Object? href = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      barPropA: freezed == barPropA
          ? _value.barPropA
          : barPropA // ignore: cast_nullable_to_non_nullable
              as String?,
      fooPropB: freezed == fooPropB
          ? _value.fooPropB
          : fooPropB // ignore: cast_nullable_to_non_nullable
              as String?,
      foo: freezed == foo
          ? _value.foo
          : foo // ignore: cast_nullable_to_non_nullable
              as FooRefOrValue?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FooRefOrValueCopyWith<$Res>? get foo {
    if (_value.foo == null) {
      return null;
    }

    return $FooRefOrValueCopyWith<$Res>(_value.foo!, (value) {
      return _then(_value.copyWith(foo: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_BarCopyWith<$Res> implements $BarCopyWith<$Res> {
  factory _$$_BarCopyWith(_$_Bar value, $Res Function(_$_Bar) then) =
      __$$_BarCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'id') String id,
      @JsonKey(name: r'barPropA') String? barPropA,
      @JsonKey(name: r'fooPropB') String? fooPropB,
      @JsonKey(name: r'foo') FooRefOrValue? foo,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});

  @override
  $FooRefOrValueCopyWith<$Res>? get foo;
}

/// @nodoc
class __$$_BarCopyWithImpl<$Res> extends _$BarCopyWithImpl<$Res, _$_Bar>
    implements _$$_BarCopyWith<$Res> {
  __$$_BarCopyWithImpl(_$_Bar _value, $Res Function(_$_Bar) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? barPropA = freezed,
    Object? fooPropB = freezed,
    Object? foo = freezed,
    Object? href = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_$_Bar(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      barPropA: freezed == barPropA
          ? _value.barPropA
          : barPropA // ignore: cast_nullable_to_non_nullable
              as String?,
      fooPropB: freezed == fooPropB
          ? _value.fooPropB
          : fooPropB // ignore: cast_nullable_to_non_nullable
              as String?,
      foo: freezed == foo
          ? _value.foo
          : foo // ignore: cast_nullable_to_non_nullable
              as FooRefOrValue?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Bar extends _Bar {
  const _$_Bar(
      {@JsonKey(name: r'id') required this.id,
      @JsonKey(name: r'barPropA') this.barPropA,
      @JsonKey(name: r'fooPropB') this.fooPropB,
      @JsonKey(name: r'foo') this.foo,
      @JsonKey(name: r'href') this.href,
      @JsonKey(name: r'@schemaLocation') this.atSchemaLocation,
      @JsonKey(name: r'@baseType') this.atBaseType,
      @JsonKey(name: r'@type') required this.atType})
      : super._();

  factory _$_Bar.fromJson(Map<String, dynamic> json) => _$$_BarFromJson(json);

  @override
  @JsonKey(name: r'id')
  final String id;
  @override
  @JsonKey(name: r'barPropA')
  final String? barPropA;
  @override
  @JsonKey(name: r'fooPropB')
  final String? fooPropB;
  @override
  @JsonKey(name: r'foo')
  final FooRefOrValue? foo;

  /// Hyperlink reference
  @override
  @JsonKey(name: r'href')
  final String? href;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @override
  @JsonKey(name: r'@schemaLocation')
  final String? atSchemaLocation;

  /// When sub-classing, this defines the super-class
  @override
  @JsonKey(name: r'@baseType')
  final String? atBaseType;

  /// When sub-classing, this defines the sub-class Extensible name
  @override
  @JsonKey(name: r'@type')
  final String atType;

  @override
  String toString() {
    return 'Bar(id: $id, barPropA: $barPropA, fooPropB: $fooPropB, foo: $foo, href: $href, atSchemaLocation: $atSchemaLocation, atBaseType: $atBaseType, atType: $atType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Bar &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.barPropA, barPropA) ||
                other.barPropA == barPropA) &&
            (identical(other.fooPropB, fooPropB) ||
                other.fooPropB == fooPropB) &&
            (identical(other.foo, foo) || other.foo == foo) &&
            (identical(other.href, href) || other.href == href) &&
            (identical(other.atSchemaLocation, atSchemaLocation) ||
                other.atSchemaLocation == atSchemaLocation) &&
            (identical(other.atBaseType, atBaseType) ||
                other.atBaseType == atBaseType) &&
            (identical(other.atType, atType) || other.atType == atType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, barPropA, fooPropB, foo,
      href, atSchemaLocation, atBaseType, atType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BarCopyWith<_$_Bar> get copyWith =>
      __$$_BarCopyWithImpl<_$_Bar>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BarToJson(
      this,
    );
  }
}

abstract class _Bar extends Bar {
  const factory _Bar(
      {@JsonKey(name: r'id') required final String id,
      @JsonKey(name: r'barPropA') final String? barPropA,
      @JsonKey(name: r'fooPropB') final String? fooPropB,
      @JsonKey(name: r'foo') final FooRefOrValue? foo,
      @JsonKey(name: r'href') final String? href,
      @JsonKey(name: r'@schemaLocation') final String? atSchemaLocation,
      @JsonKey(name: r'@baseType') final String? atBaseType,
      @JsonKey(name: r'@type') required final String atType}) = _$_Bar;
  const _Bar._() : super._();

  factory _Bar.fromJson(Map<String, dynamic> json) = _$_Bar.fromJson;

  @override
  @JsonKey(name: r'id')
  String get id;
  @override
  @JsonKey(name: r'barPropA')
  String? get barPropA;
  @override
  @JsonKey(name: r'fooPropB')
  String? get fooPropB;
  @override
  @JsonKey(name: r'foo')
  FooRefOrValue? get foo;
  @override

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href;
  @override

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation;
  @override

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType;
  @override

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType;
  @override
  @JsonKey(ignore: true)
  _$$_BarCopyWith<_$_Bar> get copyWith => throw _privateConstructorUsedError;
}

BarCreate _$BarCreateFromJson(Map<String, dynamic> json) {
  return _BarCreate.fromJson(json);
}

/// @nodoc
mixin _$BarCreate {
  @JsonKey(name: r'barPropA')
  String? get barPropA => throw _privateConstructorUsedError;
  @JsonKey(name: r'fooPropB')
  String? get fooPropB => throw _privateConstructorUsedError;
  @JsonKey(name: r'foo')
  FooRefOrValue? get foo => throw _privateConstructorUsedError;

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href => throw _privateConstructorUsedError;

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id => throw _privateConstructorUsedError;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BarCreateCopyWith<BarCreate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BarCreateCopyWith<$Res> {
  factory $BarCreateCopyWith(BarCreate value, $Res Function(BarCreate) then) =
      _$BarCreateCopyWithImpl<$Res, BarCreate>;
  @useResult
  $Res call(
      {@JsonKey(name: r'barPropA') String? barPropA,
      @JsonKey(name: r'fooPropB') String? fooPropB,
      @JsonKey(name: r'foo') FooRefOrValue? foo,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});

  $FooRefOrValueCopyWith<$Res>? get foo;
}

/// @nodoc
class _$BarCreateCopyWithImpl<$Res, $Val extends BarCreate>
    implements $BarCreateCopyWith<$Res> {
  _$BarCreateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? barPropA = freezed,
    Object? fooPropB = freezed,
    Object? foo = freezed,
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_value.copyWith(
      barPropA: freezed == barPropA
          ? _value.barPropA
          : barPropA // ignore: cast_nullable_to_non_nullable
              as String?,
      fooPropB: freezed == fooPropB
          ? _value.fooPropB
          : fooPropB // ignore: cast_nullable_to_non_nullable
              as String?,
      foo: freezed == foo
          ? _value.foo
          : foo // ignore: cast_nullable_to_non_nullable
              as FooRefOrValue?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FooRefOrValueCopyWith<$Res>? get foo {
    if (_value.foo == null) {
      return null;
    }

    return $FooRefOrValueCopyWith<$Res>(_value.foo!, (value) {
      return _then(_value.copyWith(foo: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_BarCreateCopyWith<$Res> implements $BarCreateCopyWith<$Res> {
  factory _$$_BarCreateCopyWith(
          _$_BarCreate value, $Res Function(_$_BarCreate) then) =
      __$$_BarCreateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'barPropA') String? barPropA,
      @JsonKey(name: r'fooPropB') String? fooPropB,
      @JsonKey(name: r'foo') FooRefOrValue? foo,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});

  @override
  $FooRefOrValueCopyWith<$Res>? get foo;
}

/// @nodoc
class __$$_BarCreateCopyWithImpl<$Res>
    extends _$BarCreateCopyWithImpl<$Res, _$_BarCreate>
    implements _$$_BarCreateCopyWith<$Res> {
  __$$_BarCreateCopyWithImpl(
      _$_BarCreate _value, $Res Function(_$_BarCreate) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? barPropA = freezed,
    Object? fooPropB = freezed,
    Object? foo = freezed,
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_$_BarCreate(
      barPropA: freezed == barPropA
          ? _value.barPropA
          : barPropA // ignore: cast_nullable_to_non_nullable
              as String?,
      fooPropB: freezed == fooPropB
          ? _value.fooPropB
          : fooPropB // ignore: cast_nullable_to_non_nullable
              as String?,
      foo: freezed == foo
          ? _value.foo
          : foo // ignore: cast_nullable_to_non_nullable
              as FooRefOrValue?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BarCreate extends _BarCreate {
  const _$_BarCreate(
      {@JsonKey(name: r'barPropA') this.barPropA,
      @JsonKey(name: r'fooPropB') this.fooPropB,
      @JsonKey(name: r'foo') this.foo,
      @JsonKey(name: r'href') this.href,
      @JsonKey(name: r'id') this.id,
      @JsonKey(name: r'@schemaLocation') this.atSchemaLocation,
      @JsonKey(name: r'@baseType') this.atBaseType,
      @JsonKey(name: r'@type') required this.atType})
      : super._();

  factory _$_BarCreate.fromJson(Map<String, dynamic> json) =>
      _$$_BarCreateFromJson(json);

  @override
  @JsonKey(name: r'barPropA')
  final String? barPropA;
  @override
  @JsonKey(name: r'fooPropB')
  final String? fooPropB;
  @override
  @JsonKey(name: r'foo')
  final FooRefOrValue? foo;

  /// Hyperlink reference
  @override
  @JsonKey(name: r'href')
  final String? href;

  /// unique identifier
  @override
  @JsonKey(name: r'id')
  final String? id;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @override
  @JsonKey(name: r'@schemaLocation')
  final String? atSchemaLocation;

  /// When sub-classing, this defines the super-class
  @override
  @JsonKey(name: r'@baseType')
  final String? atBaseType;

  /// When sub-classing, this defines the sub-class Extensible name
  @override
  @JsonKey(name: r'@type')
  final String atType;

  @override
  String toString() {
    return 'BarCreate(barPropA: $barPropA, fooPropB: $fooPropB, foo: $foo, href: $href, id: $id, atSchemaLocation: $atSchemaLocation, atBaseType: $atBaseType, atType: $atType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BarCreate &&
            (identical(other.barPropA, barPropA) ||
                other.barPropA == barPropA) &&
            (identical(other.fooPropB, fooPropB) ||
                other.fooPropB == fooPropB) &&
            (identical(other.foo, foo) || other.foo == foo) &&
            (identical(other.href, href) || other.href == href) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.atSchemaLocation, atSchemaLocation) ||
                other.atSchemaLocation == atSchemaLocation) &&
            (identical(other.atBaseType, atBaseType) ||
                other.atBaseType == atBaseType) &&
            (identical(other.atType, atType) || other.atType == atType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, barPropA, fooPropB, foo, href,
      id, atSchemaLocation, atBaseType, atType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BarCreateCopyWith<_$_BarCreate> get copyWith =>
      __$$_BarCreateCopyWithImpl<_$_BarCreate>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BarCreateToJson(
      this,
    );
  }
}

abstract class _BarCreate extends BarCreate {
  const factory _BarCreate(
      {@JsonKey(name: r'barPropA') final String? barPropA,
      @JsonKey(name: r'fooPropB') final String? fooPropB,
      @JsonKey(name: r'foo') final FooRefOrValue? foo,
      @JsonKey(name: r'href') final String? href,
      @JsonKey(name: r'id') final String? id,
      @JsonKey(name: r'@schemaLocation') final String? atSchemaLocation,
      @JsonKey(name: r'@baseType') final String? atBaseType,
      @JsonKey(name: r'@type') required final String atType}) = _$_BarCreate;
  const _BarCreate._() : super._();

  factory _BarCreate.fromJson(Map<String, dynamic> json) =
      _$_BarCreate.fromJson;

  @override
  @JsonKey(name: r'barPropA')
  String? get barPropA;
  @override
  @JsonKey(name: r'fooPropB')
  String? get fooPropB;
  @override
  @JsonKey(name: r'foo')
  FooRefOrValue? get foo;
  @override

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href;
  @override

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id;
  @override

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation;
  @override

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType;
  @override

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType;
  @override
  @JsonKey(ignore: true)
  _$$_BarCreateCopyWith<_$_BarCreate> get copyWith =>
      throw _privateConstructorUsedError;
}

BarRef _$BarRefFromJson(Map<String, dynamic> json) {
  return _BarRef.fromJson(json);
}

/// @nodoc
mixin _$BarRef {
  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href => throw _privateConstructorUsedError;

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id => throw _privateConstructorUsedError;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BarRefCopyWith<BarRef> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BarRefCopyWith<$Res> {
  factory $BarRefCopyWith(BarRef value, $Res Function(BarRef) then) =
      _$BarRefCopyWithImpl<$Res, BarRef>;
  @useResult
  $Res call(
      {@JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class _$BarRefCopyWithImpl<$Res, $Val extends BarRef>
    implements $BarRefCopyWith<$Res> {
  _$BarRefCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_value.copyWith(
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BarRefCopyWith<$Res> implements $BarRefCopyWith<$Res> {
  factory _$$_BarRefCopyWith(_$_BarRef value, $Res Function(_$_BarRef) then) =
      __$$_BarRefCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class __$$_BarRefCopyWithImpl<$Res>
    extends _$BarRefCopyWithImpl<$Res, _$_BarRef>
    implements _$$_BarRefCopyWith<$Res> {
  __$$_BarRefCopyWithImpl(_$_BarRef _value, $Res Function(_$_BarRef) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_$_BarRef(
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BarRef extends _BarRef {
  const _$_BarRef(
      {@JsonKey(name: r'href') this.href,
      @JsonKey(name: r'id') this.id,
      @JsonKey(name: r'@schemaLocation') this.atSchemaLocation,
      @JsonKey(name: r'@baseType') this.atBaseType,
      @JsonKey(name: r'@type') required this.atType})
      : super._();

  factory _$_BarRef.fromJson(Map<String, dynamic> json) =>
      _$$_BarRefFromJson(json);

  /// Hyperlink reference
  @override
  @JsonKey(name: r'href')
  final String? href;

  /// unique identifier
  @override
  @JsonKey(name: r'id')
  final String? id;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @override
  @JsonKey(name: r'@schemaLocation')
  final String? atSchemaLocation;

  /// When sub-classing, this defines the super-class
  @override
  @JsonKey(name: r'@baseType')
  final String? atBaseType;

  /// When sub-classing, this defines the sub-class Extensible name
  @override
  @JsonKey(name: r'@type')
  final String atType;

  @override
  String toString() {
    return 'BarRef(href: $href, id: $id, atSchemaLocation: $atSchemaLocation, atBaseType: $atBaseType, atType: $atType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BarRef &&
            (identical(other.href, href) || other.href == href) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.atSchemaLocation, atSchemaLocation) ||
                other.atSchemaLocation == atSchemaLocation) &&
            (identical(other.atBaseType, atBaseType) ||
                other.atBaseType == atBaseType) &&
            (identical(other.atType, atType) || other.atType == atType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, href, id, atSchemaLocation, atBaseType, atType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BarRefCopyWith<_$_BarRef> get copyWith =>
      __$$_BarRefCopyWithImpl<_$_BarRef>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BarRefToJson(
      this,
    );
  }
}

abstract class _BarRef extends BarRef {
  const factory _BarRef(
      {@JsonKey(name: r'href') final String? href,
      @JsonKey(name: r'id') final String? id,
      @JsonKey(name: r'@schemaLocation') final String? atSchemaLocation,
      @JsonKey(name: r'@baseType') final String? atBaseType,
      @JsonKey(name: r'@type') required final String atType}) = _$_BarRef;
  const _BarRef._() : super._();

  factory _BarRef.fromJson(Map<String, dynamic> json) = _$_BarRef.fromJson;

  @override

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href;
  @override

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id;
  @override

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation;
  @override

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType;
  @override

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType;
  @override
  @JsonKey(ignore: true)
  _$$_BarRefCopyWith<_$_BarRef> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BarRefOrValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bar barValue) asBar,
    required TResult Function(BarRef barRefValue) asBarRef,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BarRefOrValue> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bar barValue)? asBar,
    TResult? Function(BarRef barRefValue)? asBarRef,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BarRefOrValue> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bar barValue)? asBar,
    TResult Function(BarRef barRefValue)? asBarRef,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BarRefOrValue> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BarRefOrValueAsBar value) asBar,
    required TResult Function(BarRefOrValueAsBarRef value) asBarRef,
    required TResult Function(BarRefOrValueUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BarRefOrValueAsBar value)? asBar,
    TResult? Function(BarRefOrValueAsBarRef value)? asBarRef,
    TResult? Function(BarRefOrValueUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BarRefOrValueAsBar value)? asBar,
    TResult Function(BarRefOrValueAsBarRef value)? asBarRef,
    TResult Function(BarRefOrValueUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BarRefOrValueCopyWith<$Res> {
  factory $BarRefOrValueCopyWith(
          BarRefOrValue value, $Res Function(BarRefOrValue) then) =
      _$BarRefOrValueCopyWithImpl<$Res, BarRefOrValue>;
}

/// @nodoc
class _$BarRefOrValueCopyWithImpl<$Res, $Val extends BarRefOrValue>
    implements $BarRefOrValueCopyWith<$Res> {
  _$BarRefOrValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$BarRefOrValueAsBarCopyWith<$Res> {
  factory _$$BarRefOrValueAsBarCopyWith(_$BarRefOrValueAsBar value,
          $Res Function(_$BarRefOrValueAsBar) then) =
      __$$BarRefOrValueAsBarCopyWithImpl<$Res>;
  @useResult
  $Res call({Bar barValue});

  $BarCopyWith<$Res> get barValue;
}

/// @nodoc
class __$$BarRefOrValueAsBarCopyWithImpl<$Res>
    extends _$BarRefOrValueCopyWithImpl<$Res, _$BarRefOrValueAsBar>
    implements _$$BarRefOrValueAsBarCopyWith<$Res> {
  __$$BarRefOrValueAsBarCopyWithImpl(
      _$BarRefOrValueAsBar _value, $Res Function(_$BarRefOrValueAsBar) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? barValue = null,
  }) {
    return _then(_$BarRefOrValueAsBar(
      barValue: null == barValue
          ? _value.barValue
          : barValue // ignore: cast_nullable_to_non_nullable
              as Bar,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BarCopyWith<$Res> get barValue {
    return $BarCopyWith<$Res>(_value.barValue, (value) {
      return _then(_value.copyWith(barValue: value));
    });
  }
}

/// @nodoc

class _$BarRefOrValueAsBar extends BarRefOrValueAsBar {
  const _$BarRefOrValueAsBar({required this.barValue}) : super._();

  @override
  final Bar barValue;

  @override
  String toString() {
    return 'BarRefOrValue.asBar(barValue: $barValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BarRefOrValueAsBar &&
            (identical(other.barValue, barValue) ||
                other.barValue == barValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, barValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BarRefOrValueAsBarCopyWith<_$BarRefOrValueAsBar> get copyWith =>
      __$$BarRefOrValueAsBarCopyWithImpl<_$BarRefOrValueAsBar>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bar barValue) asBar,
    required TResult Function(BarRef barRefValue) asBarRef,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BarRefOrValue> deserializedModels)
        unknown,
  }) {
    return asBar(barValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bar barValue)? asBar,
    TResult? Function(BarRef barRefValue)? asBarRef,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BarRefOrValue> deserializedModels)?
        unknown,
  }) {
    return asBar?.call(barValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bar barValue)? asBar,
    TResult Function(BarRef barRefValue)? asBarRef,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BarRefOrValue> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asBar != null) {
      return asBar(barValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BarRefOrValueAsBar value) asBar,
    required TResult Function(BarRefOrValueAsBarRef value) asBarRef,
    required TResult Function(BarRefOrValueUnknown value) unknown,
  }) {
    return asBar(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BarRefOrValueAsBar value)? asBar,
    TResult? Function(BarRefOrValueAsBarRef value)? asBarRef,
    TResult? Function(BarRefOrValueUnknown value)? unknown,
  }) {
    return asBar?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BarRefOrValueAsBar value)? asBar,
    TResult Function(BarRefOrValueAsBarRef value)? asBarRef,
    TResult Function(BarRefOrValueUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asBar != null) {
      return asBar(this);
    }
    return orElse();
  }
}

abstract class BarRefOrValueAsBar extends BarRefOrValue {
  const factory BarRefOrValueAsBar({required final Bar barValue}) =
      _$BarRefOrValueAsBar;
  const BarRefOrValueAsBar._() : super._();

  Bar get barValue;
  @JsonKey(ignore: true)
  _$$BarRefOrValueAsBarCopyWith<_$BarRefOrValueAsBar> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BarRefOrValueAsBarRefCopyWith<$Res> {
  factory _$$BarRefOrValueAsBarRefCopyWith(_$BarRefOrValueAsBarRef value,
          $Res Function(_$BarRefOrValueAsBarRef) then) =
      __$$BarRefOrValueAsBarRefCopyWithImpl<$Res>;
  @useResult
  $Res call({BarRef barRefValue});

  $BarRefCopyWith<$Res> get barRefValue;
}

/// @nodoc
class __$$BarRefOrValueAsBarRefCopyWithImpl<$Res>
    extends _$BarRefOrValueCopyWithImpl<$Res, _$BarRefOrValueAsBarRef>
    implements _$$BarRefOrValueAsBarRefCopyWith<$Res> {
  __$$BarRefOrValueAsBarRefCopyWithImpl(_$BarRefOrValueAsBarRef _value,
      $Res Function(_$BarRefOrValueAsBarRef) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? barRefValue = null,
  }) {
    return _then(_$BarRefOrValueAsBarRef(
      barRefValue: null == barRefValue
          ? _value.barRefValue
          : barRefValue // ignore: cast_nullable_to_non_nullable
              as BarRef,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BarRefCopyWith<$Res> get barRefValue {
    return $BarRefCopyWith<$Res>(_value.barRefValue, (value) {
      return _then(_value.copyWith(barRefValue: value));
    });
  }
}

/// @nodoc

class _$BarRefOrValueAsBarRef extends BarRefOrValueAsBarRef {
  const _$BarRefOrValueAsBarRef({required this.barRefValue}) : super._();

  @override
  final BarRef barRefValue;

  @override
  String toString() {
    return 'BarRefOrValue.asBarRef(barRefValue: $barRefValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BarRefOrValueAsBarRef &&
            (identical(other.barRefValue, barRefValue) ||
                other.barRefValue == barRefValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, barRefValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BarRefOrValueAsBarRefCopyWith<_$BarRefOrValueAsBarRef> get copyWith =>
      __$$BarRefOrValueAsBarRefCopyWithImpl<_$BarRefOrValueAsBarRef>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bar barValue) asBar,
    required TResult Function(BarRef barRefValue) asBarRef,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BarRefOrValue> deserializedModels)
        unknown,
  }) {
    return asBarRef(barRefValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bar barValue)? asBar,
    TResult? Function(BarRef barRefValue)? asBarRef,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BarRefOrValue> deserializedModels)?
        unknown,
  }) {
    return asBarRef?.call(barRefValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bar barValue)? asBar,
    TResult Function(BarRef barRefValue)? asBarRef,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BarRefOrValue> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asBarRef != null) {
      return asBarRef(barRefValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BarRefOrValueAsBar value) asBar,
    required TResult Function(BarRefOrValueAsBarRef value) asBarRef,
    required TResult Function(BarRefOrValueUnknown value) unknown,
  }) {
    return asBarRef(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BarRefOrValueAsBar value)? asBar,
    TResult? Function(BarRefOrValueAsBarRef value)? asBarRef,
    TResult? Function(BarRefOrValueUnknown value)? unknown,
  }) {
    return asBarRef?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BarRefOrValueAsBar value)? asBar,
    TResult Function(BarRefOrValueAsBarRef value)? asBarRef,
    TResult Function(BarRefOrValueUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asBarRef != null) {
      return asBarRef(this);
    }
    return orElse();
  }
}

abstract class BarRefOrValueAsBarRef extends BarRefOrValue {
  const factory BarRefOrValueAsBarRef({required final BarRef barRefValue}) =
      _$BarRefOrValueAsBarRef;
  const BarRefOrValueAsBarRef._() : super._();

  BarRef get barRefValue;
  @JsonKey(ignore: true)
  _$$BarRefOrValueAsBarRefCopyWith<_$BarRefOrValueAsBarRef> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BarRefOrValueUnknownCopyWith<$Res> {
  factory _$$BarRefOrValueUnknownCopyWith(_$BarRefOrValueUnknown value,
          $Res Function(_$BarRefOrValueUnknown) then) =
      __$$BarRefOrValueUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<BarRefOrValue> deserializedModels});
}

/// @nodoc
class __$$BarRefOrValueUnknownCopyWithImpl<$Res>
    extends _$BarRefOrValueCopyWithImpl<$Res, _$BarRefOrValueUnknown>
    implements _$$BarRefOrValueUnknownCopyWith<$Res> {
  __$$BarRefOrValueUnknownCopyWithImpl(_$BarRefOrValueUnknown _value,
      $Res Function(_$BarRefOrValueUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$BarRefOrValueUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<BarRefOrValue>,
    ));
  }
}

/// @nodoc

class _$BarRefOrValueUnknown extends BarRefOrValueUnknown {
  const _$BarRefOrValueUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[Bar, BarRef],
      final List<BarRefOrValue> deserializedModels = const <BarRefOrValue>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<BarRefOrValue> _deserializedModels;
  @override
  @JsonKey()
  List<BarRefOrValue> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'BarRefOrValue.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BarRefOrValueUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BarRefOrValueUnknownCopyWith<_$BarRefOrValueUnknown> get copyWith =>
      __$$BarRefOrValueUnknownCopyWithImpl<_$BarRefOrValueUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bar barValue) asBar,
    required TResult Function(BarRef barRefValue) asBarRef,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BarRefOrValue> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bar barValue)? asBar,
    TResult? Function(BarRef barRefValue)? asBarRef,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BarRefOrValue> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bar barValue)? asBar,
    TResult Function(BarRef barRefValue)? asBarRef,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BarRefOrValue> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BarRefOrValueAsBar value) asBar,
    required TResult Function(BarRefOrValueAsBarRef value) asBarRef,
    required TResult Function(BarRefOrValueUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BarRefOrValueAsBar value)? asBar,
    TResult? Function(BarRefOrValueAsBarRef value)? asBarRef,
    TResult? Function(BarRefOrValueUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BarRefOrValueAsBar value)? asBar,
    TResult Function(BarRefOrValueAsBarRef value)? asBarRef,
    TResult Function(BarRefOrValueUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class BarRefOrValueUnknown extends BarRefOrValue {
  const factory BarRefOrValueUnknown(
      {final String message,
      required final Map<String, dynamic> json,
      final DeserializationErrorType errorType,
      final List<Type> possibleTypes,
      final List<BarRefOrValue> deserializedModels}) = _$BarRefOrValueUnknown;
  const BarRefOrValueUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<BarRefOrValue> get deserializedModels;
  @JsonKey(ignore: true)
  _$$BarRefOrValueUnknownCopyWith<_$BarRefOrValueUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Entity {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bar bar) bar,
    required TResult Function(BarCreate barCreate) barCreate,
    required TResult Function(Foo foo) foo,
    required TResult Function(Pasta pasta) pasta,
    required TResult Function(Pizza pizza) pizza,
    required TResult Function(PizzaSpeziale pizzaSpeziale) pizzaspeziale,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bar bar)? bar,
    TResult? Function(BarCreate barCreate)? barCreate,
    TResult? Function(Foo foo)? foo,
    TResult? Function(Pasta pasta)? pasta,
    TResult? Function(Pizza pizza)? pizza,
    TResult? Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bar bar)? bar,
    TResult Function(BarCreate barCreate)? barCreate,
    TResult Function(Foo foo)? foo,
    TResult Function(Pasta pasta)? pasta,
    TResult Function(Pizza pizza)? pizza,
    TResult Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntityBar value) bar,
    required TResult Function(EntityBar_create value) barCreate,
    required TResult Function(EntityFoo value) foo,
    required TResult Function(EntityPasta value) pasta,
    required TResult Function(EntityPizza value) pizza,
    required TResult Function(EntityPizzaspeziale value) pizzaspeziale,
    required TResult Function(EntityUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntityBar value)? bar,
    TResult? Function(EntityBar_create value)? barCreate,
    TResult? Function(EntityFoo value)? foo,
    TResult? Function(EntityPasta value)? pasta,
    TResult? Function(EntityPizza value)? pizza,
    TResult? Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult? Function(EntityUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntityBar value)? bar,
    TResult Function(EntityBar_create value)? barCreate,
    TResult Function(EntityFoo value)? foo,
    TResult Function(EntityPasta value)? pasta,
    TResult Function(EntityPizza value)? pizza,
    TResult Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult Function(EntityUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityCopyWith<$Res> {
  factory $EntityCopyWith(Entity value, $Res Function(Entity) then) =
      _$EntityCopyWithImpl<$Res, Entity>;
}

/// @nodoc
class _$EntityCopyWithImpl<$Res, $Val extends Entity>
    implements $EntityCopyWith<$Res> {
  _$EntityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EntityBarCopyWith<$Res> {
  factory _$$EntityBarCopyWith(
          _$EntityBar value, $Res Function(_$EntityBar) then) =
      __$$EntityBarCopyWithImpl<$Res>;
  @useResult
  $Res call({Bar bar});

  $BarCopyWith<$Res> get bar;
}

/// @nodoc
class __$$EntityBarCopyWithImpl<$Res>
    extends _$EntityCopyWithImpl<$Res, _$EntityBar>
    implements _$$EntityBarCopyWith<$Res> {
  __$$EntityBarCopyWithImpl(
      _$EntityBar _value, $Res Function(_$EntityBar) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bar = null,
  }) {
    return _then(_$EntityBar(
      bar: null == bar
          ? _value.bar
          : bar // ignore: cast_nullable_to_non_nullable
              as Bar,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BarCopyWith<$Res> get bar {
    return $BarCopyWith<$Res>(_value.bar, (value) {
      return _then(_value.copyWith(bar: value));
    });
  }
}

/// @nodoc

class _$EntityBar extends EntityBar {
  const _$EntityBar({required this.bar}) : super._();

  @override
  final Bar bar;

  @override
  String toString() {
    return 'Entity.bar(bar: $bar)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntityBar &&
            (identical(other.bar, bar) || other.bar == bar));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bar);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntityBarCopyWith<_$EntityBar> get copyWith =>
      __$$EntityBarCopyWithImpl<_$EntityBar>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bar bar) bar,
    required TResult Function(BarCreate barCreate) barCreate,
    required TResult Function(Foo foo) foo,
    required TResult Function(Pasta pasta) pasta,
    required TResult Function(Pizza pizza) pizza,
    required TResult Function(PizzaSpeziale pizzaSpeziale) pizzaspeziale,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)
        unknown,
  }) {
    return bar(this.bar);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bar bar)? bar,
    TResult? Function(BarCreate barCreate)? barCreate,
    TResult? Function(Foo foo)? foo,
    TResult? Function(Pasta pasta)? pasta,
    TResult? Function(Pizza pizza)? pizza,
    TResult? Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
  }) {
    return bar?.call(this.bar);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bar bar)? bar,
    TResult Function(BarCreate barCreate)? barCreate,
    TResult Function(Foo foo)? foo,
    TResult Function(Pasta pasta)? pasta,
    TResult Function(Pizza pizza)? pizza,
    TResult Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (bar != null) {
      return bar(this.bar);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntityBar value) bar,
    required TResult Function(EntityBar_create value) barCreate,
    required TResult Function(EntityFoo value) foo,
    required TResult Function(EntityPasta value) pasta,
    required TResult Function(EntityPizza value) pizza,
    required TResult Function(EntityPizzaspeziale value) pizzaspeziale,
    required TResult Function(EntityUnknown value) unknown,
  }) {
    return bar(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntityBar value)? bar,
    TResult? Function(EntityBar_create value)? barCreate,
    TResult? Function(EntityFoo value)? foo,
    TResult? Function(EntityPasta value)? pasta,
    TResult? Function(EntityPizza value)? pizza,
    TResult? Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult? Function(EntityUnknown value)? unknown,
  }) {
    return bar?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntityBar value)? bar,
    TResult Function(EntityBar_create value)? barCreate,
    TResult Function(EntityFoo value)? foo,
    TResult Function(EntityPasta value)? pasta,
    TResult Function(EntityPizza value)? pizza,
    TResult Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult Function(EntityUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (bar != null) {
      return bar(this);
    }
    return orElse();
  }
}

abstract class EntityBar extends Entity {
  const factory EntityBar({required final Bar bar}) = _$EntityBar;
  const EntityBar._() : super._();

  Bar get bar;
  @JsonKey(ignore: true)
  _$$EntityBarCopyWith<_$EntityBar> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EntityBar_createCopyWith<$Res> {
  factory _$$EntityBar_createCopyWith(
          _$EntityBar_create value, $Res Function(_$EntityBar_create) then) =
      __$$EntityBar_createCopyWithImpl<$Res>;
  @useResult
  $Res call({BarCreate barCreate});

  $BarCreateCopyWith<$Res> get barCreate;
}

/// @nodoc
class __$$EntityBar_createCopyWithImpl<$Res>
    extends _$EntityCopyWithImpl<$Res, _$EntityBar_create>
    implements _$$EntityBar_createCopyWith<$Res> {
  __$$EntityBar_createCopyWithImpl(
      _$EntityBar_create _value, $Res Function(_$EntityBar_create) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? barCreate = null,
  }) {
    return _then(_$EntityBar_create(
      barCreate: null == barCreate
          ? _value.barCreate
          : barCreate // ignore: cast_nullable_to_non_nullable
              as BarCreate,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BarCreateCopyWith<$Res> get barCreate {
    return $BarCreateCopyWith<$Res>(_value.barCreate, (value) {
      return _then(_value.copyWith(barCreate: value));
    });
  }
}

/// @nodoc

class _$EntityBar_create extends EntityBar_create {
  const _$EntityBar_create({required this.barCreate}) : super._();

  @override
  final BarCreate barCreate;

  @override
  String toString() {
    return 'Entity.barCreate(barCreate: $barCreate)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntityBar_create &&
            (identical(other.barCreate, barCreate) ||
                other.barCreate == barCreate));
  }

  @override
  int get hashCode => Object.hash(runtimeType, barCreate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntityBar_createCopyWith<_$EntityBar_create> get copyWith =>
      __$$EntityBar_createCopyWithImpl<_$EntityBar_create>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bar bar) bar,
    required TResult Function(BarCreate barCreate) barCreate,
    required TResult Function(Foo foo) foo,
    required TResult Function(Pasta pasta) pasta,
    required TResult Function(Pizza pizza) pizza,
    required TResult Function(PizzaSpeziale pizzaSpeziale) pizzaspeziale,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)
        unknown,
  }) {
    return barCreate(this.barCreate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bar bar)? bar,
    TResult? Function(BarCreate barCreate)? barCreate,
    TResult? Function(Foo foo)? foo,
    TResult? Function(Pasta pasta)? pasta,
    TResult? Function(Pizza pizza)? pizza,
    TResult? Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
  }) {
    return barCreate?.call(this.barCreate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bar bar)? bar,
    TResult Function(BarCreate barCreate)? barCreate,
    TResult Function(Foo foo)? foo,
    TResult Function(Pasta pasta)? pasta,
    TResult Function(Pizza pizza)? pizza,
    TResult Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (barCreate != null) {
      return barCreate(this.barCreate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntityBar value) bar,
    required TResult Function(EntityBar_create value) barCreate,
    required TResult Function(EntityFoo value) foo,
    required TResult Function(EntityPasta value) pasta,
    required TResult Function(EntityPizza value) pizza,
    required TResult Function(EntityPizzaspeziale value) pizzaspeziale,
    required TResult Function(EntityUnknown value) unknown,
  }) {
    return barCreate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntityBar value)? bar,
    TResult? Function(EntityBar_create value)? barCreate,
    TResult? Function(EntityFoo value)? foo,
    TResult? Function(EntityPasta value)? pasta,
    TResult? Function(EntityPizza value)? pizza,
    TResult? Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult? Function(EntityUnknown value)? unknown,
  }) {
    return barCreate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntityBar value)? bar,
    TResult Function(EntityBar_create value)? barCreate,
    TResult Function(EntityFoo value)? foo,
    TResult Function(EntityPasta value)? pasta,
    TResult Function(EntityPizza value)? pizza,
    TResult Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult Function(EntityUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (barCreate != null) {
      return barCreate(this);
    }
    return orElse();
  }
}

abstract class EntityBar_create extends Entity {
  const factory EntityBar_create({required final BarCreate barCreate}) =
      _$EntityBar_create;
  const EntityBar_create._() : super._();

  BarCreate get barCreate;
  @JsonKey(ignore: true)
  _$$EntityBar_createCopyWith<_$EntityBar_create> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EntityFooCopyWith<$Res> {
  factory _$$EntityFooCopyWith(
          _$EntityFoo value, $Res Function(_$EntityFoo) then) =
      __$$EntityFooCopyWithImpl<$Res>;
  @useResult
  $Res call({Foo foo});

  $FooCopyWith<$Res> get foo;
}

/// @nodoc
class __$$EntityFooCopyWithImpl<$Res>
    extends _$EntityCopyWithImpl<$Res, _$EntityFoo>
    implements _$$EntityFooCopyWith<$Res> {
  __$$EntityFooCopyWithImpl(
      _$EntityFoo _value, $Res Function(_$EntityFoo) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? foo = null,
  }) {
    return _then(_$EntityFoo(
      foo: null == foo
          ? _value.foo
          : foo // ignore: cast_nullable_to_non_nullable
              as Foo,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FooCopyWith<$Res> get foo {
    return $FooCopyWith<$Res>(_value.foo, (value) {
      return _then(_value.copyWith(foo: value));
    });
  }
}

/// @nodoc

class _$EntityFoo extends EntityFoo {
  const _$EntityFoo({required this.foo}) : super._();

  @override
  final Foo foo;

  @override
  String toString() {
    return 'Entity.foo(foo: $foo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntityFoo &&
            (identical(other.foo, foo) || other.foo == foo));
  }

  @override
  int get hashCode => Object.hash(runtimeType, foo);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntityFooCopyWith<_$EntityFoo> get copyWith =>
      __$$EntityFooCopyWithImpl<_$EntityFoo>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bar bar) bar,
    required TResult Function(BarCreate barCreate) barCreate,
    required TResult Function(Foo foo) foo,
    required TResult Function(Pasta pasta) pasta,
    required TResult Function(Pizza pizza) pizza,
    required TResult Function(PizzaSpeziale pizzaSpeziale) pizzaspeziale,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)
        unknown,
  }) {
    return foo(this.foo);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bar bar)? bar,
    TResult? Function(BarCreate barCreate)? barCreate,
    TResult? Function(Foo foo)? foo,
    TResult? Function(Pasta pasta)? pasta,
    TResult? Function(Pizza pizza)? pizza,
    TResult? Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
  }) {
    return foo?.call(this.foo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bar bar)? bar,
    TResult Function(BarCreate barCreate)? barCreate,
    TResult Function(Foo foo)? foo,
    TResult Function(Pasta pasta)? pasta,
    TResult Function(Pizza pizza)? pizza,
    TResult Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (foo != null) {
      return foo(this.foo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntityBar value) bar,
    required TResult Function(EntityBar_create value) barCreate,
    required TResult Function(EntityFoo value) foo,
    required TResult Function(EntityPasta value) pasta,
    required TResult Function(EntityPizza value) pizza,
    required TResult Function(EntityPizzaspeziale value) pizzaspeziale,
    required TResult Function(EntityUnknown value) unknown,
  }) {
    return foo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntityBar value)? bar,
    TResult? Function(EntityBar_create value)? barCreate,
    TResult? Function(EntityFoo value)? foo,
    TResult? Function(EntityPasta value)? pasta,
    TResult? Function(EntityPizza value)? pizza,
    TResult? Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult? Function(EntityUnknown value)? unknown,
  }) {
    return foo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntityBar value)? bar,
    TResult Function(EntityBar_create value)? barCreate,
    TResult Function(EntityFoo value)? foo,
    TResult Function(EntityPasta value)? pasta,
    TResult Function(EntityPizza value)? pizza,
    TResult Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult Function(EntityUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (foo != null) {
      return foo(this);
    }
    return orElse();
  }
}

abstract class EntityFoo extends Entity {
  const factory EntityFoo({required final Foo foo}) = _$EntityFoo;
  const EntityFoo._() : super._();

  Foo get foo;
  @JsonKey(ignore: true)
  _$$EntityFooCopyWith<_$EntityFoo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EntityPastaCopyWith<$Res> {
  factory _$$EntityPastaCopyWith(
          _$EntityPasta value, $Res Function(_$EntityPasta) then) =
      __$$EntityPastaCopyWithImpl<$Res>;
  @useResult
  $Res call({Pasta pasta});

  $PastaCopyWith<$Res> get pasta;
}

/// @nodoc
class __$$EntityPastaCopyWithImpl<$Res>
    extends _$EntityCopyWithImpl<$Res, _$EntityPasta>
    implements _$$EntityPastaCopyWith<$Res> {
  __$$EntityPastaCopyWithImpl(
      _$EntityPasta _value, $Res Function(_$EntityPasta) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pasta = null,
  }) {
    return _then(_$EntityPasta(
      pasta: null == pasta
          ? _value.pasta
          : pasta // ignore: cast_nullable_to_non_nullable
              as Pasta,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PastaCopyWith<$Res> get pasta {
    return $PastaCopyWith<$Res>(_value.pasta, (value) {
      return _then(_value.copyWith(pasta: value));
    });
  }
}

/// @nodoc

class _$EntityPasta extends EntityPasta {
  const _$EntityPasta({required this.pasta}) : super._();

  @override
  final Pasta pasta;

  @override
  String toString() {
    return 'Entity.pasta(pasta: $pasta)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntityPasta &&
            (identical(other.pasta, pasta) || other.pasta == pasta));
  }

  @override
  int get hashCode => Object.hash(runtimeType, pasta);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntityPastaCopyWith<_$EntityPasta> get copyWith =>
      __$$EntityPastaCopyWithImpl<_$EntityPasta>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bar bar) bar,
    required TResult Function(BarCreate barCreate) barCreate,
    required TResult Function(Foo foo) foo,
    required TResult Function(Pasta pasta) pasta,
    required TResult Function(Pizza pizza) pizza,
    required TResult Function(PizzaSpeziale pizzaSpeziale) pizzaspeziale,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)
        unknown,
  }) {
    return pasta(this.pasta);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bar bar)? bar,
    TResult? Function(BarCreate barCreate)? barCreate,
    TResult? Function(Foo foo)? foo,
    TResult? Function(Pasta pasta)? pasta,
    TResult? Function(Pizza pizza)? pizza,
    TResult? Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
  }) {
    return pasta?.call(this.pasta);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bar bar)? bar,
    TResult Function(BarCreate barCreate)? barCreate,
    TResult Function(Foo foo)? foo,
    TResult Function(Pasta pasta)? pasta,
    TResult Function(Pizza pizza)? pizza,
    TResult Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (pasta != null) {
      return pasta(this.pasta);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntityBar value) bar,
    required TResult Function(EntityBar_create value) barCreate,
    required TResult Function(EntityFoo value) foo,
    required TResult Function(EntityPasta value) pasta,
    required TResult Function(EntityPizza value) pizza,
    required TResult Function(EntityPizzaspeziale value) pizzaspeziale,
    required TResult Function(EntityUnknown value) unknown,
  }) {
    return pasta(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntityBar value)? bar,
    TResult? Function(EntityBar_create value)? barCreate,
    TResult? Function(EntityFoo value)? foo,
    TResult? Function(EntityPasta value)? pasta,
    TResult? Function(EntityPizza value)? pizza,
    TResult? Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult? Function(EntityUnknown value)? unknown,
  }) {
    return pasta?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntityBar value)? bar,
    TResult Function(EntityBar_create value)? barCreate,
    TResult Function(EntityFoo value)? foo,
    TResult Function(EntityPasta value)? pasta,
    TResult Function(EntityPizza value)? pizza,
    TResult Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult Function(EntityUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (pasta != null) {
      return pasta(this);
    }
    return orElse();
  }
}

abstract class EntityPasta extends Entity {
  const factory EntityPasta({required final Pasta pasta}) = _$EntityPasta;
  const EntityPasta._() : super._();

  Pasta get pasta;
  @JsonKey(ignore: true)
  _$$EntityPastaCopyWith<_$EntityPasta> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EntityPizzaCopyWith<$Res> {
  factory _$$EntityPizzaCopyWith(
          _$EntityPizza value, $Res Function(_$EntityPizza) then) =
      __$$EntityPizzaCopyWithImpl<$Res>;
  @useResult
  $Res call({Pizza pizza});

  $PizzaCopyWith<$Res> get pizza;
}

/// @nodoc
class __$$EntityPizzaCopyWithImpl<$Res>
    extends _$EntityCopyWithImpl<$Res, _$EntityPizza>
    implements _$$EntityPizzaCopyWith<$Res> {
  __$$EntityPizzaCopyWithImpl(
      _$EntityPizza _value, $Res Function(_$EntityPizza) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pizza = null,
  }) {
    return _then(_$EntityPizza(
      pizza: null == pizza
          ? _value.pizza
          : pizza // ignore: cast_nullable_to_non_nullable
              as Pizza,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PizzaCopyWith<$Res> get pizza {
    return $PizzaCopyWith<$Res>(_value.pizza, (value) {
      return _then(_value.copyWith(pizza: value));
    });
  }
}

/// @nodoc

class _$EntityPizza extends EntityPizza {
  const _$EntityPizza({required this.pizza}) : super._();

  @override
  final Pizza pizza;

  @override
  String toString() {
    return 'Entity.pizza(pizza: $pizza)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntityPizza &&
            (identical(other.pizza, pizza) || other.pizza == pizza));
  }

  @override
  int get hashCode => Object.hash(runtimeType, pizza);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntityPizzaCopyWith<_$EntityPizza> get copyWith =>
      __$$EntityPizzaCopyWithImpl<_$EntityPizza>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bar bar) bar,
    required TResult Function(BarCreate barCreate) barCreate,
    required TResult Function(Foo foo) foo,
    required TResult Function(Pasta pasta) pasta,
    required TResult Function(Pizza pizza) pizza,
    required TResult Function(PizzaSpeziale pizzaSpeziale) pizzaspeziale,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)
        unknown,
  }) {
    return pizza(this.pizza);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bar bar)? bar,
    TResult? Function(BarCreate barCreate)? barCreate,
    TResult? Function(Foo foo)? foo,
    TResult? Function(Pasta pasta)? pasta,
    TResult? Function(Pizza pizza)? pizza,
    TResult? Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
  }) {
    return pizza?.call(this.pizza);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bar bar)? bar,
    TResult Function(BarCreate barCreate)? barCreate,
    TResult Function(Foo foo)? foo,
    TResult Function(Pasta pasta)? pasta,
    TResult Function(Pizza pizza)? pizza,
    TResult Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (pizza != null) {
      return pizza(this.pizza);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntityBar value) bar,
    required TResult Function(EntityBar_create value) barCreate,
    required TResult Function(EntityFoo value) foo,
    required TResult Function(EntityPasta value) pasta,
    required TResult Function(EntityPizza value) pizza,
    required TResult Function(EntityPizzaspeziale value) pizzaspeziale,
    required TResult Function(EntityUnknown value) unknown,
  }) {
    return pizza(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntityBar value)? bar,
    TResult? Function(EntityBar_create value)? barCreate,
    TResult? Function(EntityFoo value)? foo,
    TResult? Function(EntityPasta value)? pasta,
    TResult? Function(EntityPizza value)? pizza,
    TResult? Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult? Function(EntityUnknown value)? unknown,
  }) {
    return pizza?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntityBar value)? bar,
    TResult Function(EntityBar_create value)? barCreate,
    TResult Function(EntityFoo value)? foo,
    TResult Function(EntityPasta value)? pasta,
    TResult Function(EntityPizza value)? pizza,
    TResult Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult Function(EntityUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (pizza != null) {
      return pizza(this);
    }
    return orElse();
  }
}

abstract class EntityPizza extends Entity {
  const factory EntityPizza({required final Pizza pizza}) = _$EntityPizza;
  const EntityPizza._() : super._();

  Pizza get pizza;
  @JsonKey(ignore: true)
  _$$EntityPizzaCopyWith<_$EntityPizza> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EntityPizzaspezialeCopyWith<$Res> {
  factory _$$EntityPizzaspezialeCopyWith(_$EntityPizzaspeziale value,
          $Res Function(_$EntityPizzaspeziale) then) =
      __$$EntityPizzaspezialeCopyWithImpl<$Res>;
  @useResult
  $Res call({PizzaSpeziale pizzaSpeziale});

  $PizzaSpezialeCopyWith<$Res> get pizzaSpeziale;
}

/// @nodoc
class __$$EntityPizzaspezialeCopyWithImpl<$Res>
    extends _$EntityCopyWithImpl<$Res, _$EntityPizzaspeziale>
    implements _$$EntityPizzaspezialeCopyWith<$Res> {
  __$$EntityPizzaspezialeCopyWithImpl(
      _$EntityPizzaspeziale _value, $Res Function(_$EntityPizzaspeziale) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pizzaSpeziale = null,
  }) {
    return _then(_$EntityPizzaspeziale(
      pizzaSpeziale: null == pizzaSpeziale
          ? _value.pizzaSpeziale
          : pizzaSpeziale // ignore: cast_nullable_to_non_nullable
              as PizzaSpeziale,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PizzaSpezialeCopyWith<$Res> get pizzaSpeziale {
    return $PizzaSpezialeCopyWith<$Res>(_value.pizzaSpeziale, (value) {
      return _then(_value.copyWith(pizzaSpeziale: value));
    });
  }
}

/// @nodoc

class _$EntityPizzaspeziale extends EntityPizzaspeziale {
  const _$EntityPizzaspeziale({required this.pizzaSpeziale}) : super._();

  @override
  final PizzaSpeziale pizzaSpeziale;

  @override
  String toString() {
    return 'Entity.pizzaspeziale(pizzaSpeziale: $pizzaSpeziale)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntityPizzaspeziale &&
            (identical(other.pizzaSpeziale, pizzaSpeziale) ||
                other.pizzaSpeziale == pizzaSpeziale));
  }

  @override
  int get hashCode => Object.hash(runtimeType, pizzaSpeziale);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntityPizzaspezialeCopyWith<_$EntityPizzaspeziale> get copyWith =>
      __$$EntityPizzaspezialeCopyWithImpl<_$EntityPizzaspeziale>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bar bar) bar,
    required TResult Function(BarCreate barCreate) barCreate,
    required TResult Function(Foo foo) foo,
    required TResult Function(Pasta pasta) pasta,
    required TResult Function(Pizza pizza) pizza,
    required TResult Function(PizzaSpeziale pizzaSpeziale) pizzaspeziale,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)
        unknown,
  }) {
    return pizzaspeziale(pizzaSpeziale);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bar bar)? bar,
    TResult? Function(BarCreate barCreate)? barCreate,
    TResult? Function(Foo foo)? foo,
    TResult? Function(Pasta pasta)? pasta,
    TResult? Function(Pizza pizza)? pizza,
    TResult? Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
  }) {
    return pizzaspeziale?.call(pizzaSpeziale);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bar bar)? bar,
    TResult Function(BarCreate barCreate)? barCreate,
    TResult Function(Foo foo)? foo,
    TResult Function(Pasta pasta)? pasta,
    TResult Function(Pizza pizza)? pizza,
    TResult Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (pizzaspeziale != null) {
      return pizzaspeziale(pizzaSpeziale);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntityBar value) bar,
    required TResult Function(EntityBar_create value) barCreate,
    required TResult Function(EntityFoo value) foo,
    required TResult Function(EntityPasta value) pasta,
    required TResult Function(EntityPizza value) pizza,
    required TResult Function(EntityPizzaspeziale value) pizzaspeziale,
    required TResult Function(EntityUnknown value) unknown,
  }) {
    return pizzaspeziale(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntityBar value)? bar,
    TResult? Function(EntityBar_create value)? barCreate,
    TResult? Function(EntityFoo value)? foo,
    TResult? Function(EntityPasta value)? pasta,
    TResult? Function(EntityPizza value)? pizza,
    TResult? Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult? Function(EntityUnknown value)? unknown,
  }) {
    return pizzaspeziale?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntityBar value)? bar,
    TResult Function(EntityBar_create value)? barCreate,
    TResult Function(EntityFoo value)? foo,
    TResult Function(EntityPasta value)? pasta,
    TResult Function(EntityPizza value)? pizza,
    TResult Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult Function(EntityUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (pizzaspeziale != null) {
      return pizzaspeziale(this);
    }
    return orElse();
  }
}

abstract class EntityPizzaspeziale extends Entity {
  const factory EntityPizzaspeziale(
      {required final PizzaSpeziale pizzaSpeziale}) = _$EntityPizzaspeziale;
  const EntityPizzaspeziale._() : super._();

  PizzaSpeziale get pizzaSpeziale;
  @JsonKey(ignore: true)
  _$$EntityPizzaspezialeCopyWith<_$EntityPizzaspeziale> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EntityUnknownCopyWith<$Res> {
  factory _$$EntityUnknownCopyWith(
          _$EntityUnknown value, $Res Function(_$EntityUnknown) then) =
      __$$EntityUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<Entity> deserializedModels});
}

/// @nodoc
class __$$EntityUnknownCopyWithImpl<$Res>
    extends _$EntityCopyWithImpl<$Res, _$EntityUnknown>
    implements _$$EntityUnknownCopyWith<$Res> {
  __$$EntityUnknownCopyWithImpl(
      _$EntityUnknown _value, $Res Function(_$EntityUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$EntityUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<Entity>,
    ));
  }
}

/// @nodoc

class _$EntityUnknown extends EntityUnknown {
  const _$EntityUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[],
      final List<Entity> deserializedModels = const <Entity>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<Entity> _deserializedModels;
  @override
  @JsonKey()
  List<Entity> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'Entity.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntityUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntityUnknownCopyWith<_$EntityUnknown> get copyWith =>
      __$$EntityUnknownCopyWithImpl<_$EntityUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bar bar) bar,
    required TResult Function(BarCreate barCreate) barCreate,
    required TResult Function(Foo foo) foo,
    required TResult Function(Pasta pasta) pasta,
    required TResult Function(Pizza pizza) pizza,
    required TResult Function(PizzaSpeziale pizzaSpeziale) pizzaspeziale,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bar bar)? bar,
    TResult? Function(BarCreate barCreate)? barCreate,
    TResult? Function(Foo foo)? foo,
    TResult? Function(Pasta pasta)? pasta,
    TResult? Function(Pizza pizza)? pizza,
    TResult? Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bar bar)? bar,
    TResult Function(BarCreate barCreate)? barCreate,
    TResult Function(Foo foo)? foo,
    TResult Function(Pasta pasta)? pasta,
    TResult Function(Pizza pizza)? pizza,
    TResult Function(PizzaSpeziale pizzaSpeziale)? pizzaspeziale,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Entity> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntityBar value) bar,
    required TResult Function(EntityBar_create value) barCreate,
    required TResult Function(EntityFoo value) foo,
    required TResult Function(EntityPasta value) pasta,
    required TResult Function(EntityPizza value) pizza,
    required TResult Function(EntityPizzaspeziale value) pizzaspeziale,
    required TResult Function(EntityUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntityBar value)? bar,
    TResult? Function(EntityBar_create value)? barCreate,
    TResult? Function(EntityFoo value)? foo,
    TResult? Function(EntityPasta value)? pasta,
    TResult? Function(EntityPizza value)? pizza,
    TResult? Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult? Function(EntityUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntityBar value)? bar,
    TResult Function(EntityBar_create value)? barCreate,
    TResult Function(EntityFoo value)? foo,
    TResult Function(EntityPasta value)? pasta,
    TResult Function(EntityPizza value)? pizza,
    TResult Function(EntityPizzaspeziale value)? pizzaspeziale,
    TResult Function(EntityUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class EntityUnknown extends Entity {
  const factory EntityUnknown(
      {final String message,
      required final Map<String, dynamic> json,
      final DeserializationErrorType errorType,
      final List<Type> possibleTypes,
      final List<Entity> deserializedModels}) = _$EntityUnknown;
  const EntityUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<Entity> get deserializedModels;
  @JsonKey(ignore: true)
  _$$EntityUnknownCopyWith<_$EntityUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EntityRef {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BarRef barRef) barref,
    required TResult Function(FooRef fooRef) fooref,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<EntityRef> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BarRef barRef)? barref,
    TResult? Function(FooRef fooRef)? fooref,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<EntityRef> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BarRef barRef)? barref,
    TResult Function(FooRef fooRef)? fooref,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<EntityRef> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntityRefBarref value) barref,
    required TResult Function(EntityRefFooref value) fooref,
    required TResult Function(EntityRefUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntityRefBarref value)? barref,
    TResult? Function(EntityRefFooref value)? fooref,
    TResult? Function(EntityRefUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntityRefBarref value)? barref,
    TResult Function(EntityRefFooref value)? fooref,
    TResult Function(EntityRefUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityRefCopyWith<$Res> {
  factory $EntityRefCopyWith(EntityRef value, $Res Function(EntityRef) then) =
      _$EntityRefCopyWithImpl<$Res, EntityRef>;
}

/// @nodoc
class _$EntityRefCopyWithImpl<$Res, $Val extends EntityRef>
    implements $EntityRefCopyWith<$Res> {
  _$EntityRefCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EntityRefBarrefCopyWith<$Res> {
  factory _$$EntityRefBarrefCopyWith(
          _$EntityRefBarref value, $Res Function(_$EntityRefBarref) then) =
      __$$EntityRefBarrefCopyWithImpl<$Res>;
  @useResult
  $Res call({BarRef barRef});

  $BarRefCopyWith<$Res> get barRef;
}

/// @nodoc
class __$$EntityRefBarrefCopyWithImpl<$Res>
    extends _$EntityRefCopyWithImpl<$Res, _$EntityRefBarref>
    implements _$$EntityRefBarrefCopyWith<$Res> {
  __$$EntityRefBarrefCopyWithImpl(
      _$EntityRefBarref _value, $Res Function(_$EntityRefBarref) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? barRef = null,
  }) {
    return _then(_$EntityRefBarref(
      barRef: null == barRef
          ? _value.barRef
          : barRef // ignore: cast_nullable_to_non_nullable
              as BarRef,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BarRefCopyWith<$Res> get barRef {
    return $BarRefCopyWith<$Res>(_value.barRef, (value) {
      return _then(_value.copyWith(barRef: value));
    });
  }
}

/// @nodoc

class _$EntityRefBarref extends EntityRefBarref {
  const _$EntityRefBarref({required this.barRef}) : super._();

  @override
  final BarRef barRef;

  @override
  String toString() {
    return 'EntityRef.barref(barRef: $barRef)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntityRefBarref &&
            (identical(other.barRef, barRef) || other.barRef == barRef));
  }

  @override
  int get hashCode => Object.hash(runtimeType, barRef);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntityRefBarrefCopyWith<_$EntityRefBarref> get copyWith =>
      __$$EntityRefBarrefCopyWithImpl<_$EntityRefBarref>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BarRef barRef) barref,
    required TResult Function(FooRef fooRef) fooref,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<EntityRef> deserializedModels)
        unknown,
  }) {
    return barref(barRef);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BarRef barRef)? barref,
    TResult? Function(FooRef fooRef)? fooref,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<EntityRef> deserializedModels)?
        unknown,
  }) {
    return barref?.call(barRef);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BarRef barRef)? barref,
    TResult Function(FooRef fooRef)? fooref,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<EntityRef> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (barref != null) {
      return barref(barRef);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntityRefBarref value) barref,
    required TResult Function(EntityRefFooref value) fooref,
    required TResult Function(EntityRefUnknown value) unknown,
  }) {
    return barref(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntityRefBarref value)? barref,
    TResult? Function(EntityRefFooref value)? fooref,
    TResult? Function(EntityRefUnknown value)? unknown,
  }) {
    return barref?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntityRefBarref value)? barref,
    TResult Function(EntityRefFooref value)? fooref,
    TResult Function(EntityRefUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (barref != null) {
      return barref(this);
    }
    return orElse();
  }
}

abstract class EntityRefBarref extends EntityRef {
  const factory EntityRefBarref({required final BarRef barRef}) =
      _$EntityRefBarref;
  const EntityRefBarref._() : super._();

  BarRef get barRef;
  @JsonKey(ignore: true)
  _$$EntityRefBarrefCopyWith<_$EntityRefBarref> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EntityRefFoorefCopyWith<$Res> {
  factory _$$EntityRefFoorefCopyWith(
          _$EntityRefFooref value, $Res Function(_$EntityRefFooref) then) =
      __$$EntityRefFoorefCopyWithImpl<$Res>;
  @useResult
  $Res call({FooRef fooRef});

  $FooRefCopyWith<$Res> get fooRef;
}

/// @nodoc
class __$$EntityRefFoorefCopyWithImpl<$Res>
    extends _$EntityRefCopyWithImpl<$Res, _$EntityRefFooref>
    implements _$$EntityRefFoorefCopyWith<$Res> {
  __$$EntityRefFoorefCopyWithImpl(
      _$EntityRefFooref _value, $Res Function(_$EntityRefFooref) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fooRef = null,
  }) {
    return _then(_$EntityRefFooref(
      fooRef: null == fooRef
          ? _value.fooRef
          : fooRef // ignore: cast_nullable_to_non_nullable
              as FooRef,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FooRefCopyWith<$Res> get fooRef {
    return $FooRefCopyWith<$Res>(_value.fooRef, (value) {
      return _then(_value.copyWith(fooRef: value));
    });
  }
}

/// @nodoc

class _$EntityRefFooref extends EntityRefFooref {
  const _$EntityRefFooref({required this.fooRef}) : super._();

  @override
  final FooRef fooRef;

  @override
  String toString() {
    return 'EntityRef.fooref(fooRef: $fooRef)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntityRefFooref &&
            (identical(other.fooRef, fooRef) || other.fooRef == fooRef));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fooRef);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntityRefFoorefCopyWith<_$EntityRefFooref> get copyWith =>
      __$$EntityRefFoorefCopyWithImpl<_$EntityRefFooref>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BarRef barRef) barref,
    required TResult Function(FooRef fooRef) fooref,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<EntityRef> deserializedModels)
        unknown,
  }) {
    return fooref(fooRef);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BarRef barRef)? barref,
    TResult? Function(FooRef fooRef)? fooref,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<EntityRef> deserializedModels)?
        unknown,
  }) {
    return fooref?.call(fooRef);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BarRef barRef)? barref,
    TResult Function(FooRef fooRef)? fooref,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<EntityRef> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (fooref != null) {
      return fooref(fooRef);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntityRefBarref value) barref,
    required TResult Function(EntityRefFooref value) fooref,
    required TResult Function(EntityRefUnknown value) unknown,
  }) {
    return fooref(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntityRefBarref value)? barref,
    TResult? Function(EntityRefFooref value)? fooref,
    TResult? Function(EntityRefUnknown value)? unknown,
  }) {
    return fooref?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntityRefBarref value)? barref,
    TResult Function(EntityRefFooref value)? fooref,
    TResult Function(EntityRefUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (fooref != null) {
      return fooref(this);
    }
    return orElse();
  }
}

abstract class EntityRefFooref extends EntityRef {
  const factory EntityRefFooref({required final FooRef fooRef}) =
      _$EntityRefFooref;
  const EntityRefFooref._() : super._();

  FooRef get fooRef;
  @JsonKey(ignore: true)
  _$$EntityRefFoorefCopyWith<_$EntityRefFooref> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EntityRefUnknownCopyWith<$Res> {
  factory _$$EntityRefUnknownCopyWith(
          _$EntityRefUnknown value, $Res Function(_$EntityRefUnknown) then) =
      __$$EntityRefUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<EntityRef> deserializedModels});
}

/// @nodoc
class __$$EntityRefUnknownCopyWithImpl<$Res>
    extends _$EntityRefCopyWithImpl<$Res, _$EntityRefUnknown>
    implements _$$EntityRefUnknownCopyWith<$Res> {
  __$$EntityRefUnknownCopyWithImpl(
      _$EntityRefUnknown _value, $Res Function(_$EntityRefUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$EntityRefUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<EntityRef>,
    ));
  }
}

/// @nodoc

class _$EntityRefUnknown extends EntityRefUnknown {
  const _$EntityRefUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[],
      final List<EntityRef> deserializedModels = const <EntityRef>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<EntityRef> _deserializedModels;
  @override
  @JsonKey()
  List<EntityRef> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'EntityRef.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntityRefUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntityRefUnknownCopyWith<_$EntityRefUnknown> get copyWith =>
      __$$EntityRefUnknownCopyWithImpl<_$EntityRefUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BarRef barRef) barref,
    required TResult Function(FooRef fooRef) fooref,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<EntityRef> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BarRef barRef)? barref,
    TResult? Function(FooRef fooRef)? fooref,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<EntityRef> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BarRef barRef)? barref,
    TResult Function(FooRef fooRef)? fooref,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<EntityRef> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntityRefBarref value) barref,
    required TResult Function(EntityRefFooref value) fooref,
    required TResult Function(EntityRefUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntityRefBarref value)? barref,
    TResult? Function(EntityRefFooref value)? fooref,
    TResult? Function(EntityRefUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntityRefBarref value)? barref,
    TResult Function(EntityRefFooref value)? fooref,
    TResult Function(EntityRefUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class EntityRefUnknown extends EntityRef {
  const factory EntityRefUnknown(
      {final String message,
      required final Map<String, dynamic> json,
      final DeserializationErrorType errorType,
      final List<Type> possibleTypes,
      final List<EntityRef> deserializedModels}) = _$EntityRefUnknown;
  const EntityRefUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<EntityRef> get deserializedModels;
  @JsonKey(ignore: true)
  _$$EntityRefUnknownCopyWith<_$EntityRefUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

Extensible _$ExtensibleFromJson(Map<String, dynamic> json) {
  return _Extensible.fromJson(json);
}

/// @nodoc
mixin _$Extensible {
  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExtensibleCopyWith<Extensible> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExtensibleCopyWith<$Res> {
  factory $ExtensibleCopyWith(
          Extensible value, $Res Function(Extensible) then) =
      _$ExtensibleCopyWithImpl<$Res, Extensible>;
  @useResult
  $Res call(
      {@JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class _$ExtensibleCopyWithImpl<$Res, $Val extends Extensible>
    implements $ExtensibleCopyWith<$Res> {
  _$ExtensibleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_value.copyWith(
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ExtensibleCopyWith<$Res>
    implements $ExtensibleCopyWith<$Res> {
  factory _$$_ExtensibleCopyWith(
          _$_Extensible value, $Res Function(_$_Extensible) then) =
      __$$_ExtensibleCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class __$$_ExtensibleCopyWithImpl<$Res>
    extends _$ExtensibleCopyWithImpl<$Res, _$_Extensible>
    implements _$$_ExtensibleCopyWith<$Res> {
  __$$_ExtensibleCopyWithImpl(
      _$_Extensible _value, $Res Function(_$_Extensible) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_$_Extensible(
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Extensible extends _Extensible {
  const _$_Extensible(
      {@JsonKey(name: r'@schemaLocation') this.atSchemaLocation,
      @JsonKey(name: r'@baseType') this.atBaseType,
      @JsonKey(name: r'@type') required this.atType})
      : super._();

  factory _$_Extensible.fromJson(Map<String, dynamic> json) =>
      _$$_ExtensibleFromJson(json);

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @override
  @JsonKey(name: r'@schemaLocation')
  final String? atSchemaLocation;

  /// When sub-classing, this defines the super-class
  @override
  @JsonKey(name: r'@baseType')
  final String? atBaseType;

  /// When sub-classing, this defines the sub-class Extensible name
  @override
  @JsonKey(name: r'@type')
  final String atType;

  @override
  String toString() {
    return 'Extensible(atSchemaLocation: $atSchemaLocation, atBaseType: $atBaseType, atType: $atType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Extensible &&
            (identical(other.atSchemaLocation, atSchemaLocation) ||
                other.atSchemaLocation == atSchemaLocation) &&
            (identical(other.atBaseType, atBaseType) ||
                other.atBaseType == atBaseType) &&
            (identical(other.atType, atType) || other.atType == atType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, atSchemaLocation, atBaseType, atType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ExtensibleCopyWith<_$_Extensible> get copyWith =>
      __$$_ExtensibleCopyWithImpl<_$_Extensible>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ExtensibleToJson(
      this,
    );
  }
}

abstract class _Extensible extends Extensible {
  const factory _Extensible(
      {@JsonKey(name: r'@schemaLocation') final String? atSchemaLocation,
      @JsonKey(name: r'@baseType') final String? atBaseType,
      @JsonKey(name: r'@type') required final String atType}) = _$_Extensible;
  const _Extensible._() : super._();

  factory _Extensible.fromJson(Map<String, dynamic> json) =
      _$_Extensible.fromJson;

  @override

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation;
  @override

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType;
  @override

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType;
  @override
  @JsonKey(ignore: true)
  _$$_ExtensibleCopyWith<_$_Extensible> get copyWith =>
      throw _privateConstructorUsedError;
}

Foo _$FooFromJson(Map<String, dynamic> json) {
  return _Foo.fromJson(json);
}

/// @nodoc
mixin _$Foo {
  @JsonKey(name: r'fooPropA')
  String? get fooPropA => throw _privateConstructorUsedError;
  @JsonKey(name: r'fooPropB')
  String? get fooPropB => throw _privateConstructorUsedError;

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href => throw _privateConstructorUsedError;

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id => throw _privateConstructorUsedError;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FooCopyWith<Foo> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FooCopyWith<$Res> {
  factory $FooCopyWith(Foo value, $Res Function(Foo) then) =
      _$FooCopyWithImpl<$Res, Foo>;
  @useResult
  $Res call(
      {@JsonKey(name: r'fooPropA') String? fooPropA,
      @JsonKey(name: r'fooPropB') String? fooPropB,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class _$FooCopyWithImpl<$Res, $Val extends Foo> implements $FooCopyWith<$Res> {
  _$FooCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fooPropA = freezed,
    Object? fooPropB = freezed,
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_value.copyWith(
      fooPropA: freezed == fooPropA
          ? _value.fooPropA
          : fooPropA // ignore: cast_nullable_to_non_nullable
              as String?,
      fooPropB: freezed == fooPropB
          ? _value.fooPropB
          : fooPropB // ignore: cast_nullable_to_non_nullable
              as String?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FooCopyWith<$Res> implements $FooCopyWith<$Res> {
  factory _$$_FooCopyWith(_$_Foo value, $Res Function(_$_Foo) then) =
      __$$_FooCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'fooPropA') String? fooPropA,
      @JsonKey(name: r'fooPropB') String? fooPropB,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class __$$_FooCopyWithImpl<$Res> extends _$FooCopyWithImpl<$Res, _$_Foo>
    implements _$$_FooCopyWith<$Res> {
  __$$_FooCopyWithImpl(_$_Foo _value, $Res Function(_$_Foo) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fooPropA = freezed,
    Object? fooPropB = freezed,
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_$_Foo(
      fooPropA: freezed == fooPropA
          ? _value.fooPropA
          : fooPropA // ignore: cast_nullable_to_non_nullable
              as String?,
      fooPropB: freezed == fooPropB
          ? _value.fooPropB
          : fooPropB // ignore: cast_nullable_to_non_nullable
              as String?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Foo extends _Foo {
  const _$_Foo(
      {@JsonKey(name: r'fooPropA') this.fooPropA,
      @JsonKey(name: r'fooPropB') this.fooPropB,
      @JsonKey(name: r'href') this.href,
      @JsonKey(name: r'id') this.id,
      @JsonKey(name: r'@schemaLocation') this.atSchemaLocation,
      @JsonKey(name: r'@baseType') this.atBaseType,
      @JsonKey(name: r'@type') required this.atType})
      : super._();

  factory _$_Foo.fromJson(Map<String, dynamic> json) => _$$_FooFromJson(json);

  @override
  @JsonKey(name: r'fooPropA')
  final String? fooPropA;
  @override
  @JsonKey(name: r'fooPropB')
  final String? fooPropB;

  /// Hyperlink reference
  @override
  @JsonKey(name: r'href')
  final String? href;

  /// unique identifier
  @override
  @JsonKey(name: r'id')
  final String? id;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @override
  @JsonKey(name: r'@schemaLocation')
  final String? atSchemaLocation;

  /// When sub-classing, this defines the super-class
  @override
  @JsonKey(name: r'@baseType')
  final String? atBaseType;

  /// When sub-classing, this defines the sub-class Extensible name
  @override
  @JsonKey(name: r'@type')
  final String atType;

  @override
  String toString() {
    return 'Foo(fooPropA: $fooPropA, fooPropB: $fooPropB, href: $href, id: $id, atSchemaLocation: $atSchemaLocation, atBaseType: $atBaseType, atType: $atType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Foo &&
            (identical(other.fooPropA, fooPropA) ||
                other.fooPropA == fooPropA) &&
            (identical(other.fooPropB, fooPropB) ||
                other.fooPropB == fooPropB) &&
            (identical(other.href, href) || other.href == href) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.atSchemaLocation, atSchemaLocation) ||
                other.atSchemaLocation == atSchemaLocation) &&
            (identical(other.atBaseType, atBaseType) ||
                other.atBaseType == atBaseType) &&
            (identical(other.atType, atType) || other.atType == atType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fooPropA, fooPropB, href, id,
      atSchemaLocation, atBaseType, atType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FooCopyWith<_$_Foo> get copyWith =>
      __$$_FooCopyWithImpl<_$_Foo>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FooToJson(
      this,
    );
  }
}

abstract class _Foo extends Foo {
  const factory _Foo(
      {@JsonKey(name: r'fooPropA') final String? fooPropA,
      @JsonKey(name: r'fooPropB') final String? fooPropB,
      @JsonKey(name: r'href') final String? href,
      @JsonKey(name: r'id') final String? id,
      @JsonKey(name: r'@schemaLocation') final String? atSchemaLocation,
      @JsonKey(name: r'@baseType') final String? atBaseType,
      @JsonKey(name: r'@type') required final String atType}) = _$_Foo;
  const _Foo._() : super._();

  factory _Foo.fromJson(Map<String, dynamic> json) = _$_Foo.fromJson;

  @override
  @JsonKey(name: r'fooPropA')
  String? get fooPropA;
  @override
  @JsonKey(name: r'fooPropB')
  String? get fooPropB;
  @override

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href;
  @override

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id;
  @override

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation;
  @override

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType;
  @override

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType;
  @override
  @JsonKey(ignore: true)
  _$$_FooCopyWith<_$_Foo> get copyWith => throw _privateConstructorUsedError;
}

FooRef _$FooRefFromJson(Map<String, dynamic> json) {
  return _FooRef.fromJson(json);
}

/// @nodoc
mixin _$FooRef {
  @JsonKey(name: r'foorefPropA')
  String? get foorefPropA => throw _privateConstructorUsedError;

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href => throw _privateConstructorUsedError;

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id => throw _privateConstructorUsedError;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FooRefCopyWith<FooRef> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FooRefCopyWith<$Res> {
  factory $FooRefCopyWith(FooRef value, $Res Function(FooRef) then) =
      _$FooRefCopyWithImpl<$Res, FooRef>;
  @useResult
  $Res call(
      {@JsonKey(name: r'foorefPropA') String? foorefPropA,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class _$FooRefCopyWithImpl<$Res, $Val extends FooRef>
    implements $FooRefCopyWith<$Res> {
  _$FooRefCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? foorefPropA = freezed,
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_value.copyWith(
      foorefPropA: freezed == foorefPropA
          ? _value.foorefPropA
          : foorefPropA // ignore: cast_nullable_to_non_nullable
              as String?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FooRefCopyWith<$Res> implements $FooRefCopyWith<$Res> {
  factory _$$_FooRefCopyWith(_$_FooRef value, $Res Function(_$_FooRef) then) =
      __$$_FooRefCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'foorefPropA') String? foorefPropA,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class __$$_FooRefCopyWithImpl<$Res>
    extends _$FooRefCopyWithImpl<$Res, _$_FooRef>
    implements _$$_FooRefCopyWith<$Res> {
  __$$_FooRefCopyWithImpl(_$_FooRef _value, $Res Function(_$_FooRef) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? foorefPropA = freezed,
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_$_FooRef(
      foorefPropA: freezed == foorefPropA
          ? _value.foorefPropA
          : foorefPropA // ignore: cast_nullable_to_non_nullable
              as String?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FooRef extends _FooRef {
  const _$_FooRef(
      {@JsonKey(name: r'foorefPropA') this.foorefPropA,
      @JsonKey(name: r'href') this.href,
      @JsonKey(name: r'id') this.id,
      @JsonKey(name: r'@schemaLocation') this.atSchemaLocation,
      @JsonKey(name: r'@baseType') this.atBaseType,
      @JsonKey(name: r'@type') required this.atType})
      : super._();

  factory _$_FooRef.fromJson(Map<String, dynamic> json) =>
      _$$_FooRefFromJson(json);

  @override
  @JsonKey(name: r'foorefPropA')
  final String? foorefPropA;

  /// Hyperlink reference
  @override
  @JsonKey(name: r'href')
  final String? href;

  /// unique identifier
  @override
  @JsonKey(name: r'id')
  final String? id;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @override
  @JsonKey(name: r'@schemaLocation')
  final String? atSchemaLocation;

  /// When sub-classing, this defines the super-class
  @override
  @JsonKey(name: r'@baseType')
  final String? atBaseType;

  /// When sub-classing, this defines the sub-class Extensible name
  @override
  @JsonKey(name: r'@type')
  final String atType;

  @override
  String toString() {
    return 'FooRef(foorefPropA: $foorefPropA, href: $href, id: $id, atSchemaLocation: $atSchemaLocation, atBaseType: $atBaseType, atType: $atType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FooRef &&
            (identical(other.foorefPropA, foorefPropA) ||
                other.foorefPropA == foorefPropA) &&
            (identical(other.href, href) || other.href == href) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.atSchemaLocation, atSchemaLocation) ||
                other.atSchemaLocation == atSchemaLocation) &&
            (identical(other.atBaseType, atBaseType) ||
                other.atBaseType == atBaseType) &&
            (identical(other.atType, atType) || other.atType == atType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, foorefPropA, href, id, atSchemaLocation, atBaseType, atType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FooRefCopyWith<_$_FooRef> get copyWith =>
      __$$_FooRefCopyWithImpl<_$_FooRef>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FooRefToJson(
      this,
    );
  }
}

abstract class _FooRef extends FooRef {
  const factory _FooRef(
      {@JsonKey(name: r'foorefPropA') final String? foorefPropA,
      @JsonKey(name: r'href') final String? href,
      @JsonKey(name: r'id') final String? id,
      @JsonKey(name: r'@schemaLocation') final String? atSchemaLocation,
      @JsonKey(name: r'@baseType') final String? atBaseType,
      @JsonKey(name: r'@type') required final String atType}) = _$_FooRef;
  const _FooRef._() : super._();

  factory _FooRef.fromJson(Map<String, dynamic> json) = _$_FooRef.fromJson;

  @override
  @JsonKey(name: r'foorefPropA')
  String? get foorefPropA;
  @override

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href;
  @override

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id;
  @override

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation;
  @override

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType;
  @override

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType;
  @override
  @JsonKey(ignore: true)
  _$$_FooRefCopyWith<_$_FooRef> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FooRefOrValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Foo fooValue) asFoo,
    required TResult Function(FooRef fooRefValue) asFooRef,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FooRefOrValue> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Foo fooValue)? asFoo,
    TResult? Function(FooRef fooRefValue)? asFooRef,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FooRefOrValue> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Foo fooValue)? asFoo,
    TResult Function(FooRef fooRefValue)? asFooRef,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FooRefOrValue> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FooRefOrValueAsFoo value) asFoo,
    required TResult Function(FooRefOrValueAsFooRef value) asFooRef,
    required TResult Function(FooRefOrValueUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FooRefOrValueAsFoo value)? asFoo,
    TResult? Function(FooRefOrValueAsFooRef value)? asFooRef,
    TResult? Function(FooRefOrValueUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FooRefOrValueAsFoo value)? asFoo,
    TResult Function(FooRefOrValueAsFooRef value)? asFooRef,
    TResult Function(FooRefOrValueUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FooRefOrValueCopyWith<$Res> {
  factory $FooRefOrValueCopyWith(
          FooRefOrValue value, $Res Function(FooRefOrValue) then) =
      _$FooRefOrValueCopyWithImpl<$Res, FooRefOrValue>;
}

/// @nodoc
class _$FooRefOrValueCopyWithImpl<$Res, $Val extends FooRefOrValue>
    implements $FooRefOrValueCopyWith<$Res> {
  _$FooRefOrValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FooRefOrValueAsFooCopyWith<$Res> {
  factory _$$FooRefOrValueAsFooCopyWith(_$FooRefOrValueAsFoo value,
          $Res Function(_$FooRefOrValueAsFoo) then) =
      __$$FooRefOrValueAsFooCopyWithImpl<$Res>;
  @useResult
  $Res call({Foo fooValue});

  $FooCopyWith<$Res> get fooValue;
}

/// @nodoc
class __$$FooRefOrValueAsFooCopyWithImpl<$Res>
    extends _$FooRefOrValueCopyWithImpl<$Res, _$FooRefOrValueAsFoo>
    implements _$$FooRefOrValueAsFooCopyWith<$Res> {
  __$$FooRefOrValueAsFooCopyWithImpl(
      _$FooRefOrValueAsFoo _value, $Res Function(_$FooRefOrValueAsFoo) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fooValue = null,
  }) {
    return _then(_$FooRefOrValueAsFoo(
      fooValue: null == fooValue
          ? _value.fooValue
          : fooValue // ignore: cast_nullable_to_non_nullable
              as Foo,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FooCopyWith<$Res> get fooValue {
    return $FooCopyWith<$Res>(_value.fooValue, (value) {
      return _then(_value.copyWith(fooValue: value));
    });
  }
}

/// @nodoc

class _$FooRefOrValueAsFoo extends FooRefOrValueAsFoo {
  const _$FooRefOrValueAsFoo({required this.fooValue}) : super._();

  @override
  final Foo fooValue;

  @override
  String toString() {
    return 'FooRefOrValue.asFoo(fooValue: $fooValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FooRefOrValueAsFoo &&
            (identical(other.fooValue, fooValue) ||
                other.fooValue == fooValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fooValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FooRefOrValueAsFooCopyWith<_$FooRefOrValueAsFoo> get copyWith =>
      __$$FooRefOrValueAsFooCopyWithImpl<_$FooRefOrValueAsFoo>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Foo fooValue) asFoo,
    required TResult Function(FooRef fooRefValue) asFooRef,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FooRefOrValue> deserializedModels)
        unknown,
  }) {
    return asFoo(fooValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Foo fooValue)? asFoo,
    TResult? Function(FooRef fooRefValue)? asFooRef,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FooRefOrValue> deserializedModels)?
        unknown,
  }) {
    return asFoo?.call(fooValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Foo fooValue)? asFoo,
    TResult Function(FooRef fooRefValue)? asFooRef,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FooRefOrValue> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFoo != null) {
      return asFoo(fooValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FooRefOrValueAsFoo value) asFoo,
    required TResult Function(FooRefOrValueAsFooRef value) asFooRef,
    required TResult Function(FooRefOrValueUnknown value) unknown,
  }) {
    return asFoo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FooRefOrValueAsFoo value)? asFoo,
    TResult? Function(FooRefOrValueAsFooRef value)? asFooRef,
    TResult? Function(FooRefOrValueUnknown value)? unknown,
  }) {
    return asFoo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FooRefOrValueAsFoo value)? asFoo,
    TResult Function(FooRefOrValueAsFooRef value)? asFooRef,
    TResult Function(FooRefOrValueUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFoo != null) {
      return asFoo(this);
    }
    return orElse();
  }
}

abstract class FooRefOrValueAsFoo extends FooRefOrValue {
  const factory FooRefOrValueAsFoo({required final Foo fooValue}) =
      _$FooRefOrValueAsFoo;
  const FooRefOrValueAsFoo._() : super._();

  Foo get fooValue;
  @JsonKey(ignore: true)
  _$$FooRefOrValueAsFooCopyWith<_$FooRefOrValueAsFoo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FooRefOrValueAsFooRefCopyWith<$Res> {
  factory _$$FooRefOrValueAsFooRefCopyWith(_$FooRefOrValueAsFooRef value,
          $Res Function(_$FooRefOrValueAsFooRef) then) =
      __$$FooRefOrValueAsFooRefCopyWithImpl<$Res>;
  @useResult
  $Res call({FooRef fooRefValue});

  $FooRefCopyWith<$Res> get fooRefValue;
}

/// @nodoc
class __$$FooRefOrValueAsFooRefCopyWithImpl<$Res>
    extends _$FooRefOrValueCopyWithImpl<$Res, _$FooRefOrValueAsFooRef>
    implements _$$FooRefOrValueAsFooRefCopyWith<$Res> {
  __$$FooRefOrValueAsFooRefCopyWithImpl(_$FooRefOrValueAsFooRef _value,
      $Res Function(_$FooRefOrValueAsFooRef) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fooRefValue = null,
  }) {
    return _then(_$FooRefOrValueAsFooRef(
      fooRefValue: null == fooRefValue
          ? _value.fooRefValue
          : fooRefValue // ignore: cast_nullable_to_non_nullable
              as FooRef,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FooRefCopyWith<$Res> get fooRefValue {
    return $FooRefCopyWith<$Res>(_value.fooRefValue, (value) {
      return _then(_value.copyWith(fooRefValue: value));
    });
  }
}

/// @nodoc

class _$FooRefOrValueAsFooRef extends FooRefOrValueAsFooRef {
  const _$FooRefOrValueAsFooRef({required this.fooRefValue}) : super._();

  @override
  final FooRef fooRefValue;

  @override
  String toString() {
    return 'FooRefOrValue.asFooRef(fooRefValue: $fooRefValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FooRefOrValueAsFooRef &&
            (identical(other.fooRefValue, fooRefValue) ||
                other.fooRefValue == fooRefValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fooRefValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FooRefOrValueAsFooRefCopyWith<_$FooRefOrValueAsFooRef> get copyWith =>
      __$$FooRefOrValueAsFooRefCopyWithImpl<_$FooRefOrValueAsFooRef>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Foo fooValue) asFoo,
    required TResult Function(FooRef fooRefValue) asFooRef,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FooRefOrValue> deserializedModels)
        unknown,
  }) {
    return asFooRef(fooRefValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Foo fooValue)? asFoo,
    TResult? Function(FooRef fooRefValue)? asFooRef,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FooRefOrValue> deserializedModels)?
        unknown,
  }) {
    return asFooRef?.call(fooRefValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Foo fooValue)? asFoo,
    TResult Function(FooRef fooRefValue)? asFooRef,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FooRefOrValue> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFooRef != null) {
      return asFooRef(fooRefValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FooRefOrValueAsFoo value) asFoo,
    required TResult Function(FooRefOrValueAsFooRef value) asFooRef,
    required TResult Function(FooRefOrValueUnknown value) unknown,
  }) {
    return asFooRef(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FooRefOrValueAsFoo value)? asFoo,
    TResult? Function(FooRefOrValueAsFooRef value)? asFooRef,
    TResult? Function(FooRefOrValueUnknown value)? unknown,
  }) {
    return asFooRef?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FooRefOrValueAsFoo value)? asFoo,
    TResult Function(FooRefOrValueAsFooRef value)? asFooRef,
    TResult Function(FooRefOrValueUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFooRef != null) {
      return asFooRef(this);
    }
    return orElse();
  }
}

abstract class FooRefOrValueAsFooRef extends FooRefOrValue {
  const factory FooRefOrValueAsFooRef({required final FooRef fooRefValue}) =
      _$FooRefOrValueAsFooRef;
  const FooRefOrValueAsFooRef._() : super._();

  FooRef get fooRefValue;
  @JsonKey(ignore: true)
  _$$FooRefOrValueAsFooRefCopyWith<_$FooRefOrValueAsFooRef> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FooRefOrValueUnknownCopyWith<$Res> {
  factory _$$FooRefOrValueUnknownCopyWith(_$FooRefOrValueUnknown value,
          $Res Function(_$FooRefOrValueUnknown) then) =
      __$$FooRefOrValueUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<FooRefOrValue> deserializedModels});
}

/// @nodoc
class __$$FooRefOrValueUnknownCopyWithImpl<$Res>
    extends _$FooRefOrValueCopyWithImpl<$Res, _$FooRefOrValueUnknown>
    implements _$$FooRefOrValueUnknownCopyWith<$Res> {
  __$$FooRefOrValueUnknownCopyWithImpl(_$FooRefOrValueUnknown _value,
      $Res Function(_$FooRefOrValueUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$FooRefOrValueUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<FooRefOrValue>,
    ));
  }
}

/// @nodoc

class _$FooRefOrValueUnknown extends FooRefOrValueUnknown {
  const _$FooRefOrValueUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[Foo, FooRef],
      final List<FooRefOrValue> deserializedModels = const <FooRefOrValue>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<FooRefOrValue> _deserializedModels;
  @override
  @JsonKey()
  List<FooRefOrValue> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'FooRefOrValue.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FooRefOrValueUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FooRefOrValueUnknownCopyWith<_$FooRefOrValueUnknown> get copyWith =>
      __$$FooRefOrValueUnknownCopyWithImpl<_$FooRefOrValueUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Foo fooValue) asFoo,
    required TResult Function(FooRef fooRefValue) asFooRef,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FooRefOrValue> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Foo fooValue)? asFoo,
    TResult? Function(FooRef fooRefValue)? asFooRef,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FooRefOrValue> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Foo fooValue)? asFoo,
    TResult Function(FooRef fooRefValue)? asFooRef,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FooRefOrValue> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FooRefOrValueAsFoo value) asFoo,
    required TResult Function(FooRefOrValueAsFooRef value) asFooRef,
    required TResult Function(FooRefOrValueUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FooRefOrValueAsFoo value)? asFoo,
    TResult? Function(FooRefOrValueAsFooRef value)? asFooRef,
    TResult? Function(FooRefOrValueUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FooRefOrValueAsFoo value)? asFoo,
    TResult Function(FooRefOrValueAsFooRef value)? asFooRef,
    TResult Function(FooRefOrValueUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class FooRefOrValueUnknown extends FooRefOrValue {
  const factory FooRefOrValueUnknown(
      {final String message,
      required final Map<String, dynamic> json,
      final DeserializationErrorType errorType,
      final List<Type> possibleTypes,
      final List<FooRefOrValue> deserializedModels}) = _$FooRefOrValueUnknown;
  const FooRefOrValueUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<FooRefOrValue> get deserializedModels;
  @JsonKey(ignore: true)
  _$$FooRefOrValueUnknownCopyWith<_$FooRefOrValueUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

Pasta _$PastaFromJson(Map<String, dynamic> json) {
  return _Pasta.fromJson(json);
}

/// @nodoc
mixin _$Pasta {
  @JsonKey(name: r'vendor')
  String? get vendor => throw _privateConstructorUsedError;

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href => throw _privateConstructorUsedError;

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id => throw _privateConstructorUsedError;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PastaCopyWith<Pasta> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PastaCopyWith<$Res> {
  factory $PastaCopyWith(Pasta value, $Res Function(Pasta) then) =
      _$PastaCopyWithImpl<$Res, Pasta>;
  @useResult
  $Res call(
      {@JsonKey(name: r'vendor') String? vendor,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class _$PastaCopyWithImpl<$Res, $Val extends Pasta>
    implements $PastaCopyWith<$Res> {
  _$PastaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vendor = freezed,
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_value.copyWith(
      vendor: freezed == vendor
          ? _value.vendor
          : vendor // ignore: cast_nullable_to_non_nullable
              as String?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_PastaCopyWith<$Res> implements $PastaCopyWith<$Res> {
  factory _$$_PastaCopyWith(_$_Pasta value, $Res Function(_$_Pasta) then) =
      __$$_PastaCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'vendor') String? vendor,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class __$$_PastaCopyWithImpl<$Res> extends _$PastaCopyWithImpl<$Res, _$_Pasta>
    implements _$$_PastaCopyWith<$Res> {
  __$$_PastaCopyWithImpl(_$_Pasta _value, $Res Function(_$_Pasta) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vendor = freezed,
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_$_Pasta(
      vendor: freezed == vendor
          ? _value.vendor
          : vendor // ignore: cast_nullable_to_non_nullable
              as String?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Pasta extends _Pasta {
  const _$_Pasta(
      {@JsonKey(name: r'vendor') this.vendor,
      @JsonKey(name: r'href') this.href,
      @JsonKey(name: r'id') this.id,
      @JsonKey(name: r'@schemaLocation') this.atSchemaLocation,
      @JsonKey(name: r'@baseType') this.atBaseType,
      @JsonKey(name: r'@type') required this.atType})
      : super._();

  factory _$_Pasta.fromJson(Map<String, dynamic> json) =>
      _$$_PastaFromJson(json);

  @override
  @JsonKey(name: r'vendor')
  final String? vendor;

  /// Hyperlink reference
  @override
  @JsonKey(name: r'href')
  final String? href;

  /// unique identifier
  @override
  @JsonKey(name: r'id')
  final String? id;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @override
  @JsonKey(name: r'@schemaLocation')
  final String? atSchemaLocation;

  /// When sub-classing, this defines the super-class
  @override
  @JsonKey(name: r'@baseType')
  final String? atBaseType;

  /// When sub-classing, this defines the sub-class Extensible name
  @override
  @JsonKey(name: r'@type')
  final String atType;

  @override
  String toString() {
    return 'Pasta(vendor: $vendor, href: $href, id: $id, atSchemaLocation: $atSchemaLocation, atBaseType: $atBaseType, atType: $atType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Pasta &&
            (identical(other.vendor, vendor) || other.vendor == vendor) &&
            (identical(other.href, href) || other.href == href) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.atSchemaLocation, atSchemaLocation) ||
                other.atSchemaLocation == atSchemaLocation) &&
            (identical(other.atBaseType, atBaseType) ||
                other.atBaseType == atBaseType) &&
            (identical(other.atType, atType) || other.atType == atType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, vendor, href, id, atSchemaLocation, atBaseType, atType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PastaCopyWith<_$_Pasta> get copyWith =>
      __$$_PastaCopyWithImpl<_$_Pasta>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PastaToJson(
      this,
    );
  }
}

abstract class _Pasta extends Pasta {
  const factory _Pasta(
      {@JsonKey(name: r'vendor') final String? vendor,
      @JsonKey(name: r'href') final String? href,
      @JsonKey(name: r'id') final String? id,
      @JsonKey(name: r'@schemaLocation') final String? atSchemaLocation,
      @JsonKey(name: r'@baseType') final String? atBaseType,
      @JsonKey(name: r'@type') required final String atType}) = _$_Pasta;
  const _Pasta._() : super._();

  factory _Pasta.fromJson(Map<String, dynamic> json) = _$_Pasta.fromJson;

  @override
  @JsonKey(name: r'vendor')
  String? get vendor;
  @override

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href;
  @override

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id;
  @override

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation;
  @override

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType;
  @override

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType;
  @override
  @JsonKey(ignore: true)
  _$$_PastaCopyWith<_$_Pasta> get copyWith =>
      throw _privateConstructorUsedError;
}

Pizza _$PizzaFromJson(Map<String, dynamic> json) {
  return _Pizza.fromJson(json);
}

/// @nodoc
mixin _$Pizza {
  @JsonKey(name: r'pizzaSize')
  num? get pizzaSize => throw _privateConstructorUsedError;

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href => throw _privateConstructorUsedError;

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id => throw _privateConstructorUsedError;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PizzaCopyWith<Pizza> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PizzaCopyWith<$Res> {
  factory $PizzaCopyWith(Pizza value, $Res Function(Pizza) then) =
      _$PizzaCopyWithImpl<$Res, Pizza>;
  @useResult
  $Res call(
      {@JsonKey(name: r'pizzaSize') num? pizzaSize,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class _$PizzaCopyWithImpl<$Res, $Val extends Pizza>
    implements $PizzaCopyWith<$Res> {
  _$PizzaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pizzaSize = freezed,
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_value.copyWith(
      pizzaSize: freezed == pizzaSize
          ? _value.pizzaSize
          : pizzaSize // ignore: cast_nullable_to_non_nullable
              as num?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_PizzaCopyWith<$Res> implements $PizzaCopyWith<$Res> {
  factory _$$_PizzaCopyWith(_$_Pizza value, $Res Function(_$_Pizza) then) =
      __$$_PizzaCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'pizzaSize') num? pizzaSize,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class __$$_PizzaCopyWithImpl<$Res> extends _$PizzaCopyWithImpl<$Res, _$_Pizza>
    implements _$$_PizzaCopyWith<$Res> {
  __$$_PizzaCopyWithImpl(_$_Pizza _value, $Res Function(_$_Pizza) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pizzaSize = freezed,
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_$_Pizza(
      pizzaSize: freezed == pizzaSize
          ? _value.pizzaSize
          : pizzaSize // ignore: cast_nullable_to_non_nullable
              as num?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Pizza extends _Pizza {
  const _$_Pizza(
      {@JsonKey(name: r'pizzaSize') this.pizzaSize,
      @JsonKey(name: r'href') this.href,
      @JsonKey(name: r'id') this.id,
      @JsonKey(name: r'@schemaLocation') this.atSchemaLocation,
      @JsonKey(name: r'@baseType') this.atBaseType,
      @JsonKey(name: r'@type') required this.atType})
      : super._();

  factory _$_Pizza.fromJson(Map<String, dynamic> json) =>
      _$$_PizzaFromJson(json);

  @override
  @JsonKey(name: r'pizzaSize')
  final num? pizzaSize;

  /// Hyperlink reference
  @override
  @JsonKey(name: r'href')
  final String? href;

  /// unique identifier
  @override
  @JsonKey(name: r'id')
  final String? id;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @override
  @JsonKey(name: r'@schemaLocation')
  final String? atSchemaLocation;

  /// When sub-classing, this defines the super-class
  @override
  @JsonKey(name: r'@baseType')
  final String? atBaseType;

  /// When sub-classing, this defines the sub-class Extensible name
  @override
  @JsonKey(name: r'@type')
  final String atType;

  @override
  String toString() {
    return 'Pizza(pizzaSize: $pizzaSize, href: $href, id: $id, atSchemaLocation: $atSchemaLocation, atBaseType: $atBaseType, atType: $atType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Pizza &&
            (identical(other.pizzaSize, pizzaSize) ||
                other.pizzaSize == pizzaSize) &&
            (identical(other.href, href) || other.href == href) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.atSchemaLocation, atSchemaLocation) ||
                other.atSchemaLocation == atSchemaLocation) &&
            (identical(other.atBaseType, atBaseType) ||
                other.atBaseType == atBaseType) &&
            (identical(other.atType, atType) || other.atType == atType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, pizzaSize, href, id, atSchemaLocation, atBaseType, atType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PizzaCopyWith<_$_Pizza> get copyWith =>
      __$$_PizzaCopyWithImpl<_$_Pizza>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PizzaToJson(
      this,
    );
  }
}

abstract class _Pizza extends Pizza {
  const factory _Pizza(
      {@JsonKey(name: r'pizzaSize') final num? pizzaSize,
      @JsonKey(name: r'href') final String? href,
      @JsonKey(name: r'id') final String? id,
      @JsonKey(name: r'@schemaLocation') final String? atSchemaLocation,
      @JsonKey(name: r'@baseType') final String? atBaseType,
      @JsonKey(name: r'@type') required final String atType}) = _$_Pizza;
  const _Pizza._() : super._();

  factory _Pizza.fromJson(Map<String, dynamic> json) = _$_Pizza.fromJson;

  @override
  @JsonKey(name: r'pizzaSize')
  num? get pizzaSize;
  @override

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href;
  @override

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id;
  @override

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation;
  @override

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType;
  @override

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType;
  @override
  @JsonKey(ignore: true)
  _$$_PizzaCopyWith<_$_Pizza> get copyWith =>
      throw _privateConstructorUsedError;
}

PizzaSpeziale _$PizzaSpezialeFromJson(Map<String, dynamic> json) {
  return _PizzaSpeziale.fromJson(json);
}

/// @nodoc
mixin _$PizzaSpeziale {
  @JsonKey(name: r'toppings')
  String? get toppings => throw _privateConstructorUsedError;

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href => throw _privateConstructorUsedError;

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id => throw _privateConstructorUsedError;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType => throw _privateConstructorUsedError;

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PizzaSpezialeCopyWith<PizzaSpeziale> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PizzaSpezialeCopyWith<$Res> {
  factory $PizzaSpezialeCopyWith(
          PizzaSpeziale value, $Res Function(PizzaSpeziale) then) =
      _$PizzaSpezialeCopyWithImpl<$Res, PizzaSpeziale>;
  @useResult
  $Res call(
      {@JsonKey(name: r'toppings') String? toppings,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class _$PizzaSpezialeCopyWithImpl<$Res, $Val extends PizzaSpeziale>
    implements $PizzaSpezialeCopyWith<$Res> {
  _$PizzaSpezialeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toppings = freezed,
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_value.copyWith(
      toppings: freezed == toppings
          ? _value.toppings
          : toppings // ignore: cast_nullable_to_non_nullable
              as String?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_PizzaSpezialeCopyWith<$Res>
    implements $PizzaSpezialeCopyWith<$Res> {
  factory _$$_PizzaSpezialeCopyWith(
          _$_PizzaSpeziale value, $Res Function(_$_PizzaSpeziale) then) =
      __$$_PizzaSpezialeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'toppings') String? toppings,
      @JsonKey(name: r'href') String? href,
      @JsonKey(name: r'id') String? id,
      @JsonKey(name: r'@schemaLocation') String? atSchemaLocation,
      @JsonKey(name: r'@baseType') String? atBaseType,
      @JsonKey(name: r'@type') String atType});
}

/// @nodoc
class __$$_PizzaSpezialeCopyWithImpl<$Res>
    extends _$PizzaSpezialeCopyWithImpl<$Res, _$_PizzaSpeziale>
    implements _$$_PizzaSpezialeCopyWith<$Res> {
  __$$_PizzaSpezialeCopyWithImpl(
      _$_PizzaSpeziale _value, $Res Function(_$_PizzaSpeziale) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toppings = freezed,
    Object? href = freezed,
    Object? id = freezed,
    Object? atSchemaLocation = freezed,
    Object? atBaseType = freezed,
    Object? atType = null,
  }) {
    return _then(_$_PizzaSpeziale(
      toppings: freezed == toppings
          ? _value.toppings
          : toppings // ignore: cast_nullable_to_non_nullable
              as String?,
      href: freezed == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      atSchemaLocation: freezed == atSchemaLocation
          ? _value.atSchemaLocation
          : atSchemaLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      atBaseType: freezed == atBaseType
          ? _value.atBaseType
          : atBaseType // ignore: cast_nullable_to_non_nullable
              as String?,
      atType: null == atType
          ? _value.atType
          : atType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PizzaSpeziale extends _PizzaSpeziale {
  const _$_PizzaSpeziale(
      {@JsonKey(name: r'toppings') this.toppings,
      @JsonKey(name: r'href') this.href,
      @JsonKey(name: r'id') this.id,
      @JsonKey(name: r'@schemaLocation') this.atSchemaLocation,
      @JsonKey(name: r'@baseType') this.atBaseType,
      @JsonKey(name: r'@type') required this.atType})
      : super._();

  factory _$_PizzaSpeziale.fromJson(Map<String, dynamic> json) =>
      _$$_PizzaSpezialeFromJson(json);

  @override
  @JsonKey(name: r'toppings')
  final String? toppings;

  /// Hyperlink reference
  @override
  @JsonKey(name: r'href')
  final String? href;

  /// unique identifier
  @override
  @JsonKey(name: r'id')
  final String? id;

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @override
  @JsonKey(name: r'@schemaLocation')
  final String? atSchemaLocation;

  /// When sub-classing, this defines the super-class
  @override
  @JsonKey(name: r'@baseType')
  final String? atBaseType;

  /// When sub-classing, this defines the sub-class Extensible name
  @override
  @JsonKey(name: r'@type')
  final String atType;

  @override
  String toString() {
    return 'PizzaSpeziale(toppings: $toppings, href: $href, id: $id, atSchemaLocation: $atSchemaLocation, atBaseType: $atBaseType, atType: $atType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PizzaSpeziale &&
            (identical(other.toppings, toppings) ||
                other.toppings == toppings) &&
            (identical(other.href, href) || other.href == href) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.atSchemaLocation, atSchemaLocation) ||
                other.atSchemaLocation == atSchemaLocation) &&
            (identical(other.atBaseType, atBaseType) ||
                other.atBaseType == atBaseType) &&
            (identical(other.atType, atType) || other.atType == atType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, toppings, href, id, atSchemaLocation, atBaseType, atType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PizzaSpezialeCopyWith<_$_PizzaSpeziale> get copyWith =>
      __$$_PizzaSpezialeCopyWithImpl<_$_PizzaSpeziale>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PizzaSpezialeToJson(
      this,
    );
  }
}

abstract class _PizzaSpeziale extends PizzaSpeziale {
  const factory _PizzaSpeziale(
          {@JsonKey(name: r'toppings') final String? toppings,
          @JsonKey(name: r'href') final String? href,
          @JsonKey(name: r'id') final String? id,
          @JsonKey(name: r'@schemaLocation') final String? atSchemaLocation,
          @JsonKey(name: r'@baseType') final String? atBaseType,
          @JsonKey(name: r'@type') required final String atType}) =
      _$_PizzaSpeziale;
  const _PizzaSpeziale._() : super._();

  factory _PizzaSpeziale.fromJson(Map<String, dynamic> json) =
      _$_PizzaSpeziale.fromJson;

  @override
  @JsonKey(name: r'toppings')
  String? get toppings;
  @override

  /// Hyperlink reference
  @JsonKey(name: r'href')
  String? get href;
  @override

  /// unique identifier
  @JsonKey(name: r'id')
  String? get id;
  @override

  /// A URI to a JSON-Schema file that defines additional attributes and relationships
  @JsonKey(name: r'@schemaLocation')
  String? get atSchemaLocation;
  @override

  /// When sub-classing, this defines the super-class
  @JsonKey(name: r'@baseType')
  String? get atBaseType;
  @override

  /// When sub-classing, this defines the sub-class Extensible name
  @JsonKey(name: r'@type')
  String get atType;
  @override
  @JsonKey(ignore: true)
  _$$_PizzaSpezialeCopyWith<_$_PizzaSpeziale> get copyWith =>
      throw _privateConstructorUsedError;
}
