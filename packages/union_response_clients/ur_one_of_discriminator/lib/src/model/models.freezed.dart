// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

IntInUnion _$IntInUnionFromJson(Map<String, dynamic> json) {
  return _IntInUnion.fromJson(json);
}

/// @nodoc
mixin _$IntInUnion {
  int get intValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IntInUnionCopyWith<IntInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntInUnionCopyWith<$Res> {
  factory $IntInUnionCopyWith(
          IntInUnion value, $Res Function(IntInUnion) then) =
      _$IntInUnionCopyWithImpl<$Res, IntInUnion>;
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class _$IntInUnionCopyWithImpl<$Res, $Val extends IntInUnion>
    implements $IntInUnionCopyWith<$Res> {
  _$IntInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_value.copyWith(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_IntInUnionCopyWith<$Res>
    implements $IntInUnionCopyWith<$Res> {
  factory _$$_IntInUnionCopyWith(
          _$_IntInUnion value, $Res Function(_$_IntInUnion) then) =
      __$$_IntInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class __$$_IntInUnionCopyWithImpl<$Res>
    extends _$IntInUnionCopyWithImpl<$Res, _$_IntInUnion>
    implements _$$_IntInUnionCopyWith<$Res> {
  __$$_IntInUnionCopyWithImpl(
      _$_IntInUnion _value, $Res Function(_$_IntInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_$_IntInUnion(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IntInUnion implements _IntInUnion {
  const _$_IntInUnion({required this.intValue});

  factory _$_IntInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_IntInUnionFromJson(json);

  @override
  final int intValue;

  @override
  String toString() {
    return 'IntInUnion(intValue: $intValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IntInUnion &&
            (identical(other.intValue, intValue) ||
                other.intValue == intValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, intValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IntInUnionCopyWith<_$_IntInUnion> get copyWith =>
      __$$_IntInUnionCopyWithImpl<_$_IntInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IntInUnionToJson(
      this,
    );
  }
}

abstract class _IntInUnion implements IntInUnion {
  const factory _IntInUnion({required final int intValue}) = _$_IntInUnion;

  factory _IntInUnion.fromJson(Map<String, dynamic> json) =
      _$_IntInUnion.fromJson;

  @override
  int get intValue;
  @override
  @JsonKey(ignore: true)
  _$$_IntInUnionCopyWith<_$_IntInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

StringInUnion _$StringInUnionFromJson(Map<String, dynamic> json) {
  return _StringInUnion.fromJson(json);
}

/// @nodoc
mixin _$StringInUnion {
  String get stringValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StringInUnionCopyWith<StringInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringInUnionCopyWith<$Res> {
  factory $StringInUnionCopyWith(
          StringInUnion value, $Res Function(StringInUnion) then) =
      _$StringInUnionCopyWithImpl<$Res, StringInUnion>;
  @useResult
  $Res call({String stringValue});
}

/// @nodoc
class _$StringInUnionCopyWithImpl<$Res, $Val extends StringInUnion>
    implements $StringInUnionCopyWith<$Res> {
  _$StringInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stringValue = null,
  }) {
    return _then(_value.copyWith(
      stringValue: null == stringValue
          ? _value.stringValue
          : stringValue // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_StringInUnionCopyWith<$Res>
    implements $StringInUnionCopyWith<$Res> {
  factory _$$_StringInUnionCopyWith(
          _$_StringInUnion value, $Res Function(_$_StringInUnion) then) =
      __$$_StringInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String stringValue});
}

/// @nodoc
class __$$_StringInUnionCopyWithImpl<$Res>
    extends _$StringInUnionCopyWithImpl<$Res, _$_StringInUnion>
    implements _$$_StringInUnionCopyWith<$Res> {
  __$$_StringInUnionCopyWithImpl(
      _$_StringInUnion _value, $Res Function(_$_StringInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stringValue = null,
  }) {
    return _then(_$_StringInUnion(
      stringValue: null == stringValue
          ? _value.stringValue
          : stringValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_StringInUnion implements _StringInUnion {
  const _$_StringInUnion({required this.stringValue});

  factory _$_StringInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_StringInUnionFromJson(json);

  @override
  final String stringValue;

  @override
  String toString() {
    return 'StringInUnion(stringValue: $stringValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StringInUnion &&
            (identical(other.stringValue, stringValue) ||
                other.stringValue == stringValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, stringValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StringInUnionCopyWith<_$_StringInUnion> get copyWith =>
      __$$_StringInUnionCopyWithImpl<_$_StringInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_StringInUnionToJson(
      this,
    );
  }
}

abstract class _StringInUnion implements StringInUnion {
  const factory _StringInUnion({required final String stringValue}) =
      _$_StringInUnion;

  factory _StringInUnion.fromJson(Map<String, dynamic> json) =
      _$_StringInUnion.fromJson;

  @override
  String get stringValue;
  @override
  @JsonKey(ignore: true)
  _$$_StringInUnionCopyWith<_$_StringInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

BoolInUnion _$BoolInUnionFromJson(Map<String, dynamic> json) {
  return _BoolInUnion.fromJson(json);
}

/// @nodoc
mixin _$BoolInUnion {
  bool get boolValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BoolInUnionCopyWith<BoolInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BoolInUnionCopyWith<$Res> {
  factory $BoolInUnionCopyWith(
          BoolInUnion value, $Res Function(BoolInUnion) then) =
      _$BoolInUnionCopyWithImpl<$Res, BoolInUnion>;
  @useResult
  $Res call({bool boolValue});
}

/// @nodoc
class _$BoolInUnionCopyWithImpl<$Res, $Val extends BoolInUnion>
    implements $BoolInUnionCopyWith<$Res> {
  _$BoolInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boolValue = null,
  }) {
    return _then(_value.copyWith(
      boolValue: null == boolValue
          ? _value.boolValue
          : boolValue // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BoolInUnionCopyWith<$Res>
    implements $BoolInUnionCopyWith<$Res> {
  factory _$$_BoolInUnionCopyWith(
          _$_BoolInUnion value, $Res Function(_$_BoolInUnion) then) =
      __$$_BoolInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool boolValue});
}

/// @nodoc
class __$$_BoolInUnionCopyWithImpl<$Res>
    extends _$BoolInUnionCopyWithImpl<$Res, _$_BoolInUnion>
    implements _$$_BoolInUnionCopyWith<$Res> {
  __$$_BoolInUnionCopyWithImpl(
      _$_BoolInUnion _value, $Res Function(_$_BoolInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boolValue = null,
  }) {
    return _then(_$_BoolInUnion(
      boolValue: null == boolValue
          ? _value.boolValue
          : boolValue // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BoolInUnion implements _BoolInUnion {
  const _$_BoolInUnion({required this.boolValue});

  factory _$_BoolInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_BoolInUnionFromJson(json);

  @override
  final bool boolValue;

  @override
  String toString() {
    return 'BoolInUnion(boolValue: $boolValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BoolInUnion &&
            (identical(other.boolValue, boolValue) ||
                other.boolValue == boolValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, boolValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BoolInUnionCopyWith<_$_BoolInUnion> get copyWith =>
      __$$_BoolInUnionCopyWithImpl<_$_BoolInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BoolInUnionToJson(
      this,
    );
  }
}

abstract class _BoolInUnion implements BoolInUnion {
  const factory _BoolInUnion({required final bool boolValue}) = _$_BoolInUnion;

  factory _BoolInUnion.fromJson(Map<String, dynamic> json) =
      _$_BoolInUnion.fromJson;

  @override
  bool get boolValue;
  @override
  @JsonKey(ignore: true)
  _$$_BoolInUnionCopyWith<_$_BoolInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

DoubleInUnion _$DoubleInUnionFromJson(Map<String, dynamic> json) {
  return _DoubleInUnion.fromJson(json);
}

/// @nodoc
mixin _$DoubleInUnion {
  double get doubleValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DoubleInUnionCopyWith<DoubleInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DoubleInUnionCopyWith<$Res> {
  factory $DoubleInUnionCopyWith(
          DoubleInUnion value, $Res Function(DoubleInUnion) then) =
      _$DoubleInUnionCopyWithImpl<$Res, DoubleInUnion>;
  @useResult
  $Res call({double doubleValue});
}

/// @nodoc
class _$DoubleInUnionCopyWithImpl<$Res, $Val extends DoubleInUnion>
    implements $DoubleInUnionCopyWith<$Res> {
  _$DoubleInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? doubleValue = null,
  }) {
    return _then(_value.copyWith(
      doubleValue: null == doubleValue
          ? _value.doubleValue
          : doubleValue // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DoubleInUnionCopyWith<$Res>
    implements $DoubleInUnionCopyWith<$Res> {
  factory _$$_DoubleInUnionCopyWith(
          _$_DoubleInUnion value, $Res Function(_$_DoubleInUnion) then) =
      __$$_DoubleInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double doubleValue});
}

/// @nodoc
class __$$_DoubleInUnionCopyWithImpl<$Res>
    extends _$DoubleInUnionCopyWithImpl<$Res, _$_DoubleInUnion>
    implements _$$_DoubleInUnionCopyWith<$Res> {
  __$$_DoubleInUnionCopyWithImpl(
      _$_DoubleInUnion _value, $Res Function(_$_DoubleInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? doubleValue = null,
  }) {
    return _then(_$_DoubleInUnion(
      doubleValue: null == doubleValue
          ? _value.doubleValue
          : doubleValue // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DoubleInUnion implements _DoubleInUnion {
  const _$_DoubleInUnion({required this.doubleValue});

  factory _$_DoubleInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_DoubleInUnionFromJson(json);

  @override
  final double doubleValue;

  @override
  String toString() {
    return 'DoubleInUnion(doubleValue: $doubleValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DoubleInUnion &&
            (identical(other.doubleValue, doubleValue) ||
                other.doubleValue == doubleValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, doubleValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DoubleInUnionCopyWith<_$_DoubleInUnion> get copyWith =>
      __$$_DoubleInUnionCopyWithImpl<_$_DoubleInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DoubleInUnionToJson(
      this,
    );
  }
}

abstract class _DoubleInUnion implements DoubleInUnion {
  const factory _DoubleInUnion({required final double doubleValue}) =
      _$_DoubleInUnion;

  factory _DoubleInUnion.fromJson(Map<String, dynamic> json) =
      _$_DoubleInUnion.fromJson;

  @override
  double get doubleValue;
  @override
  @JsonKey(ignore: true)
  _$$_DoubleInUnionCopyWith<_$_DoubleInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

ObjectInUnion _$ObjectInUnionFromJson(Map<String, dynamic> json) {
  return _ObjectInUnion.fromJson(json);
}

/// @nodoc
mixin _$ObjectInUnion {
  Object get objectValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ObjectInUnionCopyWith<ObjectInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ObjectInUnionCopyWith<$Res> {
  factory $ObjectInUnionCopyWith(
          ObjectInUnion value, $Res Function(ObjectInUnion) then) =
      _$ObjectInUnionCopyWithImpl<$Res, ObjectInUnion>;
  @useResult
  $Res call({Object objectValue});
}

/// @nodoc
class _$ObjectInUnionCopyWithImpl<$Res, $Val extends ObjectInUnion>
    implements $ObjectInUnionCopyWith<$Res> {
  _$ObjectInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? objectValue = null,
  }) {
    return _then(_value.copyWith(
      objectValue: null == objectValue ? _value.objectValue : objectValue,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ObjectInUnionCopyWith<$Res>
    implements $ObjectInUnionCopyWith<$Res> {
  factory _$$_ObjectInUnionCopyWith(
          _$_ObjectInUnion value, $Res Function(_$_ObjectInUnion) then) =
      __$$_ObjectInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Object objectValue});
}

/// @nodoc
class __$$_ObjectInUnionCopyWithImpl<$Res>
    extends _$ObjectInUnionCopyWithImpl<$Res, _$_ObjectInUnion>
    implements _$$_ObjectInUnionCopyWith<$Res> {
  __$$_ObjectInUnionCopyWithImpl(
      _$_ObjectInUnion _value, $Res Function(_$_ObjectInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? objectValue = null,
  }) {
    return _then(_$_ObjectInUnion(
      objectValue: null == objectValue ? _value.objectValue : objectValue,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ObjectInUnion implements _ObjectInUnion {
  const _$_ObjectInUnion({required this.objectValue});

  factory _$_ObjectInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_ObjectInUnionFromJson(json);

  @override
  final Object objectValue;

  @override
  String toString() {
    return 'ObjectInUnion(objectValue: $objectValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ObjectInUnion &&
            const DeepCollectionEquality()
                .equals(other.objectValue, objectValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(objectValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ObjectInUnionCopyWith<_$_ObjectInUnion> get copyWith =>
      __$$_ObjectInUnionCopyWithImpl<_$_ObjectInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ObjectInUnionToJson(
      this,
    );
  }
}

abstract class _ObjectInUnion implements ObjectInUnion {
  const factory _ObjectInUnion({required final Object objectValue}) =
      _$_ObjectInUnion;

  factory _ObjectInUnion.fromJson(Map<String, dynamic> json) =
      _$_ObjectInUnion.fromJson;

  @override
  Object get objectValue;
  @override
  @JsonKey(ignore: true)
  _$$_ObjectInUnionCopyWith<_$_ObjectInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

NumInUnion _$NumInUnionFromJson(Map<String, dynamic> json) {
  return _NumInUnion.fromJson(json);
}

/// @nodoc
mixin _$NumInUnion {
  num get numValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NumInUnionCopyWith<NumInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NumInUnionCopyWith<$Res> {
  factory $NumInUnionCopyWith(
          NumInUnion value, $Res Function(NumInUnion) then) =
      _$NumInUnionCopyWithImpl<$Res, NumInUnion>;
  @useResult
  $Res call({num numValue});
}

/// @nodoc
class _$NumInUnionCopyWithImpl<$Res, $Val extends NumInUnion>
    implements $NumInUnionCopyWith<$Res> {
  _$NumInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? numValue = null,
  }) {
    return _then(_value.copyWith(
      numValue: null == numValue
          ? _value.numValue
          : numValue // ignore: cast_nullable_to_non_nullable
              as num,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_NumInUnionCopyWith<$Res>
    implements $NumInUnionCopyWith<$Res> {
  factory _$$_NumInUnionCopyWith(
          _$_NumInUnion value, $Res Function(_$_NumInUnion) then) =
      __$$_NumInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({num numValue});
}

/// @nodoc
class __$$_NumInUnionCopyWithImpl<$Res>
    extends _$NumInUnionCopyWithImpl<$Res, _$_NumInUnion>
    implements _$$_NumInUnionCopyWith<$Res> {
  __$$_NumInUnionCopyWithImpl(
      _$_NumInUnion _value, $Res Function(_$_NumInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? numValue = null,
  }) {
    return _then(_$_NumInUnion(
      numValue: null == numValue
          ? _value.numValue
          : numValue // ignore: cast_nullable_to_non_nullable
              as num,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NumInUnion implements _NumInUnion {
  const _$_NumInUnion({required this.numValue});

  factory _$_NumInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_NumInUnionFromJson(json);

  @override
  final num numValue;

  @override
  String toString() {
    return 'NumInUnion(numValue: $numValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NumInUnion &&
            (identical(other.numValue, numValue) ||
                other.numValue == numValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, numValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NumInUnionCopyWith<_$_NumInUnion> get copyWith =>
      __$$_NumInUnionCopyWithImpl<_$_NumInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NumInUnionToJson(
      this,
    );
  }
}

abstract class _NumInUnion implements NumInUnion {
  const factory _NumInUnion({required final num numValue}) = _$_NumInUnion;

  factory _NumInUnion.fromJson(Map<String, dynamic> json) =
      _$_NumInUnion.fromJson;

  @override
  num get numValue;
  @override
  @JsonKey(ignore: true)
  _$$_NumInUnionCopyWith<_$_NumInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

DateTimeInUnion _$DateTimeInUnionFromJson(Map<String, dynamic> json) {
  return _DateTimeInUnion.fromJson(json);
}

/// @nodoc
mixin _$DateTimeInUnion {
  DateTime get dateTimeValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DateTimeInUnionCopyWith<DateTimeInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DateTimeInUnionCopyWith<$Res> {
  factory $DateTimeInUnionCopyWith(
          DateTimeInUnion value, $Res Function(DateTimeInUnion) then) =
      _$DateTimeInUnionCopyWithImpl<$Res, DateTimeInUnion>;
  @useResult
  $Res call({DateTime dateTimeValue});
}

/// @nodoc
class _$DateTimeInUnionCopyWithImpl<$Res, $Val extends DateTimeInUnion>
    implements $DateTimeInUnionCopyWith<$Res> {
  _$DateTimeInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dateTimeValue = null,
  }) {
    return _then(_value.copyWith(
      dateTimeValue: null == dateTimeValue
          ? _value.dateTimeValue
          : dateTimeValue // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DateTimeInUnionCopyWith<$Res>
    implements $DateTimeInUnionCopyWith<$Res> {
  factory _$$_DateTimeInUnionCopyWith(
          _$_DateTimeInUnion value, $Res Function(_$_DateTimeInUnion) then) =
      __$$_DateTimeInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DateTime dateTimeValue});
}

/// @nodoc
class __$$_DateTimeInUnionCopyWithImpl<$Res>
    extends _$DateTimeInUnionCopyWithImpl<$Res, _$_DateTimeInUnion>
    implements _$$_DateTimeInUnionCopyWith<$Res> {
  __$$_DateTimeInUnionCopyWithImpl(
      _$_DateTimeInUnion _value, $Res Function(_$_DateTimeInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dateTimeValue = null,
  }) {
    return _then(_$_DateTimeInUnion(
      dateTimeValue: null == dateTimeValue
          ? _value.dateTimeValue
          : dateTimeValue // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DateTimeInUnion implements _DateTimeInUnion {
  const _$_DateTimeInUnion({required this.dateTimeValue});

  factory _$_DateTimeInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_DateTimeInUnionFromJson(json);

  @override
  final DateTime dateTimeValue;

  @override
  String toString() {
    return 'DateTimeInUnion(dateTimeValue: $dateTimeValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DateTimeInUnion &&
            (identical(other.dateTimeValue, dateTimeValue) ||
                other.dateTimeValue == dateTimeValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, dateTimeValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DateTimeInUnionCopyWith<_$_DateTimeInUnion> get copyWith =>
      __$$_DateTimeInUnionCopyWithImpl<_$_DateTimeInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DateTimeInUnionToJson(
      this,
    );
  }
}

abstract class _DateTimeInUnion implements DateTimeInUnion {
  const factory _DateTimeInUnion({required final DateTime dateTimeValue}) =
      _$_DateTimeInUnion;

  factory _DateTimeInUnion.fromJson(Map<String, dynamic> json) =
      _$_DateTimeInUnion.fromJson;

  @override
  DateTime get dateTimeValue;
  @override
  @JsonKey(ignore: true)
  _$$_DateTimeInUnionCopyWith<_$_DateTimeInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RootGetData {
  Object? get responseData => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitAllOfDisc responseData) as200,
    required TResult Function(int? statusCode, Object? responseData) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitAllOfDisc responseData)? as200,
    TResult? Function(int? statusCode, Object? responseData)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitAllOfDisc responseData)? as200,
    TResult Function(int? statusCode, Object? responseData)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RootGetDataAs200 value) as200,
    required TResult Function(RootGetResponseUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RootGetDataAs200 value)? as200,
    TResult? Function(RootGetResponseUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RootGetDataAs200 value)? as200,
    TResult Function(RootGetResponseUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RootGetDataCopyWith<$Res> {
  factory $RootGetDataCopyWith(
          RootGetData value, $Res Function(RootGetData) then) =
      _$RootGetDataCopyWithImpl<$Res, RootGetData>;
}

/// @nodoc
class _$RootGetDataCopyWithImpl<$Res, $Val extends RootGetData>
    implements $RootGetDataCopyWith<$Res> {
  _$RootGetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$RootGetDataAs200CopyWith<$Res> {
  factory _$$RootGetDataAs200CopyWith(
          _$RootGetDataAs200 value, $Res Function(_$RootGetDataAs200) then) =
      __$$RootGetDataAs200CopyWithImpl<$Res>;
  @useResult
  $Res call({FruitAllOfDisc responseData});

  $FruitAllOfDiscCopyWith<$Res> get responseData;
}

/// @nodoc
class __$$RootGetDataAs200CopyWithImpl<$Res>
    extends _$RootGetDataCopyWithImpl<$Res, _$RootGetDataAs200>
    implements _$$RootGetDataAs200CopyWith<$Res> {
  __$$RootGetDataAs200CopyWithImpl(
      _$RootGetDataAs200 _value, $Res Function(_$RootGetDataAs200) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? responseData = null,
  }) {
    return _then(_$RootGetDataAs200(
      responseData: null == responseData
          ? _value.responseData
          : responseData // ignore: cast_nullable_to_non_nullable
              as FruitAllOfDisc,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitAllOfDiscCopyWith<$Res> get responseData {
    return $FruitAllOfDiscCopyWith<$Res>(_value.responseData, (value) {
      return _then(_value.copyWith(responseData: value));
    });
  }
}

/// @nodoc

class _$RootGetDataAs200 extends RootGetDataAs200 {
  const _$RootGetDataAs200({required this.responseData}) : super._();

  @override
  final FruitAllOfDisc responseData;

  @override
  String toString() {
    return 'RootGetData.as200(responseData: $responseData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RootGetDataAs200 &&
            (identical(other.responseData, responseData) ||
                other.responseData == responseData));
  }

  @override
  int get hashCode => Object.hash(runtimeType, responseData);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RootGetDataAs200CopyWith<_$RootGetDataAs200> get copyWith =>
      __$$RootGetDataAs200CopyWithImpl<_$RootGetDataAs200>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitAllOfDisc responseData) as200,
    required TResult Function(int? statusCode, Object? responseData) unknown,
  }) {
    return as200(responseData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitAllOfDisc responseData)? as200,
    TResult? Function(int? statusCode, Object? responseData)? unknown,
  }) {
    return as200?.call(responseData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitAllOfDisc responseData)? as200,
    TResult Function(int? statusCode, Object? responseData)? unknown,
    required TResult orElse(),
  }) {
    if (as200 != null) {
      return as200(responseData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RootGetDataAs200 value) as200,
    required TResult Function(RootGetResponseUnknown value) unknown,
  }) {
    return as200(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RootGetDataAs200 value)? as200,
    TResult? Function(RootGetResponseUnknown value)? unknown,
  }) {
    return as200?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RootGetDataAs200 value)? as200,
    TResult Function(RootGetResponseUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (as200 != null) {
      return as200(this);
    }
    return orElse();
  }
}

abstract class RootGetDataAs200 extends RootGetData {
  const factory RootGetDataAs200({required final FruitAllOfDisc responseData}) =
      _$RootGetDataAs200;
  const RootGetDataAs200._() : super._();

  @override
  FruitAllOfDisc get responseData;
  @JsonKey(ignore: true)
  _$$RootGetDataAs200CopyWith<_$RootGetDataAs200> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RootGetResponseUnknownCopyWith<$Res> {
  factory _$$RootGetResponseUnknownCopyWith(_$RootGetResponseUnknown value,
          $Res Function(_$RootGetResponseUnknown) then) =
      __$$RootGetResponseUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call({int? statusCode, Object? responseData});
}

/// @nodoc
class __$$RootGetResponseUnknownCopyWithImpl<$Res>
    extends _$RootGetDataCopyWithImpl<$Res, _$RootGetResponseUnknown>
    implements _$$RootGetResponseUnknownCopyWith<$Res> {
  __$$RootGetResponseUnknownCopyWithImpl(_$RootGetResponseUnknown _value,
      $Res Function(_$RootGetResponseUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? statusCode = freezed,
    Object? responseData = freezed,
  }) {
    return _then(_$RootGetResponseUnknown(
      statusCode: freezed == statusCode
          ? _value.statusCode
          : statusCode // ignore: cast_nullable_to_non_nullable
              as int?,
      responseData:
          freezed == responseData ? _value.responseData : responseData,
    ));
  }
}

/// @nodoc

class _$RootGetResponseUnknown extends RootGetResponseUnknown {
  const _$RootGetResponseUnknown({this.statusCode, required this.responseData})
      : super._();

  @override
  final int? statusCode;
  @override
  final Object? responseData;

  @override
  String toString() {
    return 'RootGetData.unknown(statusCode: $statusCode, responseData: $responseData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RootGetResponseUnknown &&
            (identical(other.statusCode, statusCode) ||
                other.statusCode == statusCode) &&
            const DeepCollectionEquality()
                .equals(other.responseData, responseData));
  }

  @override
  int get hashCode => Object.hash(runtimeType, statusCode,
      const DeepCollectionEquality().hash(responseData));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RootGetResponseUnknownCopyWith<_$RootGetResponseUnknown> get copyWith =>
      __$$RootGetResponseUnknownCopyWithImpl<_$RootGetResponseUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitAllOfDisc responseData) as200,
    required TResult Function(int? statusCode, Object? responseData) unknown,
  }) {
    return unknown(statusCode, responseData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitAllOfDisc responseData)? as200,
    TResult? Function(int? statusCode, Object? responseData)? unknown,
  }) {
    return unknown?.call(statusCode, responseData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitAllOfDisc responseData)? as200,
    TResult Function(int? statusCode, Object? responseData)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(statusCode, responseData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RootGetDataAs200 value) as200,
    required TResult Function(RootGetResponseUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RootGetDataAs200 value)? as200,
    TResult? Function(RootGetResponseUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RootGetDataAs200 value)? as200,
    TResult Function(RootGetResponseUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class RootGetResponseUnknown extends RootGetData {
  const factory RootGetResponseUnknown(
      {final int? statusCode,
      required final Object? responseData}) = _$RootGetResponseUnknown;
  const RootGetResponseUnknown._() : super._();

  int? get statusCode;
  @override
  Object? get responseData;
  @JsonKey(ignore: true)
  _$$RootGetResponseUnknownCopyWith<_$RootGetResponseUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

AppleAllOfDisc _$AppleAllOfDiscFromJson(Map<String, dynamic> json) {
  return _AppleAllOfDisc.fromJson(json);
}

/// @nodoc
mixin _$AppleAllOfDisc {
  @JsonKey(name: r'seeds')
  int get seeds => throw _privateConstructorUsedError;
  @JsonKey(name: r'fruitType')
  String get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppleAllOfDiscCopyWith<AppleAllOfDisc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppleAllOfDiscCopyWith<$Res> {
  factory $AppleAllOfDiscCopyWith(
          AppleAllOfDisc value, $Res Function(AppleAllOfDisc) then) =
      _$AppleAllOfDiscCopyWithImpl<$Res, AppleAllOfDisc>;
  @useResult
  $Res call(
      {@JsonKey(name: r'seeds') int seeds,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class _$AppleAllOfDiscCopyWithImpl<$Res, $Val extends AppleAllOfDisc>
    implements $AppleAllOfDiscCopyWith<$Res> {
  _$AppleAllOfDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? seeds = null,
    Object? fruitType = null,
  }) {
    return _then(_value.copyWith(
      seeds: null == seeds
          ? _value.seeds
          : seeds // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppleAllOfDiscCopyWith<$Res>
    implements $AppleAllOfDiscCopyWith<$Res> {
  factory _$$_AppleAllOfDiscCopyWith(
          _$_AppleAllOfDisc value, $Res Function(_$_AppleAllOfDisc) then) =
      __$$_AppleAllOfDiscCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'seeds') int seeds,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class __$$_AppleAllOfDiscCopyWithImpl<$Res>
    extends _$AppleAllOfDiscCopyWithImpl<$Res, _$_AppleAllOfDisc>
    implements _$$_AppleAllOfDiscCopyWith<$Res> {
  __$$_AppleAllOfDiscCopyWithImpl(
      _$_AppleAllOfDisc _value, $Res Function(_$_AppleAllOfDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? seeds = null,
    Object? fruitType = null,
  }) {
    return _then(_$_AppleAllOfDisc(
      seeds: null == seeds
          ? _value.seeds
          : seeds // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppleAllOfDisc extends _AppleAllOfDisc {
  const _$_AppleAllOfDisc(
      {@JsonKey(name: r'seeds') required this.seeds,
      @JsonKey(name: r'fruitType') required this.fruitType})
      : super._();

  factory _$_AppleAllOfDisc.fromJson(Map<String, dynamic> json) =>
      _$$_AppleAllOfDiscFromJson(json);

  @override
  @JsonKey(name: r'seeds')
  final int seeds;
  @override
  @JsonKey(name: r'fruitType')
  final String fruitType;

  @override
  String toString() {
    return 'AppleAllOfDisc(seeds: $seeds, fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppleAllOfDisc &&
            (identical(other.seeds, seeds) || other.seeds == seeds) &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, seeds, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppleAllOfDiscCopyWith<_$_AppleAllOfDisc> get copyWith =>
      __$$_AppleAllOfDiscCopyWithImpl<_$_AppleAllOfDisc>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppleAllOfDiscToJson(
      this,
    );
  }
}

abstract class _AppleAllOfDisc extends AppleAllOfDisc {
  const factory _AppleAllOfDisc(
          {@JsonKey(name: r'seeds') required final int seeds,
          @JsonKey(name: r'fruitType') required final String fruitType}) =
      _$_AppleAllOfDisc;
  const _AppleAllOfDisc._() : super._();

  factory _AppleAllOfDisc.fromJson(Map<String, dynamic> json) =
      _$_AppleAllOfDisc.fromJson;

  @override
  @JsonKey(name: r'seeds')
  int get seeds;
  @override
  @JsonKey(name: r'fruitType')
  String get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_AppleAllOfDiscCopyWith<_$_AppleAllOfDisc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AppleAnyOfDisc {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleAnyOfDisc> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleAnyOfDisc> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleAnyOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AppleAnyOfDiscAsFruitType value) asFruitType,
    required TResult Function(AppleAnyOfDiscUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AppleAnyOfDiscAsFruitType value)? asFruitType,
    TResult? Function(AppleAnyOfDiscUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AppleAnyOfDiscAsFruitType value)? asFruitType,
    TResult Function(AppleAnyOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppleAnyOfDiscCopyWith<$Res> {
  factory $AppleAnyOfDiscCopyWith(
          AppleAnyOfDisc value, $Res Function(AppleAnyOfDisc) then) =
      _$AppleAnyOfDiscCopyWithImpl<$Res, AppleAnyOfDisc>;
}

/// @nodoc
class _$AppleAnyOfDiscCopyWithImpl<$Res, $Val extends AppleAnyOfDisc>
    implements $AppleAnyOfDiscCopyWith<$Res> {
  _$AppleAnyOfDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AppleAnyOfDiscAsFruitTypeCopyWith<$Res> {
  factory _$$AppleAnyOfDiscAsFruitTypeCopyWith(
          _$AppleAnyOfDiscAsFruitType value,
          $Res Function(_$AppleAnyOfDiscAsFruitType) then) =
      __$$AppleAnyOfDiscAsFruitTypeCopyWithImpl<$Res>;
  @useResult
  $Res call({FruitType fruitTypeValue});

  $FruitTypeCopyWith<$Res> get fruitTypeValue;
}

/// @nodoc
class __$$AppleAnyOfDiscAsFruitTypeCopyWithImpl<$Res>
    extends _$AppleAnyOfDiscCopyWithImpl<$Res, _$AppleAnyOfDiscAsFruitType>
    implements _$$AppleAnyOfDiscAsFruitTypeCopyWith<$Res> {
  __$$AppleAnyOfDiscAsFruitTypeCopyWithImpl(_$AppleAnyOfDiscAsFruitType _value,
      $Res Function(_$AppleAnyOfDiscAsFruitType) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitTypeValue = null,
  }) {
    return _then(_$AppleAnyOfDiscAsFruitType(
      fruitTypeValue: null == fruitTypeValue
          ? _value.fruitTypeValue
          : fruitTypeValue // ignore: cast_nullable_to_non_nullable
              as FruitType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitTypeCopyWith<$Res> get fruitTypeValue {
    return $FruitTypeCopyWith<$Res>(_value.fruitTypeValue, (value) {
      return _then(_value.copyWith(fruitTypeValue: value));
    });
  }
}

/// @nodoc

class _$AppleAnyOfDiscAsFruitType extends AppleAnyOfDiscAsFruitType {
  const _$AppleAnyOfDiscAsFruitType({required this.fruitTypeValue}) : super._();

  @override
  final FruitType fruitTypeValue;

  @override
  String toString() {
    return 'AppleAnyOfDisc.asFruitType(fruitTypeValue: $fruitTypeValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AppleAnyOfDiscAsFruitType &&
            (identical(other.fruitTypeValue, fruitTypeValue) ||
                other.fruitTypeValue == fruitTypeValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fruitTypeValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AppleAnyOfDiscAsFruitTypeCopyWith<_$AppleAnyOfDiscAsFruitType>
      get copyWith => __$$AppleAnyOfDiscAsFruitTypeCopyWithImpl<
          _$AppleAnyOfDiscAsFruitType>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleAnyOfDisc> deserializedModels)
        unknown,
  }) {
    return asFruitType(fruitTypeValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleAnyOfDisc> deserializedModels)?
        unknown,
  }) {
    return asFruitType?.call(fruitTypeValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleAnyOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFruitType != null) {
      return asFruitType(fruitTypeValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AppleAnyOfDiscAsFruitType value) asFruitType,
    required TResult Function(AppleAnyOfDiscUnknown value) unknown,
  }) {
    return asFruitType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AppleAnyOfDiscAsFruitType value)? asFruitType,
    TResult? Function(AppleAnyOfDiscUnknown value)? unknown,
  }) {
    return asFruitType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AppleAnyOfDiscAsFruitType value)? asFruitType,
    TResult Function(AppleAnyOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFruitType != null) {
      return asFruitType(this);
    }
    return orElse();
  }
}

abstract class AppleAnyOfDiscAsFruitType extends AppleAnyOfDisc {
  const factory AppleAnyOfDiscAsFruitType(
      {required final FruitType fruitTypeValue}) = _$AppleAnyOfDiscAsFruitType;
  const AppleAnyOfDiscAsFruitType._() : super._();

  FruitType get fruitTypeValue;
  @JsonKey(ignore: true)
  _$$AppleAnyOfDiscAsFruitTypeCopyWith<_$AppleAnyOfDiscAsFruitType>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AppleAnyOfDiscUnknownCopyWith<$Res> {
  factory _$$AppleAnyOfDiscUnknownCopyWith(_$AppleAnyOfDiscUnknown value,
          $Res Function(_$AppleAnyOfDiscUnknown) then) =
      __$$AppleAnyOfDiscUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<AppleAnyOfDisc> deserializedModels});
}

/// @nodoc
class __$$AppleAnyOfDiscUnknownCopyWithImpl<$Res>
    extends _$AppleAnyOfDiscCopyWithImpl<$Res, _$AppleAnyOfDiscUnknown>
    implements _$$AppleAnyOfDiscUnknownCopyWith<$Res> {
  __$$AppleAnyOfDiscUnknownCopyWithImpl(_$AppleAnyOfDiscUnknown _value,
      $Res Function(_$AppleAnyOfDiscUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$AppleAnyOfDiscUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<AppleAnyOfDisc>,
    ));
  }
}

/// @nodoc

class _$AppleAnyOfDiscUnknown extends AppleAnyOfDiscUnknown {
  const _$AppleAnyOfDiscUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[FruitType],
      final List<AppleAnyOfDisc> deserializedModels = const <AppleAnyOfDisc>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<AppleAnyOfDisc> _deserializedModels;
  @override
  @JsonKey()
  List<AppleAnyOfDisc> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'AppleAnyOfDisc.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AppleAnyOfDiscUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AppleAnyOfDiscUnknownCopyWith<_$AppleAnyOfDiscUnknown> get copyWith =>
      __$$AppleAnyOfDiscUnknownCopyWithImpl<_$AppleAnyOfDiscUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleAnyOfDisc> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleAnyOfDisc> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleAnyOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AppleAnyOfDiscAsFruitType value) asFruitType,
    required TResult Function(AppleAnyOfDiscUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AppleAnyOfDiscAsFruitType value)? asFruitType,
    TResult? Function(AppleAnyOfDiscUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AppleAnyOfDiscAsFruitType value)? asFruitType,
    TResult Function(AppleAnyOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class AppleAnyOfDiscUnknown extends AppleAnyOfDisc {
  const factory AppleAnyOfDiscUnknown(
      {final String message,
      required final Map<String, dynamic> json,
      final DeserializationErrorType errorType,
      final List<Type> possibleTypes,
      final List<AppleAnyOfDisc> deserializedModels}) = _$AppleAnyOfDiscUnknown;
  const AppleAnyOfDiscUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<AppleAnyOfDisc> get deserializedModels;
  @JsonKey(ignore: true)
  _$$AppleAnyOfDiscUnknownCopyWith<_$AppleAnyOfDiscUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

AppleGrandparentDisc _$AppleGrandparentDiscFromJson(Map<String, dynamic> json) {
  return _AppleGrandparentDisc.fromJson(json);
}

/// @nodoc
mixin _$AppleGrandparentDisc {
  @JsonKey(name: r'seeds')
  int get seeds => throw _privateConstructorUsedError;
  @JsonKey(name: r'fruitType')
  String get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppleGrandparentDiscCopyWith<AppleGrandparentDisc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppleGrandparentDiscCopyWith<$Res> {
  factory $AppleGrandparentDiscCopyWith(AppleGrandparentDisc value,
          $Res Function(AppleGrandparentDisc) then) =
      _$AppleGrandparentDiscCopyWithImpl<$Res, AppleGrandparentDisc>;
  @useResult
  $Res call(
      {@JsonKey(name: r'seeds') int seeds,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class _$AppleGrandparentDiscCopyWithImpl<$Res,
        $Val extends AppleGrandparentDisc>
    implements $AppleGrandparentDiscCopyWith<$Res> {
  _$AppleGrandparentDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? seeds = null,
    Object? fruitType = null,
  }) {
    return _then(_value.copyWith(
      seeds: null == seeds
          ? _value.seeds
          : seeds // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppleGrandparentDiscCopyWith<$Res>
    implements $AppleGrandparentDiscCopyWith<$Res> {
  factory _$$_AppleGrandparentDiscCopyWith(_$_AppleGrandparentDisc value,
          $Res Function(_$_AppleGrandparentDisc) then) =
      __$$_AppleGrandparentDiscCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'seeds') int seeds,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class __$$_AppleGrandparentDiscCopyWithImpl<$Res>
    extends _$AppleGrandparentDiscCopyWithImpl<$Res, _$_AppleGrandparentDisc>
    implements _$$_AppleGrandparentDiscCopyWith<$Res> {
  __$$_AppleGrandparentDiscCopyWithImpl(_$_AppleGrandparentDisc _value,
      $Res Function(_$_AppleGrandparentDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? seeds = null,
    Object? fruitType = null,
  }) {
    return _then(_$_AppleGrandparentDisc(
      seeds: null == seeds
          ? _value.seeds
          : seeds // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppleGrandparentDisc extends _AppleGrandparentDisc {
  const _$_AppleGrandparentDisc(
      {@JsonKey(name: r'seeds') required this.seeds,
      @JsonKey(name: r'fruitType') required this.fruitType})
      : super._();

  factory _$_AppleGrandparentDisc.fromJson(Map<String, dynamic> json) =>
      _$$_AppleGrandparentDiscFromJson(json);

  @override
  @JsonKey(name: r'seeds')
  final int seeds;
  @override
  @JsonKey(name: r'fruitType')
  final String fruitType;

  @override
  String toString() {
    return 'AppleGrandparentDisc(seeds: $seeds, fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppleGrandparentDisc &&
            (identical(other.seeds, seeds) || other.seeds == seeds) &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, seeds, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppleGrandparentDiscCopyWith<_$_AppleGrandparentDisc> get copyWith =>
      __$$_AppleGrandparentDiscCopyWithImpl<_$_AppleGrandparentDisc>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppleGrandparentDiscToJson(
      this,
    );
  }
}

abstract class _AppleGrandparentDisc extends AppleGrandparentDisc {
  const factory _AppleGrandparentDisc(
          {@JsonKey(name: r'seeds') required final int seeds,
          @JsonKey(name: r'fruitType') required final String fruitType}) =
      _$_AppleGrandparentDisc;
  const _AppleGrandparentDisc._() : super._();

  factory _AppleGrandparentDisc.fromJson(Map<String, dynamic> json) =
      _$_AppleGrandparentDisc.fromJson;

  @override
  @JsonKey(name: r'seeds')
  int get seeds;
  @override
  @JsonKey(name: r'fruitType')
  String get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_AppleGrandparentDiscCopyWith<_$_AppleGrandparentDisc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AppleOneOfDisc {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleOneOfDisc> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleOneOfDisc> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleOneOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AppleOneOfDiscAsFruitType value) asFruitType,
    required TResult Function(AppleOneOfDiscUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AppleOneOfDiscAsFruitType value)? asFruitType,
    TResult? Function(AppleOneOfDiscUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AppleOneOfDiscAsFruitType value)? asFruitType,
    TResult Function(AppleOneOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppleOneOfDiscCopyWith<$Res> {
  factory $AppleOneOfDiscCopyWith(
          AppleOneOfDisc value, $Res Function(AppleOneOfDisc) then) =
      _$AppleOneOfDiscCopyWithImpl<$Res, AppleOneOfDisc>;
}

/// @nodoc
class _$AppleOneOfDiscCopyWithImpl<$Res, $Val extends AppleOneOfDisc>
    implements $AppleOneOfDiscCopyWith<$Res> {
  _$AppleOneOfDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AppleOneOfDiscAsFruitTypeCopyWith<$Res> {
  factory _$$AppleOneOfDiscAsFruitTypeCopyWith(
          _$AppleOneOfDiscAsFruitType value,
          $Res Function(_$AppleOneOfDiscAsFruitType) then) =
      __$$AppleOneOfDiscAsFruitTypeCopyWithImpl<$Res>;
  @useResult
  $Res call({FruitType fruitTypeValue});

  $FruitTypeCopyWith<$Res> get fruitTypeValue;
}

/// @nodoc
class __$$AppleOneOfDiscAsFruitTypeCopyWithImpl<$Res>
    extends _$AppleOneOfDiscCopyWithImpl<$Res, _$AppleOneOfDiscAsFruitType>
    implements _$$AppleOneOfDiscAsFruitTypeCopyWith<$Res> {
  __$$AppleOneOfDiscAsFruitTypeCopyWithImpl(_$AppleOneOfDiscAsFruitType _value,
      $Res Function(_$AppleOneOfDiscAsFruitType) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitTypeValue = null,
  }) {
    return _then(_$AppleOneOfDiscAsFruitType(
      fruitTypeValue: null == fruitTypeValue
          ? _value.fruitTypeValue
          : fruitTypeValue // ignore: cast_nullable_to_non_nullable
              as FruitType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitTypeCopyWith<$Res> get fruitTypeValue {
    return $FruitTypeCopyWith<$Res>(_value.fruitTypeValue, (value) {
      return _then(_value.copyWith(fruitTypeValue: value));
    });
  }
}

/// @nodoc

class _$AppleOneOfDiscAsFruitType extends AppleOneOfDiscAsFruitType {
  const _$AppleOneOfDiscAsFruitType({required this.fruitTypeValue}) : super._();

  @override
  final FruitType fruitTypeValue;

  @override
  String toString() {
    return 'AppleOneOfDisc.asFruitType(fruitTypeValue: $fruitTypeValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AppleOneOfDiscAsFruitType &&
            (identical(other.fruitTypeValue, fruitTypeValue) ||
                other.fruitTypeValue == fruitTypeValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fruitTypeValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AppleOneOfDiscAsFruitTypeCopyWith<_$AppleOneOfDiscAsFruitType>
      get copyWith => __$$AppleOneOfDiscAsFruitTypeCopyWithImpl<
          _$AppleOneOfDiscAsFruitType>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleOneOfDisc> deserializedModels)
        unknown,
  }) {
    return asFruitType(fruitTypeValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleOneOfDisc> deserializedModels)?
        unknown,
  }) {
    return asFruitType?.call(fruitTypeValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleOneOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFruitType != null) {
      return asFruitType(fruitTypeValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AppleOneOfDiscAsFruitType value) asFruitType,
    required TResult Function(AppleOneOfDiscUnknown value) unknown,
  }) {
    return asFruitType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AppleOneOfDiscAsFruitType value)? asFruitType,
    TResult? Function(AppleOneOfDiscUnknown value)? unknown,
  }) {
    return asFruitType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AppleOneOfDiscAsFruitType value)? asFruitType,
    TResult Function(AppleOneOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFruitType != null) {
      return asFruitType(this);
    }
    return orElse();
  }
}

abstract class AppleOneOfDiscAsFruitType extends AppleOneOfDisc {
  const factory AppleOneOfDiscAsFruitType(
      {required final FruitType fruitTypeValue}) = _$AppleOneOfDiscAsFruitType;
  const AppleOneOfDiscAsFruitType._() : super._();

  FruitType get fruitTypeValue;
  @JsonKey(ignore: true)
  _$$AppleOneOfDiscAsFruitTypeCopyWith<_$AppleOneOfDiscAsFruitType>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AppleOneOfDiscUnknownCopyWith<$Res> {
  factory _$$AppleOneOfDiscUnknownCopyWith(_$AppleOneOfDiscUnknown value,
          $Res Function(_$AppleOneOfDiscUnknown) then) =
      __$$AppleOneOfDiscUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<AppleOneOfDisc> deserializedModels});
}

/// @nodoc
class __$$AppleOneOfDiscUnknownCopyWithImpl<$Res>
    extends _$AppleOneOfDiscCopyWithImpl<$Res, _$AppleOneOfDiscUnknown>
    implements _$$AppleOneOfDiscUnknownCopyWith<$Res> {
  __$$AppleOneOfDiscUnknownCopyWithImpl(_$AppleOneOfDiscUnknown _value,
      $Res Function(_$AppleOneOfDiscUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$AppleOneOfDiscUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<AppleOneOfDisc>,
    ));
  }
}

/// @nodoc

class _$AppleOneOfDiscUnknown extends AppleOneOfDiscUnknown {
  const _$AppleOneOfDiscUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[FruitType],
      final List<AppleOneOfDisc> deserializedModels = const <AppleOneOfDisc>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<AppleOneOfDisc> _deserializedModels;
  @override
  @JsonKey()
  List<AppleOneOfDisc> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'AppleOneOfDisc.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AppleOneOfDiscUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AppleOneOfDiscUnknownCopyWith<_$AppleOneOfDiscUnknown> get copyWith =>
      __$$AppleOneOfDiscUnknownCopyWithImpl<_$AppleOneOfDiscUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleOneOfDisc> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleOneOfDisc> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<AppleOneOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AppleOneOfDiscAsFruitType value) asFruitType,
    required TResult Function(AppleOneOfDiscUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AppleOneOfDiscAsFruitType value)? asFruitType,
    TResult? Function(AppleOneOfDiscUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AppleOneOfDiscAsFruitType value)? asFruitType,
    TResult Function(AppleOneOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class AppleOneOfDiscUnknown extends AppleOneOfDisc {
  const factory AppleOneOfDiscUnknown(
      {final String message,
      required final Map<String, dynamic> json,
      final DeserializationErrorType errorType,
      final List<Type> possibleTypes,
      final List<AppleOneOfDisc> deserializedModels}) = _$AppleOneOfDiscUnknown;
  const AppleOneOfDiscUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<AppleOneOfDisc> get deserializedModels;
  @JsonKey(ignore: true)
  _$$AppleOneOfDiscUnknownCopyWith<_$AppleOneOfDiscUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

AppleReqDisc _$AppleReqDiscFromJson(Map<String, dynamic> json) {
  return _AppleReqDisc.fromJson(json);
}

/// @nodoc
mixin _$AppleReqDisc {
  @JsonKey(name: r'seeds')
  int get seeds => throw _privateConstructorUsedError;
  @JsonKey(name: r'fruitType')
  String get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppleReqDiscCopyWith<AppleReqDisc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppleReqDiscCopyWith<$Res> {
  factory $AppleReqDiscCopyWith(
          AppleReqDisc value, $Res Function(AppleReqDisc) then) =
      _$AppleReqDiscCopyWithImpl<$Res, AppleReqDisc>;
  @useResult
  $Res call(
      {@JsonKey(name: r'seeds') int seeds,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class _$AppleReqDiscCopyWithImpl<$Res, $Val extends AppleReqDisc>
    implements $AppleReqDiscCopyWith<$Res> {
  _$AppleReqDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? seeds = null,
    Object? fruitType = null,
  }) {
    return _then(_value.copyWith(
      seeds: null == seeds
          ? _value.seeds
          : seeds // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppleReqDiscCopyWith<$Res>
    implements $AppleReqDiscCopyWith<$Res> {
  factory _$$_AppleReqDiscCopyWith(
          _$_AppleReqDisc value, $Res Function(_$_AppleReqDisc) then) =
      __$$_AppleReqDiscCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'seeds') int seeds,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class __$$_AppleReqDiscCopyWithImpl<$Res>
    extends _$AppleReqDiscCopyWithImpl<$Res, _$_AppleReqDisc>
    implements _$$_AppleReqDiscCopyWith<$Res> {
  __$$_AppleReqDiscCopyWithImpl(
      _$_AppleReqDisc _value, $Res Function(_$_AppleReqDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? seeds = null,
    Object? fruitType = null,
  }) {
    return _then(_$_AppleReqDisc(
      seeds: null == seeds
          ? _value.seeds
          : seeds // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppleReqDisc extends _AppleReqDisc {
  const _$_AppleReqDisc(
      {@JsonKey(name: r'seeds') required this.seeds,
      @JsonKey(name: r'fruitType') required this.fruitType})
      : super._();

  factory _$_AppleReqDisc.fromJson(Map<String, dynamic> json) =>
      _$$_AppleReqDiscFromJson(json);

  @override
  @JsonKey(name: r'seeds')
  final int seeds;
  @override
  @JsonKey(name: r'fruitType')
  final String fruitType;

  @override
  String toString() {
    return 'AppleReqDisc(seeds: $seeds, fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppleReqDisc &&
            (identical(other.seeds, seeds) || other.seeds == seeds) &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, seeds, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppleReqDiscCopyWith<_$_AppleReqDisc> get copyWith =>
      __$$_AppleReqDiscCopyWithImpl<_$_AppleReqDisc>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppleReqDiscToJson(
      this,
    );
  }
}

abstract class _AppleReqDisc extends AppleReqDisc {
  const factory _AppleReqDisc(
          {@JsonKey(name: r'seeds') required final int seeds,
          @JsonKey(name: r'fruitType') required final String fruitType}) =
      _$_AppleReqDisc;
  const _AppleReqDisc._() : super._();

  factory _AppleReqDisc.fromJson(Map<String, dynamic> json) =
      _$_AppleReqDisc.fromJson;

  @override
  @JsonKey(name: r'seeds')
  int get seeds;
  @override
  @JsonKey(name: r'fruitType')
  String get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_AppleReqDiscCopyWith<_$_AppleReqDisc> get copyWith =>
      throw _privateConstructorUsedError;
}

BananaAllOfDisc _$BananaAllOfDiscFromJson(Map<String, dynamic> json) {
  return _BananaAllOfDisc.fromJson(json);
}

/// @nodoc
mixin _$BananaAllOfDisc {
  @JsonKey(name: r'length')
  int get length => throw _privateConstructorUsedError;
  @JsonKey(name: r'fruitType')
  String get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BananaAllOfDiscCopyWith<BananaAllOfDisc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BananaAllOfDiscCopyWith<$Res> {
  factory $BananaAllOfDiscCopyWith(
          BananaAllOfDisc value, $Res Function(BananaAllOfDisc) then) =
      _$BananaAllOfDiscCopyWithImpl<$Res, BananaAllOfDisc>;
  @useResult
  $Res call(
      {@JsonKey(name: r'length') int length,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class _$BananaAllOfDiscCopyWithImpl<$Res, $Val extends BananaAllOfDisc>
    implements $BananaAllOfDiscCopyWith<$Res> {
  _$BananaAllOfDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = null,
    Object? fruitType = null,
  }) {
    return _then(_value.copyWith(
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BananaAllOfDiscCopyWith<$Res>
    implements $BananaAllOfDiscCopyWith<$Res> {
  factory _$$_BananaAllOfDiscCopyWith(
          _$_BananaAllOfDisc value, $Res Function(_$_BananaAllOfDisc) then) =
      __$$_BananaAllOfDiscCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'length') int length,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class __$$_BananaAllOfDiscCopyWithImpl<$Res>
    extends _$BananaAllOfDiscCopyWithImpl<$Res, _$_BananaAllOfDisc>
    implements _$$_BananaAllOfDiscCopyWith<$Res> {
  __$$_BananaAllOfDiscCopyWithImpl(
      _$_BananaAllOfDisc _value, $Res Function(_$_BananaAllOfDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = null,
    Object? fruitType = null,
  }) {
    return _then(_$_BananaAllOfDisc(
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BananaAllOfDisc extends _BananaAllOfDisc {
  const _$_BananaAllOfDisc(
      {@JsonKey(name: r'length') required this.length,
      @JsonKey(name: r'fruitType') required this.fruitType})
      : super._();

  factory _$_BananaAllOfDisc.fromJson(Map<String, dynamic> json) =>
      _$$_BananaAllOfDiscFromJson(json);

  @override
  @JsonKey(name: r'length')
  final int length;
  @override
  @JsonKey(name: r'fruitType')
  final String fruitType;

  @override
  String toString() {
    return 'BananaAllOfDisc(length: $length, fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BananaAllOfDisc &&
            (identical(other.length, length) || other.length == length) &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, length, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BananaAllOfDiscCopyWith<_$_BananaAllOfDisc> get copyWith =>
      __$$_BananaAllOfDiscCopyWithImpl<_$_BananaAllOfDisc>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BananaAllOfDiscToJson(
      this,
    );
  }
}

abstract class _BananaAllOfDisc extends BananaAllOfDisc {
  const factory _BananaAllOfDisc(
          {@JsonKey(name: r'length') required final int length,
          @JsonKey(name: r'fruitType') required final String fruitType}) =
      _$_BananaAllOfDisc;
  const _BananaAllOfDisc._() : super._();

  factory _BananaAllOfDisc.fromJson(Map<String, dynamic> json) =
      _$_BananaAllOfDisc.fromJson;

  @override
  @JsonKey(name: r'length')
  int get length;
  @override
  @JsonKey(name: r'fruitType')
  String get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_BananaAllOfDiscCopyWith<_$_BananaAllOfDisc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BananaAnyOfDisc {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaAnyOfDisc> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaAnyOfDisc> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaAnyOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BananaAnyOfDiscAsFruitType value) asFruitType,
    required TResult Function(BananaAnyOfDiscUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BananaAnyOfDiscAsFruitType value)? asFruitType,
    TResult? Function(BananaAnyOfDiscUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BananaAnyOfDiscAsFruitType value)? asFruitType,
    TResult Function(BananaAnyOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BananaAnyOfDiscCopyWith<$Res> {
  factory $BananaAnyOfDiscCopyWith(
          BananaAnyOfDisc value, $Res Function(BananaAnyOfDisc) then) =
      _$BananaAnyOfDiscCopyWithImpl<$Res, BananaAnyOfDisc>;
}

/// @nodoc
class _$BananaAnyOfDiscCopyWithImpl<$Res, $Val extends BananaAnyOfDisc>
    implements $BananaAnyOfDiscCopyWith<$Res> {
  _$BananaAnyOfDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$BananaAnyOfDiscAsFruitTypeCopyWith<$Res> {
  factory _$$BananaAnyOfDiscAsFruitTypeCopyWith(
          _$BananaAnyOfDiscAsFruitType value,
          $Res Function(_$BananaAnyOfDiscAsFruitType) then) =
      __$$BananaAnyOfDiscAsFruitTypeCopyWithImpl<$Res>;
  @useResult
  $Res call({FruitType fruitTypeValue});

  $FruitTypeCopyWith<$Res> get fruitTypeValue;
}

/// @nodoc
class __$$BananaAnyOfDiscAsFruitTypeCopyWithImpl<$Res>
    extends _$BananaAnyOfDiscCopyWithImpl<$Res, _$BananaAnyOfDiscAsFruitType>
    implements _$$BananaAnyOfDiscAsFruitTypeCopyWith<$Res> {
  __$$BananaAnyOfDiscAsFruitTypeCopyWithImpl(
      _$BananaAnyOfDiscAsFruitType _value,
      $Res Function(_$BananaAnyOfDiscAsFruitType) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitTypeValue = null,
  }) {
    return _then(_$BananaAnyOfDiscAsFruitType(
      fruitTypeValue: null == fruitTypeValue
          ? _value.fruitTypeValue
          : fruitTypeValue // ignore: cast_nullable_to_non_nullable
              as FruitType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitTypeCopyWith<$Res> get fruitTypeValue {
    return $FruitTypeCopyWith<$Res>(_value.fruitTypeValue, (value) {
      return _then(_value.copyWith(fruitTypeValue: value));
    });
  }
}

/// @nodoc

class _$BananaAnyOfDiscAsFruitType extends BananaAnyOfDiscAsFruitType {
  const _$BananaAnyOfDiscAsFruitType({required this.fruitTypeValue})
      : super._();

  @override
  final FruitType fruitTypeValue;

  @override
  String toString() {
    return 'BananaAnyOfDisc.asFruitType(fruitTypeValue: $fruitTypeValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BananaAnyOfDiscAsFruitType &&
            (identical(other.fruitTypeValue, fruitTypeValue) ||
                other.fruitTypeValue == fruitTypeValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fruitTypeValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BananaAnyOfDiscAsFruitTypeCopyWith<_$BananaAnyOfDiscAsFruitType>
      get copyWith => __$$BananaAnyOfDiscAsFruitTypeCopyWithImpl<
          _$BananaAnyOfDiscAsFruitType>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaAnyOfDisc> deserializedModels)
        unknown,
  }) {
    return asFruitType(fruitTypeValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaAnyOfDisc> deserializedModels)?
        unknown,
  }) {
    return asFruitType?.call(fruitTypeValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaAnyOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFruitType != null) {
      return asFruitType(fruitTypeValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BananaAnyOfDiscAsFruitType value) asFruitType,
    required TResult Function(BananaAnyOfDiscUnknown value) unknown,
  }) {
    return asFruitType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BananaAnyOfDiscAsFruitType value)? asFruitType,
    TResult? Function(BananaAnyOfDiscUnknown value)? unknown,
  }) {
    return asFruitType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BananaAnyOfDiscAsFruitType value)? asFruitType,
    TResult Function(BananaAnyOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFruitType != null) {
      return asFruitType(this);
    }
    return orElse();
  }
}

abstract class BananaAnyOfDiscAsFruitType extends BananaAnyOfDisc {
  const factory BananaAnyOfDiscAsFruitType(
      {required final FruitType fruitTypeValue}) = _$BananaAnyOfDiscAsFruitType;
  const BananaAnyOfDiscAsFruitType._() : super._();

  FruitType get fruitTypeValue;
  @JsonKey(ignore: true)
  _$$BananaAnyOfDiscAsFruitTypeCopyWith<_$BananaAnyOfDiscAsFruitType>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BananaAnyOfDiscUnknownCopyWith<$Res> {
  factory _$$BananaAnyOfDiscUnknownCopyWith(_$BananaAnyOfDiscUnknown value,
          $Res Function(_$BananaAnyOfDiscUnknown) then) =
      __$$BananaAnyOfDiscUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<BananaAnyOfDisc> deserializedModels});
}

/// @nodoc
class __$$BananaAnyOfDiscUnknownCopyWithImpl<$Res>
    extends _$BananaAnyOfDiscCopyWithImpl<$Res, _$BananaAnyOfDiscUnknown>
    implements _$$BananaAnyOfDiscUnknownCopyWith<$Res> {
  __$$BananaAnyOfDiscUnknownCopyWithImpl(_$BananaAnyOfDiscUnknown _value,
      $Res Function(_$BananaAnyOfDiscUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$BananaAnyOfDiscUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<BananaAnyOfDisc>,
    ));
  }
}

/// @nodoc

class _$BananaAnyOfDiscUnknown extends BananaAnyOfDiscUnknown {
  const _$BananaAnyOfDiscUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[FruitType],
      final List<BananaAnyOfDisc> deserializedModels =
          const <BananaAnyOfDisc>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<BananaAnyOfDisc> _deserializedModels;
  @override
  @JsonKey()
  List<BananaAnyOfDisc> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'BananaAnyOfDisc.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BananaAnyOfDiscUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BananaAnyOfDiscUnknownCopyWith<_$BananaAnyOfDiscUnknown> get copyWith =>
      __$$BananaAnyOfDiscUnknownCopyWithImpl<_$BananaAnyOfDiscUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaAnyOfDisc> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaAnyOfDisc> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaAnyOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BananaAnyOfDiscAsFruitType value) asFruitType,
    required TResult Function(BananaAnyOfDiscUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BananaAnyOfDiscAsFruitType value)? asFruitType,
    TResult? Function(BananaAnyOfDiscUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BananaAnyOfDiscAsFruitType value)? asFruitType,
    TResult Function(BananaAnyOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class BananaAnyOfDiscUnknown extends BananaAnyOfDisc {
  const factory BananaAnyOfDiscUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<BananaAnyOfDisc> deserializedModels}) =
      _$BananaAnyOfDiscUnknown;
  const BananaAnyOfDiscUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<BananaAnyOfDisc> get deserializedModels;
  @JsonKey(ignore: true)
  _$$BananaAnyOfDiscUnknownCopyWith<_$BananaAnyOfDiscUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

BananaGrandparentDisc _$BananaGrandparentDiscFromJson(
    Map<String, dynamic> json) {
  return _BananaGrandparentDisc.fromJson(json);
}

/// @nodoc
mixin _$BananaGrandparentDisc {
  @JsonKey(name: r'length')
  int get length => throw _privateConstructorUsedError;
  @JsonKey(name: r'fruitType')
  String get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BananaGrandparentDiscCopyWith<BananaGrandparentDisc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BananaGrandparentDiscCopyWith<$Res> {
  factory $BananaGrandparentDiscCopyWith(BananaGrandparentDisc value,
          $Res Function(BananaGrandparentDisc) then) =
      _$BananaGrandparentDiscCopyWithImpl<$Res, BananaGrandparentDisc>;
  @useResult
  $Res call(
      {@JsonKey(name: r'length') int length,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class _$BananaGrandparentDiscCopyWithImpl<$Res,
        $Val extends BananaGrandparentDisc>
    implements $BananaGrandparentDiscCopyWith<$Res> {
  _$BananaGrandparentDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = null,
    Object? fruitType = null,
  }) {
    return _then(_value.copyWith(
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BananaGrandparentDiscCopyWith<$Res>
    implements $BananaGrandparentDiscCopyWith<$Res> {
  factory _$$_BananaGrandparentDiscCopyWith(_$_BananaGrandparentDisc value,
          $Res Function(_$_BananaGrandparentDisc) then) =
      __$$_BananaGrandparentDiscCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'length') int length,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class __$$_BananaGrandparentDiscCopyWithImpl<$Res>
    extends _$BananaGrandparentDiscCopyWithImpl<$Res, _$_BananaGrandparentDisc>
    implements _$$_BananaGrandparentDiscCopyWith<$Res> {
  __$$_BananaGrandparentDiscCopyWithImpl(_$_BananaGrandparentDisc _value,
      $Res Function(_$_BananaGrandparentDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = null,
    Object? fruitType = null,
  }) {
    return _then(_$_BananaGrandparentDisc(
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BananaGrandparentDisc extends _BananaGrandparentDisc {
  const _$_BananaGrandparentDisc(
      {@JsonKey(name: r'length') required this.length,
      @JsonKey(name: r'fruitType') required this.fruitType})
      : super._();

  factory _$_BananaGrandparentDisc.fromJson(Map<String, dynamic> json) =>
      _$$_BananaGrandparentDiscFromJson(json);

  @override
  @JsonKey(name: r'length')
  final int length;
  @override
  @JsonKey(name: r'fruitType')
  final String fruitType;

  @override
  String toString() {
    return 'BananaGrandparentDisc(length: $length, fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BananaGrandparentDisc &&
            (identical(other.length, length) || other.length == length) &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, length, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BananaGrandparentDiscCopyWith<_$_BananaGrandparentDisc> get copyWith =>
      __$$_BananaGrandparentDiscCopyWithImpl<_$_BananaGrandparentDisc>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BananaGrandparentDiscToJson(
      this,
    );
  }
}

abstract class _BananaGrandparentDisc extends BananaGrandparentDisc {
  const factory _BananaGrandparentDisc(
          {@JsonKey(name: r'length') required final int length,
          @JsonKey(name: r'fruitType') required final String fruitType}) =
      _$_BananaGrandparentDisc;
  const _BananaGrandparentDisc._() : super._();

  factory _BananaGrandparentDisc.fromJson(Map<String, dynamic> json) =
      _$_BananaGrandparentDisc.fromJson;

  @override
  @JsonKey(name: r'length')
  int get length;
  @override
  @JsonKey(name: r'fruitType')
  String get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_BananaGrandparentDiscCopyWith<_$_BananaGrandparentDisc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BananaOneOfDisc {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaOneOfDisc> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaOneOfDisc> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaOneOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BananaOneOfDiscAsFruitType value) asFruitType,
    required TResult Function(BananaOneOfDiscUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BananaOneOfDiscAsFruitType value)? asFruitType,
    TResult? Function(BananaOneOfDiscUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BananaOneOfDiscAsFruitType value)? asFruitType,
    TResult Function(BananaOneOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BananaOneOfDiscCopyWith<$Res> {
  factory $BananaOneOfDiscCopyWith(
          BananaOneOfDisc value, $Res Function(BananaOneOfDisc) then) =
      _$BananaOneOfDiscCopyWithImpl<$Res, BananaOneOfDisc>;
}

/// @nodoc
class _$BananaOneOfDiscCopyWithImpl<$Res, $Val extends BananaOneOfDisc>
    implements $BananaOneOfDiscCopyWith<$Res> {
  _$BananaOneOfDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$BananaOneOfDiscAsFruitTypeCopyWith<$Res> {
  factory _$$BananaOneOfDiscAsFruitTypeCopyWith(
          _$BananaOneOfDiscAsFruitType value,
          $Res Function(_$BananaOneOfDiscAsFruitType) then) =
      __$$BananaOneOfDiscAsFruitTypeCopyWithImpl<$Res>;
  @useResult
  $Res call({FruitType fruitTypeValue});

  $FruitTypeCopyWith<$Res> get fruitTypeValue;
}

/// @nodoc
class __$$BananaOneOfDiscAsFruitTypeCopyWithImpl<$Res>
    extends _$BananaOneOfDiscCopyWithImpl<$Res, _$BananaOneOfDiscAsFruitType>
    implements _$$BananaOneOfDiscAsFruitTypeCopyWith<$Res> {
  __$$BananaOneOfDiscAsFruitTypeCopyWithImpl(
      _$BananaOneOfDiscAsFruitType _value,
      $Res Function(_$BananaOneOfDiscAsFruitType) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitTypeValue = null,
  }) {
    return _then(_$BananaOneOfDiscAsFruitType(
      fruitTypeValue: null == fruitTypeValue
          ? _value.fruitTypeValue
          : fruitTypeValue // ignore: cast_nullable_to_non_nullable
              as FruitType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitTypeCopyWith<$Res> get fruitTypeValue {
    return $FruitTypeCopyWith<$Res>(_value.fruitTypeValue, (value) {
      return _then(_value.copyWith(fruitTypeValue: value));
    });
  }
}

/// @nodoc

class _$BananaOneOfDiscAsFruitType extends BananaOneOfDiscAsFruitType {
  const _$BananaOneOfDiscAsFruitType({required this.fruitTypeValue})
      : super._();

  @override
  final FruitType fruitTypeValue;

  @override
  String toString() {
    return 'BananaOneOfDisc.asFruitType(fruitTypeValue: $fruitTypeValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BananaOneOfDiscAsFruitType &&
            (identical(other.fruitTypeValue, fruitTypeValue) ||
                other.fruitTypeValue == fruitTypeValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fruitTypeValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BananaOneOfDiscAsFruitTypeCopyWith<_$BananaOneOfDiscAsFruitType>
      get copyWith => __$$BananaOneOfDiscAsFruitTypeCopyWithImpl<
          _$BananaOneOfDiscAsFruitType>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaOneOfDisc> deserializedModels)
        unknown,
  }) {
    return asFruitType(fruitTypeValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaOneOfDisc> deserializedModels)?
        unknown,
  }) {
    return asFruitType?.call(fruitTypeValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaOneOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFruitType != null) {
      return asFruitType(fruitTypeValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BananaOneOfDiscAsFruitType value) asFruitType,
    required TResult Function(BananaOneOfDiscUnknown value) unknown,
  }) {
    return asFruitType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BananaOneOfDiscAsFruitType value)? asFruitType,
    TResult? Function(BananaOneOfDiscUnknown value)? unknown,
  }) {
    return asFruitType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BananaOneOfDiscAsFruitType value)? asFruitType,
    TResult Function(BananaOneOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFruitType != null) {
      return asFruitType(this);
    }
    return orElse();
  }
}

abstract class BananaOneOfDiscAsFruitType extends BananaOneOfDisc {
  const factory BananaOneOfDiscAsFruitType(
      {required final FruitType fruitTypeValue}) = _$BananaOneOfDiscAsFruitType;
  const BananaOneOfDiscAsFruitType._() : super._();

  FruitType get fruitTypeValue;
  @JsonKey(ignore: true)
  _$$BananaOneOfDiscAsFruitTypeCopyWith<_$BananaOneOfDiscAsFruitType>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BananaOneOfDiscUnknownCopyWith<$Res> {
  factory _$$BananaOneOfDiscUnknownCopyWith(_$BananaOneOfDiscUnknown value,
          $Res Function(_$BananaOneOfDiscUnknown) then) =
      __$$BananaOneOfDiscUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<BananaOneOfDisc> deserializedModels});
}

/// @nodoc
class __$$BananaOneOfDiscUnknownCopyWithImpl<$Res>
    extends _$BananaOneOfDiscCopyWithImpl<$Res, _$BananaOneOfDiscUnknown>
    implements _$$BananaOneOfDiscUnknownCopyWith<$Res> {
  __$$BananaOneOfDiscUnknownCopyWithImpl(_$BananaOneOfDiscUnknown _value,
      $Res Function(_$BananaOneOfDiscUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$BananaOneOfDiscUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<BananaOneOfDisc>,
    ));
  }
}

/// @nodoc

class _$BananaOneOfDiscUnknown extends BananaOneOfDiscUnknown {
  const _$BananaOneOfDiscUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[FruitType],
      final List<BananaOneOfDisc> deserializedModels =
          const <BananaOneOfDisc>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<BananaOneOfDisc> _deserializedModels;
  @override
  @JsonKey()
  List<BananaOneOfDisc> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'BananaOneOfDisc.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BananaOneOfDiscUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BananaOneOfDiscUnknownCopyWith<_$BananaOneOfDiscUnknown> get copyWith =>
      __$$BananaOneOfDiscUnknownCopyWithImpl<_$BananaOneOfDiscUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaOneOfDisc> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaOneOfDisc> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<BananaOneOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BananaOneOfDiscAsFruitType value) asFruitType,
    required TResult Function(BananaOneOfDiscUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BananaOneOfDiscAsFruitType value)? asFruitType,
    TResult? Function(BananaOneOfDiscUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BananaOneOfDiscAsFruitType value)? asFruitType,
    TResult Function(BananaOneOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class BananaOneOfDiscUnknown extends BananaOneOfDisc {
  const factory BananaOneOfDiscUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<BananaOneOfDisc> deserializedModels}) =
      _$BananaOneOfDiscUnknown;
  const BananaOneOfDiscUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<BananaOneOfDisc> get deserializedModels;
  @JsonKey(ignore: true)
  _$$BananaOneOfDiscUnknownCopyWith<_$BananaOneOfDiscUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

BananaReqDisc _$BananaReqDiscFromJson(Map<String, dynamic> json) {
  return _BananaReqDisc.fromJson(json);
}

/// @nodoc
mixin _$BananaReqDisc {
  @JsonKey(name: r'length')
  int get length => throw _privateConstructorUsedError;
  @JsonKey(name: r'fruitType')
  String get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BananaReqDiscCopyWith<BananaReqDisc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BananaReqDiscCopyWith<$Res> {
  factory $BananaReqDiscCopyWith(
          BananaReqDisc value, $Res Function(BananaReqDisc) then) =
      _$BananaReqDiscCopyWithImpl<$Res, BananaReqDisc>;
  @useResult
  $Res call(
      {@JsonKey(name: r'length') int length,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class _$BananaReqDiscCopyWithImpl<$Res, $Val extends BananaReqDisc>
    implements $BananaReqDiscCopyWith<$Res> {
  _$BananaReqDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = null,
    Object? fruitType = null,
  }) {
    return _then(_value.copyWith(
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BananaReqDiscCopyWith<$Res>
    implements $BananaReqDiscCopyWith<$Res> {
  factory _$$_BananaReqDiscCopyWith(
          _$_BananaReqDisc value, $Res Function(_$_BananaReqDisc) then) =
      __$$_BananaReqDiscCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'length') int length,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class __$$_BananaReqDiscCopyWithImpl<$Res>
    extends _$BananaReqDiscCopyWithImpl<$Res, _$_BananaReqDisc>
    implements _$$_BananaReqDiscCopyWith<$Res> {
  __$$_BananaReqDiscCopyWithImpl(
      _$_BananaReqDisc _value, $Res Function(_$_BananaReqDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = null,
    Object? fruitType = null,
  }) {
    return _then(_$_BananaReqDisc(
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BananaReqDisc extends _BananaReqDisc {
  const _$_BananaReqDisc(
      {@JsonKey(name: r'length') required this.length,
      @JsonKey(name: r'fruitType') required this.fruitType})
      : super._();

  factory _$_BananaReqDisc.fromJson(Map<String, dynamic> json) =>
      _$$_BananaReqDiscFromJson(json);

  @override
  @JsonKey(name: r'length')
  final int length;
  @override
  @JsonKey(name: r'fruitType')
  final String fruitType;

  @override
  String toString() {
    return 'BananaReqDisc(length: $length, fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BananaReqDisc &&
            (identical(other.length, length) || other.length == length) &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, length, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BananaReqDiscCopyWith<_$_BananaReqDisc> get copyWith =>
      __$$_BananaReqDiscCopyWithImpl<_$_BananaReqDisc>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BananaReqDiscToJson(
      this,
    );
  }
}

abstract class _BananaReqDisc extends BananaReqDisc {
  const factory _BananaReqDisc(
          {@JsonKey(name: r'length') required final int length,
          @JsonKey(name: r'fruitType') required final String fruitType}) =
      _$_BananaReqDisc;
  const _BananaReqDisc._() : super._();

  factory _BananaReqDisc.fromJson(Map<String, dynamic> json) =
      _$_BananaReqDisc.fromJson;

  @override
  @JsonKey(name: r'length')
  int get length;
  @override
  @JsonKey(name: r'fruitType')
  String get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_BananaReqDiscCopyWith<_$_BananaReqDisc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ComposedDiscMissingFromProperties {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscMissingFromProperties discMissingFromPropertiesValue)
        asDiscMissingFromProperties,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingFromProperties> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscMissingFromProperties discMissingFromPropertiesValue)?
        asDiscMissingFromProperties,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingFromProperties> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscMissingFromProperties discMissingFromPropertiesValue)?
        asDiscMissingFromProperties,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingFromProperties> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties value)
        asDiscMissingFromProperties,
    required TResult Function(ComposedDiscMissingFromPropertiesUnknown value)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties value)?
        asDiscMissingFromProperties,
    TResult? Function(ComposedDiscMissingFromPropertiesUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties value)?
        asDiscMissingFromProperties,
    TResult Function(ComposedDiscMissingFromPropertiesUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComposedDiscMissingFromPropertiesCopyWith<$Res> {
  factory $ComposedDiscMissingFromPropertiesCopyWith(
          ComposedDiscMissingFromProperties value,
          $Res Function(ComposedDiscMissingFromProperties) then) =
      _$ComposedDiscMissingFromPropertiesCopyWithImpl<$Res,
          ComposedDiscMissingFromProperties>;
}

/// @nodoc
class _$ComposedDiscMissingFromPropertiesCopyWithImpl<$Res,
        $Val extends ComposedDiscMissingFromProperties>
    implements $ComposedDiscMissingFromPropertiesCopyWith<$Res> {
  _$ComposedDiscMissingFromPropertiesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ComposedDiscMissingFromPropertiesAsDiscMissingFromPropertiesCopyWith<
    $Res> {
  factory _$$ComposedDiscMissingFromPropertiesAsDiscMissingFromPropertiesCopyWith(
          _$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties value,
          $Res Function(
                  _$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties)
              then) =
      __$$ComposedDiscMissingFromPropertiesAsDiscMissingFromPropertiesCopyWithImpl<
          $Res>;
  @useResult
  $Res call({DiscMissingFromProperties discMissingFromPropertiesValue});

  $DiscMissingFromPropertiesCopyWith<$Res> get discMissingFromPropertiesValue;
}

/// @nodoc
class __$$ComposedDiscMissingFromPropertiesAsDiscMissingFromPropertiesCopyWithImpl<
        $Res>
    extends _$ComposedDiscMissingFromPropertiesCopyWithImpl<$Res,
        _$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties>
    implements
        _$$ComposedDiscMissingFromPropertiesAsDiscMissingFromPropertiesCopyWith<
            $Res> {
  __$$ComposedDiscMissingFromPropertiesAsDiscMissingFromPropertiesCopyWithImpl(
      _$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties _value,
      $Res Function(
              _$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? discMissingFromPropertiesValue = null,
  }) {
    return _then(_$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties(
      discMissingFromPropertiesValue: null == discMissingFromPropertiesValue
          ? _value.discMissingFromPropertiesValue
          : discMissingFromPropertiesValue // ignore: cast_nullable_to_non_nullable
              as DiscMissingFromProperties,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DiscMissingFromPropertiesCopyWith<$Res> get discMissingFromPropertiesValue {
    return $DiscMissingFromPropertiesCopyWith<$Res>(
        _value.discMissingFromPropertiesValue, (value) {
      return _then(_value.copyWith(discMissingFromPropertiesValue: value));
    });
  }
}

/// @nodoc

class _$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties
    extends ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties {
  const _$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties(
      {required this.discMissingFromPropertiesValue})
      : super._();

  @override
  final DiscMissingFromProperties discMissingFromPropertiesValue;

  @override
  String toString() {
    return 'ComposedDiscMissingFromProperties.asDiscMissingFromProperties(discMissingFromPropertiesValue: $discMissingFromPropertiesValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties &&
            (identical(other.discMissingFromPropertiesValue,
                    discMissingFromPropertiesValue) ||
                other.discMissingFromPropertiesValue ==
                    discMissingFromPropertiesValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, discMissingFromPropertiesValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscMissingFromPropertiesAsDiscMissingFromPropertiesCopyWith<
          _$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties>
      get copyWith =>
          __$$ComposedDiscMissingFromPropertiesAsDiscMissingFromPropertiesCopyWithImpl<
                  _$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscMissingFromProperties discMissingFromPropertiesValue)
        asDiscMissingFromProperties,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingFromProperties> deserializedModels)
        unknown,
  }) {
    return asDiscMissingFromProperties(discMissingFromPropertiesValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscMissingFromProperties discMissingFromPropertiesValue)?
        asDiscMissingFromProperties,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingFromProperties> deserializedModels)?
        unknown,
  }) {
    return asDiscMissingFromProperties?.call(discMissingFromPropertiesValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscMissingFromProperties discMissingFromPropertiesValue)?
        asDiscMissingFromProperties,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingFromProperties> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asDiscMissingFromProperties != null) {
      return asDiscMissingFromProperties(discMissingFromPropertiesValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties value)
        asDiscMissingFromProperties,
    required TResult Function(ComposedDiscMissingFromPropertiesUnknown value)
        unknown,
  }) {
    return asDiscMissingFromProperties(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties value)?
        asDiscMissingFromProperties,
    TResult? Function(ComposedDiscMissingFromPropertiesUnknown value)? unknown,
  }) {
    return asDiscMissingFromProperties?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties value)?
        asDiscMissingFromProperties,
    TResult Function(ComposedDiscMissingFromPropertiesUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asDiscMissingFromProperties != null) {
      return asDiscMissingFromProperties(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties
    extends ComposedDiscMissingFromProperties {
  const factory ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties(
          {required final DiscMissingFromProperties
              discMissingFromPropertiesValue}) =
      _$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties;
  const ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties._()
      : super._();

  DiscMissingFromProperties get discMissingFromPropertiesValue;
  @JsonKey(ignore: true)
  _$$ComposedDiscMissingFromPropertiesAsDiscMissingFromPropertiesCopyWith<
          _$ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposedDiscMissingFromPropertiesUnknownCopyWith<$Res> {
  factory _$$ComposedDiscMissingFromPropertiesUnknownCopyWith(
          _$ComposedDiscMissingFromPropertiesUnknown value,
          $Res Function(_$ComposedDiscMissingFromPropertiesUnknown) then) =
      __$$ComposedDiscMissingFromPropertiesUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<ComposedDiscMissingFromProperties> deserializedModels});
}

/// @nodoc
class __$$ComposedDiscMissingFromPropertiesUnknownCopyWithImpl<$Res>
    extends _$ComposedDiscMissingFromPropertiesCopyWithImpl<$Res,
        _$ComposedDiscMissingFromPropertiesUnknown>
    implements _$$ComposedDiscMissingFromPropertiesUnknownCopyWith<$Res> {
  __$$ComposedDiscMissingFromPropertiesUnknownCopyWithImpl(
      _$ComposedDiscMissingFromPropertiesUnknown _value,
      $Res Function(_$ComposedDiscMissingFromPropertiesUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$ComposedDiscMissingFromPropertiesUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<ComposedDiscMissingFromProperties>,
    ));
  }
}

/// @nodoc

class _$ComposedDiscMissingFromPropertiesUnknown
    extends ComposedDiscMissingFromPropertiesUnknown {
  const _$ComposedDiscMissingFromPropertiesUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[DiscMissingFromProperties],
      final List<ComposedDiscMissingFromProperties> deserializedModels =
          const <ComposedDiscMissingFromProperties>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<ComposedDiscMissingFromProperties> _deserializedModels;
  @override
  @JsonKey()
  List<ComposedDiscMissingFromProperties> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'ComposedDiscMissingFromProperties.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscMissingFromPropertiesUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscMissingFromPropertiesUnknownCopyWith<
          _$ComposedDiscMissingFromPropertiesUnknown>
      get copyWith => __$$ComposedDiscMissingFromPropertiesUnknownCopyWithImpl<
          _$ComposedDiscMissingFromPropertiesUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscMissingFromProperties discMissingFromPropertiesValue)
        asDiscMissingFromProperties,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingFromProperties> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscMissingFromProperties discMissingFromPropertiesValue)?
        asDiscMissingFromProperties,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingFromProperties> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscMissingFromProperties discMissingFromPropertiesValue)?
        asDiscMissingFromProperties,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingFromProperties> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties value)
        asDiscMissingFromProperties,
    required TResult Function(ComposedDiscMissingFromPropertiesUnknown value)
        unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties value)?
        asDiscMissingFromProperties,
    TResult? Function(ComposedDiscMissingFromPropertiesUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscMissingFromPropertiesAsDiscMissingFromProperties value)?
        asDiscMissingFromProperties,
    TResult Function(ComposedDiscMissingFromPropertiesUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscMissingFromPropertiesUnknown
    extends ComposedDiscMissingFromProperties {
  const factory ComposedDiscMissingFromPropertiesUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<ComposedDiscMissingFromProperties> deserializedModels}) =
      _$ComposedDiscMissingFromPropertiesUnknown;
  const ComposedDiscMissingFromPropertiesUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<ComposedDiscMissingFromProperties> get deserializedModels;
  @JsonKey(ignore: true)
  _$$ComposedDiscMissingFromPropertiesUnknownCopyWith<
          _$ComposedDiscMissingFromPropertiesUnknown>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ComposedDiscMissingNoProperties {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ObjectInUnion objectValue) asObject,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingNoProperties> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ObjectInUnion objectValue)? asObject,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingNoProperties> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ObjectInUnion objectValue)? asObject,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingNoProperties> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ComposedDiscMissingNoPropertiesAsObject value)
        asObject,
    required TResult Function(ComposedDiscMissingNoPropertiesUnknown value)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ComposedDiscMissingNoPropertiesAsObject value)? asObject,
    TResult? Function(ComposedDiscMissingNoPropertiesUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ComposedDiscMissingNoPropertiesAsObject value)? asObject,
    TResult Function(ComposedDiscMissingNoPropertiesUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComposedDiscMissingNoPropertiesCopyWith<$Res> {
  factory $ComposedDiscMissingNoPropertiesCopyWith(
          ComposedDiscMissingNoProperties value,
          $Res Function(ComposedDiscMissingNoProperties) then) =
      _$ComposedDiscMissingNoPropertiesCopyWithImpl<$Res,
          ComposedDiscMissingNoProperties>;
}

/// @nodoc
class _$ComposedDiscMissingNoPropertiesCopyWithImpl<$Res,
        $Val extends ComposedDiscMissingNoProperties>
    implements $ComposedDiscMissingNoPropertiesCopyWith<$Res> {
  _$ComposedDiscMissingNoPropertiesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ComposedDiscMissingNoPropertiesAsObjectCopyWith<$Res> {
  factory _$$ComposedDiscMissingNoPropertiesAsObjectCopyWith(
          _$ComposedDiscMissingNoPropertiesAsObject value,
          $Res Function(_$ComposedDiscMissingNoPropertiesAsObject) then) =
      __$$ComposedDiscMissingNoPropertiesAsObjectCopyWithImpl<$Res>;
  @useResult
  $Res call({ObjectInUnion objectValue});

  $ObjectInUnionCopyWith<$Res> get objectValue;
}

/// @nodoc
class __$$ComposedDiscMissingNoPropertiesAsObjectCopyWithImpl<$Res>
    extends _$ComposedDiscMissingNoPropertiesCopyWithImpl<$Res,
        _$ComposedDiscMissingNoPropertiesAsObject>
    implements _$$ComposedDiscMissingNoPropertiesAsObjectCopyWith<$Res> {
  __$$ComposedDiscMissingNoPropertiesAsObjectCopyWithImpl(
      _$ComposedDiscMissingNoPropertiesAsObject _value,
      $Res Function(_$ComposedDiscMissingNoPropertiesAsObject) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? objectValue = null,
  }) {
    return _then(_$ComposedDiscMissingNoPropertiesAsObject(
      objectValue: null == objectValue
          ? _value.objectValue
          : objectValue // ignore: cast_nullable_to_non_nullable
              as ObjectInUnion,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ObjectInUnionCopyWith<$Res> get objectValue {
    return $ObjectInUnionCopyWith<$Res>(_value.objectValue, (value) {
      return _then(_value.copyWith(objectValue: value));
    });
  }
}

/// @nodoc

class _$ComposedDiscMissingNoPropertiesAsObject
    extends ComposedDiscMissingNoPropertiesAsObject {
  const _$ComposedDiscMissingNoPropertiesAsObject({required this.objectValue})
      : super._();

  @override
  final ObjectInUnion objectValue;

  @override
  String toString() {
    return 'ComposedDiscMissingNoProperties.asObject(objectValue: $objectValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscMissingNoPropertiesAsObject &&
            (identical(other.objectValue, objectValue) ||
                other.objectValue == objectValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, objectValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscMissingNoPropertiesAsObjectCopyWith<
          _$ComposedDiscMissingNoPropertiesAsObject>
      get copyWith => __$$ComposedDiscMissingNoPropertiesAsObjectCopyWithImpl<
          _$ComposedDiscMissingNoPropertiesAsObject>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ObjectInUnion objectValue) asObject,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingNoProperties> deserializedModels)
        unknown,
  }) {
    return asObject(objectValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ObjectInUnion objectValue)? asObject,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingNoProperties> deserializedModels)?
        unknown,
  }) {
    return asObject?.call(objectValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ObjectInUnion objectValue)? asObject,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingNoProperties> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asObject != null) {
      return asObject(objectValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ComposedDiscMissingNoPropertiesAsObject value)
        asObject,
    required TResult Function(ComposedDiscMissingNoPropertiesUnknown value)
        unknown,
  }) {
    return asObject(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ComposedDiscMissingNoPropertiesAsObject value)? asObject,
    TResult? Function(ComposedDiscMissingNoPropertiesUnknown value)? unknown,
  }) {
    return asObject?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ComposedDiscMissingNoPropertiesAsObject value)? asObject,
    TResult Function(ComposedDiscMissingNoPropertiesUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asObject != null) {
      return asObject(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscMissingNoPropertiesAsObject
    extends ComposedDiscMissingNoProperties {
  const factory ComposedDiscMissingNoPropertiesAsObject(
          {required final ObjectInUnion objectValue}) =
      _$ComposedDiscMissingNoPropertiesAsObject;
  const ComposedDiscMissingNoPropertiesAsObject._() : super._();

  ObjectInUnion get objectValue;
  @JsonKey(ignore: true)
  _$$ComposedDiscMissingNoPropertiesAsObjectCopyWith<
          _$ComposedDiscMissingNoPropertiesAsObject>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposedDiscMissingNoPropertiesUnknownCopyWith<$Res> {
  factory _$$ComposedDiscMissingNoPropertiesUnknownCopyWith(
          _$ComposedDiscMissingNoPropertiesUnknown value,
          $Res Function(_$ComposedDiscMissingNoPropertiesUnknown) then) =
      __$$ComposedDiscMissingNoPropertiesUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<ComposedDiscMissingNoProperties> deserializedModels});
}

/// @nodoc
class __$$ComposedDiscMissingNoPropertiesUnknownCopyWithImpl<$Res>
    extends _$ComposedDiscMissingNoPropertiesCopyWithImpl<$Res,
        _$ComposedDiscMissingNoPropertiesUnknown>
    implements _$$ComposedDiscMissingNoPropertiesUnknownCopyWith<$Res> {
  __$$ComposedDiscMissingNoPropertiesUnknownCopyWithImpl(
      _$ComposedDiscMissingNoPropertiesUnknown _value,
      $Res Function(_$ComposedDiscMissingNoPropertiesUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$ComposedDiscMissingNoPropertiesUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<ComposedDiscMissingNoProperties>,
    ));
  }
}

/// @nodoc

class _$ComposedDiscMissingNoPropertiesUnknown
    extends ComposedDiscMissingNoPropertiesUnknown {
  const _$ComposedDiscMissingNoPropertiesUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[Object],
      final List<ComposedDiscMissingNoProperties> deserializedModels =
          const <ComposedDiscMissingNoProperties>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<ComposedDiscMissingNoProperties> _deserializedModels;
  @override
  @JsonKey()
  List<ComposedDiscMissingNoProperties> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'ComposedDiscMissingNoProperties.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscMissingNoPropertiesUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscMissingNoPropertiesUnknownCopyWith<
          _$ComposedDiscMissingNoPropertiesUnknown>
      get copyWith => __$$ComposedDiscMissingNoPropertiesUnknownCopyWithImpl<
          _$ComposedDiscMissingNoPropertiesUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ObjectInUnion objectValue) asObject,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingNoProperties> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ObjectInUnion objectValue)? asObject,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingNoProperties> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ObjectInUnion objectValue)? asObject,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscMissingNoProperties> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ComposedDiscMissingNoPropertiesAsObject value)
        asObject,
    required TResult Function(ComposedDiscMissingNoPropertiesUnknown value)
        unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ComposedDiscMissingNoPropertiesAsObject value)? asObject,
    TResult? Function(ComposedDiscMissingNoPropertiesUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ComposedDiscMissingNoPropertiesAsObject value)? asObject,
    TResult Function(ComposedDiscMissingNoPropertiesUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscMissingNoPropertiesUnknown
    extends ComposedDiscMissingNoProperties {
  const factory ComposedDiscMissingNoPropertiesUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<ComposedDiscMissingNoProperties> deserializedModels}) =
      _$ComposedDiscMissingNoPropertiesUnknown;
  const ComposedDiscMissingNoPropertiesUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<ComposedDiscMissingNoProperties> get deserializedModels;
  @JsonKey(ignore: true)
  _$$ComposedDiscMissingNoPropertiesUnknownCopyWith<
          _$ComposedDiscMissingNoPropertiesUnknown>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ComposedDiscOptionalTypeCorrect {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeCorrect discOptionalTypeCorrectValue)
        asDiscOptionalTypeCorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeCorrect> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeCorrect> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeCorrect> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect value)
        asDiscOptionalTypeCorrect,
    required TResult Function(ComposedDiscOptionalTypeCorrectUnknown value)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult? Function(ComposedDiscOptionalTypeCorrectUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult Function(ComposedDiscOptionalTypeCorrectUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComposedDiscOptionalTypeCorrectCopyWith<$Res> {
  factory $ComposedDiscOptionalTypeCorrectCopyWith(
          ComposedDiscOptionalTypeCorrect value,
          $Res Function(ComposedDiscOptionalTypeCorrect) then) =
      _$ComposedDiscOptionalTypeCorrectCopyWithImpl<$Res,
          ComposedDiscOptionalTypeCorrect>;
}

/// @nodoc
class _$ComposedDiscOptionalTypeCorrectCopyWithImpl<$Res,
        $Val extends ComposedDiscOptionalTypeCorrect>
    implements $ComposedDiscOptionalTypeCorrectCopyWith<$Res> {
  _$ComposedDiscOptionalTypeCorrectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrectCopyWith<
    $Res> {
  factory _$$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrectCopyWith(
          _$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect value,
          $Res Function(
                  _$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect)
              then) =
      __$$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrectCopyWithImpl<
          $Res>;
  @useResult
  $Res call({DiscOptionalTypeCorrect discOptionalTypeCorrectValue});

  $DiscOptionalTypeCorrectCopyWith<$Res> get discOptionalTypeCorrectValue;
}

/// @nodoc
class __$$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrectCopyWithImpl<
        $Res>
    extends _$ComposedDiscOptionalTypeCorrectCopyWithImpl<$Res,
        _$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect>
    implements
        _$$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrectCopyWith<
            $Res> {
  __$$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrectCopyWithImpl(
      _$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect _value,
      $Res Function(_$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? discOptionalTypeCorrectValue = null,
  }) {
    return _then(_$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect(
      discOptionalTypeCorrectValue: null == discOptionalTypeCorrectValue
          ? _value.discOptionalTypeCorrectValue
          : discOptionalTypeCorrectValue // ignore: cast_nullable_to_non_nullable
              as DiscOptionalTypeCorrect,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DiscOptionalTypeCorrectCopyWith<$Res> get discOptionalTypeCorrectValue {
    return $DiscOptionalTypeCorrectCopyWith<$Res>(
        _value.discOptionalTypeCorrectValue, (value) {
      return _then(_value.copyWith(discOptionalTypeCorrectValue: value));
    });
  }
}

/// @nodoc

class _$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect
    extends ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect {
  const _$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect(
      {required this.discOptionalTypeCorrectValue})
      : super._();

  @override
  final DiscOptionalTypeCorrect discOptionalTypeCorrectValue;

  @override
  String toString() {
    return 'ComposedDiscOptionalTypeCorrect.asDiscOptionalTypeCorrect(discOptionalTypeCorrectValue: $discOptionalTypeCorrectValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect &&
            (identical(other.discOptionalTypeCorrectValue,
                    discOptionalTypeCorrectValue) ||
                other.discOptionalTypeCorrectValue ==
                    discOptionalTypeCorrectValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, discOptionalTypeCorrectValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrectCopyWith<
          _$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect>
      get copyWith =>
          __$$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrectCopyWithImpl<
                  _$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeCorrect discOptionalTypeCorrectValue)
        asDiscOptionalTypeCorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeCorrect> deserializedModels)
        unknown,
  }) {
    return asDiscOptionalTypeCorrect(discOptionalTypeCorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeCorrect> deserializedModels)?
        unknown,
  }) {
    return asDiscOptionalTypeCorrect?.call(discOptionalTypeCorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeCorrect> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asDiscOptionalTypeCorrect != null) {
      return asDiscOptionalTypeCorrect(discOptionalTypeCorrectValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect value)
        asDiscOptionalTypeCorrect,
    required TResult Function(ComposedDiscOptionalTypeCorrectUnknown value)
        unknown,
  }) {
    return asDiscOptionalTypeCorrect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult? Function(ComposedDiscOptionalTypeCorrectUnknown value)? unknown,
  }) {
    return asDiscOptionalTypeCorrect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult Function(ComposedDiscOptionalTypeCorrectUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asDiscOptionalTypeCorrect != null) {
      return asDiscOptionalTypeCorrect(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect
    extends ComposedDiscOptionalTypeCorrect {
  const factory ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect(
          {required final DiscOptionalTypeCorrect
              discOptionalTypeCorrectValue}) =
      _$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect;
  const ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect._()
      : super._();

  DiscOptionalTypeCorrect get discOptionalTypeCorrectValue;
  @JsonKey(ignore: true)
  _$$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrectCopyWith<
          _$ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposedDiscOptionalTypeCorrectUnknownCopyWith<$Res> {
  factory _$$ComposedDiscOptionalTypeCorrectUnknownCopyWith(
          _$ComposedDiscOptionalTypeCorrectUnknown value,
          $Res Function(_$ComposedDiscOptionalTypeCorrectUnknown) then) =
      __$$ComposedDiscOptionalTypeCorrectUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<ComposedDiscOptionalTypeCorrect> deserializedModels});
}

/// @nodoc
class __$$ComposedDiscOptionalTypeCorrectUnknownCopyWithImpl<$Res>
    extends _$ComposedDiscOptionalTypeCorrectCopyWithImpl<$Res,
        _$ComposedDiscOptionalTypeCorrectUnknown>
    implements _$$ComposedDiscOptionalTypeCorrectUnknownCopyWith<$Res> {
  __$$ComposedDiscOptionalTypeCorrectUnknownCopyWithImpl(
      _$ComposedDiscOptionalTypeCorrectUnknown _value,
      $Res Function(_$ComposedDiscOptionalTypeCorrectUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$ComposedDiscOptionalTypeCorrectUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<ComposedDiscOptionalTypeCorrect>,
    ));
  }
}

/// @nodoc

class _$ComposedDiscOptionalTypeCorrectUnknown
    extends ComposedDiscOptionalTypeCorrectUnknown {
  const _$ComposedDiscOptionalTypeCorrectUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[DiscOptionalTypeCorrect],
      final List<ComposedDiscOptionalTypeCorrect> deserializedModels =
          const <ComposedDiscOptionalTypeCorrect>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<ComposedDiscOptionalTypeCorrect> _deserializedModels;
  @override
  @JsonKey()
  List<ComposedDiscOptionalTypeCorrect> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'ComposedDiscOptionalTypeCorrect.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscOptionalTypeCorrectUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscOptionalTypeCorrectUnknownCopyWith<
          _$ComposedDiscOptionalTypeCorrectUnknown>
      get copyWith => __$$ComposedDiscOptionalTypeCorrectUnknownCopyWithImpl<
          _$ComposedDiscOptionalTypeCorrectUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeCorrect discOptionalTypeCorrectValue)
        asDiscOptionalTypeCorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeCorrect> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeCorrect> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeCorrect> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect value)
        asDiscOptionalTypeCorrect,
    required TResult Function(ComposedDiscOptionalTypeCorrectUnknown value)
        unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult? Function(ComposedDiscOptionalTypeCorrectUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscOptionalTypeCorrectAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult Function(ComposedDiscOptionalTypeCorrectUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscOptionalTypeCorrectUnknown
    extends ComposedDiscOptionalTypeCorrect {
  const factory ComposedDiscOptionalTypeCorrectUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<ComposedDiscOptionalTypeCorrect> deserializedModels}) =
      _$ComposedDiscOptionalTypeCorrectUnknown;
  const ComposedDiscOptionalTypeCorrectUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<ComposedDiscOptionalTypeCorrect> get deserializedModels;
  @JsonKey(ignore: true)
  _$$ComposedDiscOptionalTypeCorrectUnknownCopyWith<
          _$ComposedDiscOptionalTypeCorrectUnknown>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ComposedDiscOptionalTypeInconsistent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeCorrect discOptionalTypeCorrectValue)
        asDiscOptionalTypeCorrect,
    required TResult Function(
            DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)
        asDiscOptionalTypeIncorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeInconsistent> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult? Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeInconsistent> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeInconsistent> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect value)
        asDiscOptionalTypeCorrect,
    required TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
                value)
        asDiscOptionalTypeIncorrect,
    required TResult Function(ComposedDiscOptionalTypeInconsistentUnknown value)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect
                value)?
        asDiscOptionalTypeCorrect,
    TResult? Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
                value)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(ComposedDiscOptionalTypeInconsistentUnknown value)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect
                value)?
        asDiscOptionalTypeCorrect,
    TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
                value)?
        asDiscOptionalTypeIncorrect,
    TResult Function(ComposedDiscOptionalTypeInconsistentUnknown value)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComposedDiscOptionalTypeInconsistentCopyWith<$Res> {
  factory $ComposedDiscOptionalTypeInconsistentCopyWith(
          ComposedDiscOptionalTypeInconsistent value,
          $Res Function(ComposedDiscOptionalTypeInconsistent) then) =
      _$ComposedDiscOptionalTypeInconsistentCopyWithImpl<$Res,
          ComposedDiscOptionalTypeInconsistent>;
}

/// @nodoc
class _$ComposedDiscOptionalTypeInconsistentCopyWithImpl<$Res,
        $Val extends ComposedDiscOptionalTypeInconsistent>
    implements $ComposedDiscOptionalTypeInconsistentCopyWith<$Res> {
  _$ComposedDiscOptionalTypeInconsistentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrectCopyWith<
    $Res> {
  factory _$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrectCopyWith(
          _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect value,
          $Res Function(
                  _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect)
              then) =
      __$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrectCopyWithImpl<
          $Res>;
  @useResult
  $Res call({DiscOptionalTypeCorrect discOptionalTypeCorrectValue});

  $DiscOptionalTypeCorrectCopyWith<$Res> get discOptionalTypeCorrectValue;
}

/// @nodoc
class __$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrectCopyWithImpl<
        $Res>
    extends _$ComposedDiscOptionalTypeInconsistentCopyWithImpl<$Res,
        _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect>
    implements
        _$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrectCopyWith<
            $Res> {
  __$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrectCopyWithImpl(
      _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect _value,
      $Res Function(
              _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? discOptionalTypeCorrectValue = null,
  }) {
    return _then(
        _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect(
      discOptionalTypeCorrectValue: null == discOptionalTypeCorrectValue
          ? _value.discOptionalTypeCorrectValue
          : discOptionalTypeCorrectValue // ignore: cast_nullable_to_non_nullable
              as DiscOptionalTypeCorrect,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DiscOptionalTypeCorrectCopyWith<$Res> get discOptionalTypeCorrectValue {
    return $DiscOptionalTypeCorrectCopyWith<$Res>(
        _value.discOptionalTypeCorrectValue, (value) {
      return _then(_value.copyWith(discOptionalTypeCorrectValue: value));
    });
  }
}

/// @nodoc

class _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect
    extends ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect {
  const _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect(
      {required this.discOptionalTypeCorrectValue})
      : super._();

  @override
  final DiscOptionalTypeCorrect discOptionalTypeCorrectValue;

  @override
  String toString() {
    return 'ComposedDiscOptionalTypeInconsistent.asDiscOptionalTypeCorrect(discOptionalTypeCorrectValue: $discOptionalTypeCorrectValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect &&
            (identical(other.discOptionalTypeCorrectValue,
                    discOptionalTypeCorrectValue) ||
                other.discOptionalTypeCorrectValue ==
                    discOptionalTypeCorrectValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, discOptionalTypeCorrectValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrectCopyWith<
          _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect>
      get copyWith =>
          __$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrectCopyWithImpl<
                  _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeCorrect discOptionalTypeCorrectValue)
        asDiscOptionalTypeCorrect,
    required TResult Function(
            DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)
        asDiscOptionalTypeIncorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeInconsistent> deserializedModels)
        unknown,
  }) {
    return asDiscOptionalTypeCorrect(discOptionalTypeCorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult? Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeInconsistent> deserializedModels)?
        unknown,
  }) {
    return asDiscOptionalTypeCorrect?.call(discOptionalTypeCorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeInconsistent> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asDiscOptionalTypeCorrect != null) {
      return asDiscOptionalTypeCorrect(discOptionalTypeCorrectValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect value)
        asDiscOptionalTypeCorrect,
    required TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
                value)
        asDiscOptionalTypeIncorrect,
    required TResult Function(ComposedDiscOptionalTypeInconsistentUnknown value)
        unknown,
  }) {
    return asDiscOptionalTypeCorrect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect
                value)?
        asDiscOptionalTypeCorrect,
    TResult? Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
                value)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(ComposedDiscOptionalTypeInconsistentUnknown value)?
        unknown,
  }) {
    return asDiscOptionalTypeCorrect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect
                value)?
        asDiscOptionalTypeCorrect,
    TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
                value)?
        asDiscOptionalTypeIncorrect,
    TResult Function(ComposedDiscOptionalTypeInconsistentUnknown value)?
        unknown,
    required TResult orElse(),
  }) {
    if (asDiscOptionalTypeCorrect != null) {
      return asDiscOptionalTypeCorrect(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect
    extends ComposedDiscOptionalTypeInconsistent {
  const factory ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect(
          {required final DiscOptionalTypeCorrect
              discOptionalTypeCorrectValue}) =
      _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect;
  const ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect._()
      : super._();

  DiscOptionalTypeCorrect get discOptionalTypeCorrectValue;
  @JsonKey(ignore: true)
  _$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrectCopyWith<
          _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrectCopyWith<
    $Res> {
  factory _$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrectCopyWith(
          _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect value,
          $Res Function(
                  _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect)
              then) =
      __$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrectCopyWithImpl<
          $Res>;
  @useResult
  $Res call({DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue});

  $DiscOptionalTypeIncorrectCopyWith<$Res> get discOptionalTypeIncorrectValue;
}

/// @nodoc
class __$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrectCopyWithImpl<
        $Res>
    extends _$ComposedDiscOptionalTypeInconsistentCopyWithImpl<$Res,
        _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect>
    implements
        _$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrectCopyWith<
            $Res> {
  __$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrectCopyWithImpl(
      _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect _value,
      $Res Function(
              _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? discOptionalTypeIncorrectValue = null,
  }) {
    return _then(
        _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect(
      discOptionalTypeIncorrectValue: null == discOptionalTypeIncorrectValue
          ? _value.discOptionalTypeIncorrectValue
          : discOptionalTypeIncorrectValue // ignore: cast_nullable_to_non_nullable
              as DiscOptionalTypeIncorrect,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DiscOptionalTypeIncorrectCopyWith<$Res> get discOptionalTypeIncorrectValue {
    return $DiscOptionalTypeIncorrectCopyWith<$Res>(
        _value.discOptionalTypeIncorrectValue, (value) {
      return _then(_value.copyWith(discOptionalTypeIncorrectValue: value));
    });
  }
}

/// @nodoc

class _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
    extends ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect {
  const _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect(
      {required this.discOptionalTypeIncorrectValue})
      : super._();

  @override
  final DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue;

  @override
  String toString() {
    return 'ComposedDiscOptionalTypeInconsistent.asDiscOptionalTypeIncorrect(discOptionalTypeIncorrectValue: $discOptionalTypeIncorrectValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect &&
            (identical(other.discOptionalTypeIncorrectValue,
                    discOptionalTypeIncorrectValue) ||
                other.discOptionalTypeIncorrectValue ==
                    discOptionalTypeIncorrectValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, discOptionalTypeIncorrectValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrectCopyWith<
          _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect>
      get copyWith =>
          __$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrectCopyWithImpl<
                  _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeCorrect discOptionalTypeCorrectValue)
        asDiscOptionalTypeCorrect,
    required TResult Function(
            DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)
        asDiscOptionalTypeIncorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeInconsistent> deserializedModels)
        unknown,
  }) {
    return asDiscOptionalTypeIncorrect(discOptionalTypeIncorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult? Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeInconsistent> deserializedModels)?
        unknown,
  }) {
    return asDiscOptionalTypeIncorrect?.call(discOptionalTypeIncorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeInconsistent> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asDiscOptionalTypeIncorrect != null) {
      return asDiscOptionalTypeIncorrect(discOptionalTypeIncorrectValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect value)
        asDiscOptionalTypeCorrect,
    required TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
                value)
        asDiscOptionalTypeIncorrect,
    required TResult Function(ComposedDiscOptionalTypeInconsistentUnknown value)
        unknown,
  }) {
    return asDiscOptionalTypeIncorrect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect
                value)?
        asDiscOptionalTypeCorrect,
    TResult? Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
                value)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(ComposedDiscOptionalTypeInconsistentUnknown value)?
        unknown,
  }) {
    return asDiscOptionalTypeIncorrect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect
                value)?
        asDiscOptionalTypeCorrect,
    TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
                value)?
        asDiscOptionalTypeIncorrect,
    TResult Function(ComposedDiscOptionalTypeInconsistentUnknown value)?
        unknown,
    required TResult orElse(),
  }) {
    if (asDiscOptionalTypeIncorrect != null) {
      return asDiscOptionalTypeIncorrect(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
    extends ComposedDiscOptionalTypeInconsistent {
  const factory ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect(
          {required final DiscOptionalTypeIncorrect
              discOptionalTypeIncorrectValue}) =
      _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect;
  const ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect._()
      : super._();

  DiscOptionalTypeIncorrect get discOptionalTypeIncorrectValue;
  @JsonKey(ignore: true)
  _$$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrectCopyWith<
          _$ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposedDiscOptionalTypeInconsistentUnknownCopyWith<$Res> {
  factory _$$ComposedDiscOptionalTypeInconsistentUnknownCopyWith(
          _$ComposedDiscOptionalTypeInconsistentUnknown value,
          $Res Function(_$ComposedDiscOptionalTypeInconsistentUnknown) then) =
      __$$ComposedDiscOptionalTypeInconsistentUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<ComposedDiscOptionalTypeInconsistent> deserializedModels});
}

/// @nodoc
class __$$ComposedDiscOptionalTypeInconsistentUnknownCopyWithImpl<$Res>
    extends _$ComposedDiscOptionalTypeInconsistentCopyWithImpl<$Res,
        _$ComposedDiscOptionalTypeInconsistentUnknown>
    implements _$$ComposedDiscOptionalTypeInconsistentUnknownCopyWith<$Res> {
  __$$ComposedDiscOptionalTypeInconsistentUnknownCopyWithImpl(
      _$ComposedDiscOptionalTypeInconsistentUnknown _value,
      $Res Function(_$ComposedDiscOptionalTypeInconsistentUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$ComposedDiscOptionalTypeInconsistentUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<ComposedDiscOptionalTypeInconsistent>,
    ));
  }
}

/// @nodoc

class _$ComposedDiscOptionalTypeInconsistentUnknown
    extends ComposedDiscOptionalTypeInconsistentUnknown {
  const _$ComposedDiscOptionalTypeInconsistentUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        DiscOptionalTypeCorrect,
        DiscOptionalTypeIncorrect
      ],
      final List<ComposedDiscOptionalTypeInconsistent> deserializedModels =
          const <ComposedDiscOptionalTypeInconsistent>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<ComposedDiscOptionalTypeInconsistent> _deserializedModels;
  @override
  @JsonKey()
  List<ComposedDiscOptionalTypeInconsistent> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'ComposedDiscOptionalTypeInconsistent.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscOptionalTypeInconsistentUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscOptionalTypeInconsistentUnknownCopyWith<
          _$ComposedDiscOptionalTypeInconsistentUnknown>
      get copyWith =>
          __$$ComposedDiscOptionalTypeInconsistentUnknownCopyWithImpl<
              _$ComposedDiscOptionalTypeInconsistentUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeCorrect discOptionalTypeCorrectValue)
        asDiscOptionalTypeCorrect,
    required TResult Function(
            DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)
        asDiscOptionalTypeIncorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeInconsistent> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult? Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeInconsistent> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeInconsistent> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect value)
        asDiscOptionalTypeCorrect,
    required TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
                value)
        asDiscOptionalTypeIncorrect,
    required TResult Function(ComposedDiscOptionalTypeInconsistentUnknown value)
        unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect
                value)?
        asDiscOptionalTypeCorrect,
    TResult? Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
                value)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(ComposedDiscOptionalTypeInconsistentUnknown value)?
        unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeCorrect
                value)?
        asDiscOptionalTypeCorrect,
    TResult Function(
            ComposedDiscOptionalTypeInconsistentAsDiscOptionalTypeIncorrect
                value)?
        asDiscOptionalTypeIncorrect,
    TResult Function(ComposedDiscOptionalTypeInconsistentUnknown value)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscOptionalTypeInconsistentUnknown
    extends ComposedDiscOptionalTypeInconsistent {
  const factory ComposedDiscOptionalTypeInconsistentUnknown(
      {final String message,
      required final Map<String, dynamic> json,
      final DeserializationErrorType errorType,
      final List<Type> possibleTypes,
      final List<ComposedDiscOptionalTypeInconsistent>
          deserializedModels}) = _$ComposedDiscOptionalTypeInconsistentUnknown;
  const ComposedDiscOptionalTypeInconsistentUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<ComposedDiscOptionalTypeInconsistent> get deserializedModels;
  @JsonKey(ignore: true)
  _$$ComposedDiscOptionalTypeInconsistentUnknownCopyWith<
          _$ComposedDiscOptionalTypeInconsistentUnknown>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ComposedDiscOptionalTypeIncorrect {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)
        asDiscOptionalTypeIncorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeIncorrect> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeIncorrect> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeIncorrect> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect value)
        asDiscOptionalTypeIncorrect,
    required TResult Function(ComposedDiscOptionalTypeIncorrectUnknown value)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect value)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(ComposedDiscOptionalTypeIncorrectUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect value)?
        asDiscOptionalTypeIncorrect,
    TResult Function(ComposedDiscOptionalTypeIncorrectUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComposedDiscOptionalTypeIncorrectCopyWith<$Res> {
  factory $ComposedDiscOptionalTypeIncorrectCopyWith(
          ComposedDiscOptionalTypeIncorrect value,
          $Res Function(ComposedDiscOptionalTypeIncorrect) then) =
      _$ComposedDiscOptionalTypeIncorrectCopyWithImpl<$Res,
          ComposedDiscOptionalTypeIncorrect>;
}

/// @nodoc
class _$ComposedDiscOptionalTypeIncorrectCopyWithImpl<$Res,
        $Val extends ComposedDiscOptionalTypeIncorrect>
    implements $ComposedDiscOptionalTypeIncorrectCopyWith<$Res> {
  _$ComposedDiscOptionalTypeIncorrectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrectCopyWith<
    $Res> {
  factory _$$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrectCopyWith(
          _$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect value,
          $Res Function(
                  _$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect)
              then) =
      __$$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrectCopyWithImpl<
          $Res>;
  @useResult
  $Res call({DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue});

  $DiscOptionalTypeIncorrectCopyWith<$Res> get discOptionalTypeIncorrectValue;
}

/// @nodoc
class __$$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrectCopyWithImpl<
        $Res>
    extends _$ComposedDiscOptionalTypeIncorrectCopyWithImpl<$Res,
        _$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect>
    implements
        _$$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrectCopyWith<
            $Res> {
  __$$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrectCopyWithImpl(
      _$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect _value,
      $Res Function(
              _$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? discOptionalTypeIncorrectValue = null,
  }) {
    return _then(_$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect(
      discOptionalTypeIncorrectValue: null == discOptionalTypeIncorrectValue
          ? _value.discOptionalTypeIncorrectValue
          : discOptionalTypeIncorrectValue // ignore: cast_nullable_to_non_nullable
              as DiscOptionalTypeIncorrect,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DiscOptionalTypeIncorrectCopyWith<$Res> get discOptionalTypeIncorrectValue {
    return $DiscOptionalTypeIncorrectCopyWith<$Res>(
        _value.discOptionalTypeIncorrectValue, (value) {
      return _then(_value.copyWith(discOptionalTypeIncorrectValue: value));
    });
  }
}

/// @nodoc

class _$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect
    extends ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect {
  const _$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect(
      {required this.discOptionalTypeIncorrectValue})
      : super._();

  @override
  final DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue;

  @override
  String toString() {
    return 'ComposedDiscOptionalTypeIncorrect.asDiscOptionalTypeIncorrect(discOptionalTypeIncorrectValue: $discOptionalTypeIncorrectValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect &&
            (identical(other.discOptionalTypeIncorrectValue,
                    discOptionalTypeIncorrectValue) ||
                other.discOptionalTypeIncorrectValue ==
                    discOptionalTypeIncorrectValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, discOptionalTypeIncorrectValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrectCopyWith<
          _$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect>
      get copyWith =>
          __$$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrectCopyWithImpl<
                  _$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)
        asDiscOptionalTypeIncorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeIncorrect> deserializedModels)
        unknown,
  }) {
    return asDiscOptionalTypeIncorrect(discOptionalTypeIncorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeIncorrect> deserializedModels)?
        unknown,
  }) {
    return asDiscOptionalTypeIncorrect?.call(discOptionalTypeIncorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeIncorrect> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asDiscOptionalTypeIncorrect != null) {
      return asDiscOptionalTypeIncorrect(discOptionalTypeIncorrectValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect value)
        asDiscOptionalTypeIncorrect,
    required TResult Function(ComposedDiscOptionalTypeIncorrectUnknown value)
        unknown,
  }) {
    return asDiscOptionalTypeIncorrect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect value)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(ComposedDiscOptionalTypeIncorrectUnknown value)? unknown,
  }) {
    return asDiscOptionalTypeIncorrect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect value)?
        asDiscOptionalTypeIncorrect,
    TResult Function(ComposedDiscOptionalTypeIncorrectUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asDiscOptionalTypeIncorrect != null) {
      return asDiscOptionalTypeIncorrect(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect
    extends ComposedDiscOptionalTypeIncorrect {
  const factory ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect(
          {required final DiscOptionalTypeIncorrect
              discOptionalTypeIncorrectValue}) =
      _$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect;
  const ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect._()
      : super._();

  DiscOptionalTypeIncorrect get discOptionalTypeIncorrectValue;
  @JsonKey(ignore: true)
  _$$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrectCopyWith<
          _$ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposedDiscOptionalTypeIncorrectUnknownCopyWith<$Res> {
  factory _$$ComposedDiscOptionalTypeIncorrectUnknownCopyWith(
          _$ComposedDiscOptionalTypeIncorrectUnknown value,
          $Res Function(_$ComposedDiscOptionalTypeIncorrectUnknown) then) =
      __$$ComposedDiscOptionalTypeIncorrectUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<ComposedDiscOptionalTypeIncorrect> deserializedModels});
}

/// @nodoc
class __$$ComposedDiscOptionalTypeIncorrectUnknownCopyWithImpl<$Res>
    extends _$ComposedDiscOptionalTypeIncorrectCopyWithImpl<$Res,
        _$ComposedDiscOptionalTypeIncorrectUnknown>
    implements _$$ComposedDiscOptionalTypeIncorrectUnknownCopyWith<$Res> {
  __$$ComposedDiscOptionalTypeIncorrectUnknownCopyWithImpl(
      _$ComposedDiscOptionalTypeIncorrectUnknown _value,
      $Res Function(_$ComposedDiscOptionalTypeIncorrectUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$ComposedDiscOptionalTypeIncorrectUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<ComposedDiscOptionalTypeIncorrect>,
    ));
  }
}

/// @nodoc

class _$ComposedDiscOptionalTypeIncorrectUnknown
    extends ComposedDiscOptionalTypeIncorrectUnknown {
  const _$ComposedDiscOptionalTypeIncorrectUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[DiscOptionalTypeIncorrect],
      final List<ComposedDiscOptionalTypeIncorrect> deserializedModels =
          const <ComposedDiscOptionalTypeIncorrect>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<ComposedDiscOptionalTypeIncorrect> _deserializedModels;
  @override
  @JsonKey()
  List<ComposedDiscOptionalTypeIncorrect> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'ComposedDiscOptionalTypeIncorrect.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscOptionalTypeIncorrectUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscOptionalTypeIncorrectUnknownCopyWith<
          _$ComposedDiscOptionalTypeIncorrectUnknown>
      get copyWith => __$$ComposedDiscOptionalTypeIncorrectUnknownCopyWithImpl<
          _$ComposedDiscOptionalTypeIncorrectUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)
        asDiscOptionalTypeIncorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeIncorrect> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeIncorrect> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeIncorrect discOptionalTypeIncorrectValue)?
        asDiscOptionalTypeIncorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscOptionalTypeIncorrect> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect value)
        asDiscOptionalTypeIncorrect,
    required TResult Function(ComposedDiscOptionalTypeIncorrectUnknown value)
        unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect value)?
        asDiscOptionalTypeIncorrect,
    TResult? Function(ComposedDiscOptionalTypeIncorrectUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscOptionalTypeIncorrectAsDiscOptionalTypeIncorrect value)?
        asDiscOptionalTypeIncorrect,
    TResult Function(ComposedDiscOptionalTypeIncorrectUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscOptionalTypeIncorrectUnknown
    extends ComposedDiscOptionalTypeIncorrect {
  const factory ComposedDiscOptionalTypeIncorrectUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<ComposedDiscOptionalTypeIncorrect> deserializedModels}) =
      _$ComposedDiscOptionalTypeIncorrectUnknown;
  const ComposedDiscOptionalTypeIncorrectUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<ComposedDiscOptionalTypeIncorrect> get deserializedModels;
  @JsonKey(ignore: true)
  _$$ComposedDiscOptionalTypeIncorrectUnknownCopyWith<
          _$ComposedDiscOptionalTypeIncorrectUnknown>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ComposedDiscRequiredInconsistent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeCorrect discOptionalTypeCorrectValue)
        asDiscOptionalTypeCorrect,
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscRequiredInconsistent> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscRequiredInconsistent> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscRequiredInconsistent> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value)
        asDiscOptionalTypeCorrect,
    required TResult Function(ComposedDiscRequiredInconsistentAsFruitType value)
        asFruitType,
    required TResult Function(ComposedDiscRequiredInconsistentUnknown value)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult? Function(ComposedDiscRequiredInconsistentAsFruitType value)?
        asFruitType,
    TResult? Function(ComposedDiscRequiredInconsistentUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult Function(ComposedDiscRequiredInconsistentAsFruitType value)?
        asFruitType,
    TResult Function(ComposedDiscRequiredInconsistentUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComposedDiscRequiredInconsistentCopyWith<$Res> {
  factory $ComposedDiscRequiredInconsistentCopyWith(
          ComposedDiscRequiredInconsistent value,
          $Res Function(ComposedDiscRequiredInconsistent) then) =
      _$ComposedDiscRequiredInconsistentCopyWithImpl<$Res,
          ComposedDiscRequiredInconsistent>;
}

/// @nodoc
class _$ComposedDiscRequiredInconsistentCopyWithImpl<$Res,
        $Val extends ComposedDiscRequiredInconsistent>
    implements $ComposedDiscRequiredInconsistentCopyWith<$Res> {
  _$ComposedDiscRequiredInconsistentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrectCopyWith<
    $Res> {
  factory _$$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrectCopyWith(
          _$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value,
          $Res Function(
                  _$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect)
              then) =
      __$$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrectCopyWithImpl<
          $Res>;
  @useResult
  $Res call({DiscOptionalTypeCorrect discOptionalTypeCorrectValue});

  $DiscOptionalTypeCorrectCopyWith<$Res> get discOptionalTypeCorrectValue;
}

/// @nodoc
class __$$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrectCopyWithImpl<
        $Res>
    extends _$ComposedDiscRequiredInconsistentCopyWithImpl<$Res,
        _$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect>
    implements
        _$$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrectCopyWith<
            $Res> {
  __$$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrectCopyWithImpl(
      _$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect _value,
      $Res Function(_$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? discOptionalTypeCorrectValue = null,
  }) {
    return _then(_$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect(
      discOptionalTypeCorrectValue: null == discOptionalTypeCorrectValue
          ? _value.discOptionalTypeCorrectValue
          : discOptionalTypeCorrectValue // ignore: cast_nullable_to_non_nullable
              as DiscOptionalTypeCorrect,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DiscOptionalTypeCorrectCopyWith<$Res> get discOptionalTypeCorrectValue {
    return $DiscOptionalTypeCorrectCopyWith<$Res>(
        _value.discOptionalTypeCorrectValue, (value) {
      return _then(_value.copyWith(discOptionalTypeCorrectValue: value));
    });
  }
}

/// @nodoc

class _$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect
    extends ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect {
  const _$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect(
      {required this.discOptionalTypeCorrectValue})
      : super._();

  @override
  final DiscOptionalTypeCorrect discOptionalTypeCorrectValue;

  @override
  String toString() {
    return 'ComposedDiscRequiredInconsistent.asDiscOptionalTypeCorrect(discOptionalTypeCorrectValue: $discOptionalTypeCorrectValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect &&
            (identical(other.discOptionalTypeCorrectValue,
                    discOptionalTypeCorrectValue) ||
                other.discOptionalTypeCorrectValue ==
                    discOptionalTypeCorrectValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, discOptionalTypeCorrectValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrectCopyWith<
          _$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect>
      get copyWith =>
          __$$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrectCopyWithImpl<
                  _$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeCorrect discOptionalTypeCorrectValue)
        asDiscOptionalTypeCorrect,
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscRequiredInconsistent> deserializedModels)
        unknown,
  }) {
    return asDiscOptionalTypeCorrect(discOptionalTypeCorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscRequiredInconsistent> deserializedModels)?
        unknown,
  }) {
    return asDiscOptionalTypeCorrect?.call(discOptionalTypeCorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscRequiredInconsistent> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asDiscOptionalTypeCorrect != null) {
      return asDiscOptionalTypeCorrect(discOptionalTypeCorrectValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value)
        asDiscOptionalTypeCorrect,
    required TResult Function(ComposedDiscRequiredInconsistentAsFruitType value)
        asFruitType,
    required TResult Function(ComposedDiscRequiredInconsistentUnknown value)
        unknown,
  }) {
    return asDiscOptionalTypeCorrect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult? Function(ComposedDiscRequiredInconsistentAsFruitType value)?
        asFruitType,
    TResult? Function(ComposedDiscRequiredInconsistentUnknown value)? unknown,
  }) {
    return asDiscOptionalTypeCorrect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult Function(ComposedDiscRequiredInconsistentAsFruitType value)?
        asFruitType,
    TResult Function(ComposedDiscRequiredInconsistentUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asDiscOptionalTypeCorrect != null) {
      return asDiscOptionalTypeCorrect(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect
    extends ComposedDiscRequiredInconsistent {
  const factory ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect(
          {required final DiscOptionalTypeCorrect
              discOptionalTypeCorrectValue}) =
      _$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect;
  const ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect._()
      : super._();

  DiscOptionalTypeCorrect get discOptionalTypeCorrectValue;
  @JsonKey(ignore: true)
  _$$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrectCopyWith<
          _$ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposedDiscRequiredInconsistentAsFruitTypeCopyWith<$Res> {
  factory _$$ComposedDiscRequiredInconsistentAsFruitTypeCopyWith(
          _$ComposedDiscRequiredInconsistentAsFruitType value,
          $Res Function(_$ComposedDiscRequiredInconsistentAsFruitType) then) =
      __$$ComposedDiscRequiredInconsistentAsFruitTypeCopyWithImpl<$Res>;
  @useResult
  $Res call({FruitType fruitTypeValue});

  $FruitTypeCopyWith<$Res> get fruitTypeValue;
}

/// @nodoc
class __$$ComposedDiscRequiredInconsistentAsFruitTypeCopyWithImpl<$Res>
    extends _$ComposedDiscRequiredInconsistentCopyWithImpl<$Res,
        _$ComposedDiscRequiredInconsistentAsFruitType>
    implements _$$ComposedDiscRequiredInconsistentAsFruitTypeCopyWith<$Res> {
  __$$ComposedDiscRequiredInconsistentAsFruitTypeCopyWithImpl(
      _$ComposedDiscRequiredInconsistentAsFruitType _value,
      $Res Function(_$ComposedDiscRequiredInconsistentAsFruitType) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitTypeValue = null,
  }) {
    return _then(_$ComposedDiscRequiredInconsistentAsFruitType(
      fruitTypeValue: null == fruitTypeValue
          ? _value.fruitTypeValue
          : fruitTypeValue // ignore: cast_nullable_to_non_nullable
              as FruitType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitTypeCopyWith<$Res> get fruitTypeValue {
    return $FruitTypeCopyWith<$Res>(_value.fruitTypeValue, (value) {
      return _then(_value.copyWith(fruitTypeValue: value));
    });
  }
}

/// @nodoc

class _$ComposedDiscRequiredInconsistentAsFruitType
    extends ComposedDiscRequiredInconsistentAsFruitType {
  const _$ComposedDiscRequiredInconsistentAsFruitType(
      {required this.fruitTypeValue})
      : super._();

  @override
  final FruitType fruitTypeValue;

  @override
  String toString() {
    return 'ComposedDiscRequiredInconsistent.asFruitType(fruitTypeValue: $fruitTypeValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscRequiredInconsistentAsFruitType &&
            (identical(other.fruitTypeValue, fruitTypeValue) ||
                other.fruitTypeValue == fruitTypeValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fruitTypeValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscRequiredInconsistentAsFruitTypeCopyWith<
          _$ComposedDiscRequiredInconsistentAsFruitType>
      get copyWith =>
          __$$ComposedDiscRequiredInconsistentAsFruitTypeCopyWithImpl<
              _$ComposedDiscRequiredInconsistentAsFruitType>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeCorrect discOptionalTypeCorrectValue)
        asDiscOptionalTypeCorrect,
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscRequiredInconsistent> deserializedModels)
        unknown,
  }) {
    return asFruitType(fruitTypeValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscRequiredInconsistent> deserializedModels)?
        unknown,
  }) {
    return asFruitType?.call(fruitTypeValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscRequiredInconsistent> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFruitType != null) {
      return asFruitType(fruitTypeValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value)
        asDiscOptionalTypeCorrect,
    required TResult Function(ComposedDiscRequiredInconsistentAsFruitType value)
        asFruitType,
    required TResult Function(ComposedDiscRequiredInconsistentUnknown value)
        unknown,
  }) {
    return asFruitType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult? Function(ComposedDiscRequiredInconsistentAsFruitType value)?
        asFruitType,
    TResult? Function(ComposedDiscRequiredInconsistentUnknown value)? unknown,
  }) {
    return asFruitType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult Function(ComposedDiscRequiredInconsistentAsFruitType value)?
        asFruitType,
    TResult Function(ComposedDiscRequiredInconsistentUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFruitType != null) {
      return asFruitType(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscRequiredInconsistentAsFruitType
    extends ComposedDiscRequiredInconsistent {
  const factory ComposedDiscRequiredInconsistentAsFruitType(
          {required final FruitType fruitTypeValue}) =
      _$ComposedDiscRequiredInconsistentAsFruitType;
  const ComposedDiscRequiredInconsistentAsFruitType._() : super._();

  FruitType get fruitTypeValue;
  @JsonKey(ignore: true)
  _$$ComposedDiscRequiredInconsistentAsFruitTypeCopyWith<
          _$ComposedDiscRequiredInconsistentAsFruitType>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposedDiscRequiredInconsistentUnknownCopyWith<$Res> {
  factory _$$ComposedDiscRequiredInconsistentUnknownCopyWith(
          _$ComposedDiscRequiredInconsistentUnknown value,
          $Res Function(_$ComposedDiscRequiredInconsistentUnknown) then) =
      __$$ComposedDiscRequiredInconsistentUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<ComposedDiscRequiredInconsistent> deserializedModels});
}

/// @nodoc
class __$$ComposedDiscRequiredInconsistentUnknownCopyWithImpl<$Res>
    extends _$ComposedDiscRequiredInconsistentCopyWithImpl<$Res,
        _$ComposedDiscRequiredInconsistentUnknown>
    implements _$$ComposedDiscRequiredInconsistentUnknownCopyWith<$Res> {
  __$$ComposedDiscRequiredInconsistentUnknownCopyWithImpl(
      _$ComposedDiscRequiredInconsistentUnknown _value,
      $Res Function(_$ComposedDiscRequiredInconsistentUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$ComposedDiscRequiredInconsistentUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<ComposedDiscRequiredInconsistent>,
    ));
  }
}

/// @nodoc

class _$ComposedDiscRequiredInconsistentUnknown
    extends ComposedDiscRequiredInconsistentUnknown {
  const _$ComposedDiscRequiredInconsistentUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        DiscOptionalTypeCorrect,
        FruitType
      ],
      final List<ComposedDiscRequiredInconsistent> deserializedModels =
          const <ComposedDiscRequiredInconsistent>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<ComposedDiscRequiredInconsistent> _deserializedModels;
  @override
  @JsonKey()
  List<ComposedDiscRequiredInconsistent> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'ComposedDiscRequiredInconsistent.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscRequiredInconsistentUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscRequiredInconsistentUnknownCopyWith<
          _$ComposedDiscRequiredInconsistentUnknown>
      get copyWith => __$$ComposedDiscRequiredInconsistentUnknownCopyWithImpl<
          _$ComposedDiscRequiredInconsistentUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            DiscOptionalTypeCorrect discOptionalTypeCorrectValue)
        asDiscOptionalTypeCorrect,
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscRequiredInconsistent> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscRequiredInconsistent> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscOptionalTypeCorrect discOptionalTypeCorrectValue)?
        asDiscOptionalTypeCorrect,
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscRequiredInconsistent> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value)
        asDiscOptionalTypeCorrect,
    required TResult Function(ComposedDiscRequiredInconsistentAsFruitType value)
        asFruitType,
    required TResult Function(ComposedDiscRequiredInconsistentUnknown value)
        unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult? Function(ComposedDiscRequiredInconsistentAsFruitType value)?
        asFruitType,
    TResult? Function(ComposedDiscRequiredInconsistentUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            ComposedDiscRequiredInconsistentAsDiscOptionalTypeCorrect value)?
        asDiscOptionalTypeCorrect,
    TResult Function(ComposedDiscRequiredInconsistentAsFruitType value)?
        asFruitType,
    TResult Function(ComposedDiscRequiredInconsistentUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscRequiredInconsistentUnknown
    extends ComposedDiscRequiredInconsistent {
  const factory ComposedDiscRequiredInconsistentUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<ComposedDiscRequiredInconsistent> deserializedModels}) =
      _$ComposedDiscRequiredInconsistentUnknown;
  const ComposedDiscRequiredInconsistentUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<ComposedDiscRequiredInconsistent> get deserializedModels;
  @JsonKey(ignore: true)
  _$$ComposedDiscRequiredInconsistentUnknownCopyWith<
          _$ComposedDiscRequiredInconsistentUnknown>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ComposedDiscTypeInconsistent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DiscTypeIncorrect discTypeIncorrectValue)
        asDiscTypeIncorrect,
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeInconsistent> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeInconsistent> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeInconsistent> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscTypeInconsistentAsDiscTypeIncorrect value)
        asDiscTypeIncorrect,
    required TResult Function(ComposedDiscTypeInconsistentAsFruitType value)
        asFruitType,
    required TResult Function(ComposedDiscTypeInconsistentUnknown value)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ComposedDiscTypeInconsistentAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult? Function(ComposedDiscTypeInconsistentAsFruitType value)?
        asFruitType,
    TResult? Function(ComposedDiscTypeInconsistentUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ComposedDiscTypeInconsistentAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult Function(ComposedDiscTypeInconsistentAsFruitType value)?
        asFruitType,
    TResult Function(ComposedDiscTypeInconsistentUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComposedDiscTypeInconsistentCopyWith<$Res> {
  factory $ComposedDiscTypeInconsistentCopyWith(
          ComposedDiscTypeInconsistent value,
          $Res Function(ComposedDiscTypeInconsistent) then) =
      _$ComposedDiscTypeInconsistentCopyWithImpl<$Res,
          ComposedDiscTypeInconsistent>;
}

/// @nodoc
class _$ComposedDiscTypeInconsistentCopyWithImpl<$Res,
        $Val extends ComposedDiscTypeInconsistent>
    implements $ComposedDiscTypeInconsistentCopyWith<$Res> {
  _$ComposedDiscTypeInconsistentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ComposedDiscTypeInconsistentAsDiscTypeIncorrectCopyWith<
    $Res> {
  factory _$$ComposedDiscTypeInconsistentAsDiscTypeIncorrectCopyWith(
          _$ComposedDiscTypeInconsistentAsDiscTypeIncorrect value,
          $Res Function(_$ComposedDiscTypeInconsistentAsDiscTypeIncorrect)
              then) =
      __$$ComposedDiscTypeInconsistentAsDiscTypeIncorrectCopyWithImpl<$Res>;
  @useResult
  $Res call({DiscTypeIncorrect discTypeIncorrectValue});

  $DiscTypeIncorrectCopyWith<$Res> get discTypeIncorrectValue;
}

/// @nodoc
class __$$ComposedDiscTypeInconsistentAsDiscTypeIncorrectCopyWithImpl<$Res>
    extends _$ComposedDiscTypeInconsistentCopyWithImpl<$Res,
        _$ComposedDiscTypeInconsistentAsDiscTypeIncorrect>
    implements
        _$$ComposedDiscTypeInconsistentAsDiscTypeIncorrectCopyWith<$Res> {
  __$$ComposedDiscTypeInconsistentAsDiscTypeIncorrectCopyWithImpl(
      _$ComposedDiscTypeInconsistentAsDiscTypeIncorrect _value,
      $Res Function(_$ComposedDiscTypeInconsistentAsDiscTypeIncorrect) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? discTypeIncorrectValue = null,
  }) {
    return _then(_$ComposedDiscTypeInconsistentAsDiscTypeIncorrect(
      discTypeIncorrectValue: null == discTypeIncorrectValue
          ? _value.discTypeIncorrectValue
          : discTypeIncorrectValue // ignore: cast_nullable_to_non_nullable
              as DiscTypeIncorrect,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DiscTypeIncorrectCopyWith<$Res> get discTypeIncorrectValue {
    return $DiscTypeIncorrectCopyWith<$Res>(_value.discTypeIncorrectValue,
        (value) {
      return _then(_value.copyWith(discTypeIncorrectValue: value));
    });
  }
}

/// @nodoc

class _$ComposedDiscTypeInconsistentAsDiscTypeIncorrect
    extends ComposedDiscTypeInconsistentAsDiscTypeIncorrect {
  const _$ComposedDiscTypeInconsistentAsDiscTypeIncorrect(
      {required this.discTypeIncorrectValue})
      : super._();

  @override
  final DiscTypeIncorrect discTypeIncorrectValue;

  @override
  String toString() {
    return 'ComposedDiscTypeInconsistent.asDiscTypeIncorrect(discTypeIncorrectValue: $discTypeIncorrectValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscTypeInconsistentAsDiscTypeIncorrect &&
            (identical(other.discTypeIncorrectValue, discTypeIncorrectValue) ||
                other.discTypeIncorrectValue == discTypeIncorrectValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, discTypeIncorrectValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscTypeInconsistentAsDiscTypeIncorrectCopyWith<
          _$ComposedDiscTypeInconsistentAsDiscTypeIncorrect>
      get copyWith =>
          __$$ComposedDiscTypeInconsistentAsDiscTypeIncorrectCopyWithImpl<
                  _$ComposedDiscTypeInconsistentAsDiscTypeIncorrect>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DiscTypeIncorrect discTypeIncorrectValue)
        asDiscTypeIncorrect,
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeInconsistent> deserializedModels)
        unknown,
  }) {
    return asDiscTypeIncorrect(discTypeIncorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeInconsistent> deserializedModels)?
        unknown,
  }) {
    return asDiscTypeIncorrect?.call(discTypeIncorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeInconsistent> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asDiscTypeIncorrect != null) {
      return asDiscTypeIncorrect(discTypeIncorrectValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscTypeInconsistentAsDiscTypeIncorrect value)
        asDiscTypeIncorrect,
    required TResult Function(ComposedDiscTypeInconsistentAsFruitType value)
        asFruitType,
    required TResult Function(ComposedDiscTypeInconsistentUnknown value)
        unknown,
  }) {
    return asDiscTypeIncorrect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ComposedDiscTypeInconsistentAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult? Function(ComposedDiscTypeInconsistentAsFruitType value)?
        asFruitType,
    TResult? Function(ComposedDiscTypeInconsistentUnknown value)? unknown,
  }) {
    return asDiscTypeIncorrect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ComposedDiscTypeInconsistentAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult Function(ComposedDiscTypeInconsistentAsFruitType value)?
        asFruitType,
    TResult Function(ComposedDiscTypeInconsistentUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asDiscTypeIncorrect != null) {
      return asDiscTypeIncorrect(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscTypeInconsistentAsDiscTypeIncorrect
    extends ComposedDiscTypeInconsistent {
  const factory ComposedDiscTypeInconsistentAsDiscTypeIncorrect(
          {required final DiscTypeIncorrect discTypeIncorrectValue}) =
      _$ComposedDiscTypeInconsistentAsDiscTypeIncorrect;
  const ComposedDiscTypeInconsistentAsDiscTypeIncorrect._() : super._();

  DiscTypeIncorrect get discTypeIncorrectValue;
  @JsonKey(ignore: true)
  _$$ComposedDiscTypeInconsistentAsDiscTypeIncorrectCopyWith<
          _$ComposedDiscTypeInconsistentAsDiscTypeIncorrect>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposedDiscTypeInconsistentAsFruitTypeCopyWith<$Res> {
  factory _$$ComposedDiscTypeInconsistentAsFruitTypeCopyWith(
          _$ComposedDiscTypeInconsistentAsFruitType value,
          $Res Function(_$ComposedDiscTypeInconsistentAsFruitType) then) =
      __$$ComposedDiscTypeInconsistentAsFruitTypeCopyWithImpl<$Res>;
  @useResult
  $Res call({FruitType fruitTypeValue});

  $FruitTypeCopyWith<$Res> get fruitTypeValue;
}

/// @nodoc
class __$$ComposedDiscTypeInconsistentAsFruitTypeCopyWithImpl<$Res>
    extends _$ComposedDiscTypeInconsistentCopyWithImpl<$Res,
        _$ComposedDiscTypeInconsistentAsFruitType>
    implements _$$ComposedDiscTypeInconsistentAsFruitTypeCopyWith<$Res> {
  __$$ComposedDiscTypeInconsistentAsFruitTypeCopyWithImpl(
      _$ComposedDiscTypeInconsistentAsFruitType _value,
      $Res Function(_$ComposedDiscTypeInconsistentAsFruitType) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitTypeValue = null,
  }) {
    return _then(_$ComposedDiscTypeInconsistentAsFruitType(
      fruitTypeValue: null == fruitTypeValue
          ? _value.fruitTypeValue
          : fruitTypeValue // ignore: cast_nullable_to_non_nullable
              as FruitType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitTypeCopyWith<$Res> get fruitTypeValue {
    return $FruitTypeCopyWith<$Res>(_value.fruitTypeValue, (value) {
      return _then(_value.copyWith(fruitTypeValue: value));
    });
  }
}

/// @nodoc

class _$ComposedDiscTypeInconsistentAsFruitType
    extends ComposedDiscTypeInconsistentAsFruitType {
  const _$ComposedDiscTypeInconsistentAsFruitType(
      {required this.fruitTypeValue})
      : super._();

  @override
  final FruitType fruitTypeValue;

  @override
  String toString() {
    return 'ComposedDiscTypeInconsistent.asFruitType(fruitTypeValue: $fruitTypeValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscTypeInconsistentAsFruitType &&
            (identical(other.fruitTypeValue, fruitTypeValue) ||
                other.fruitTypeValue == fruitTypeValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fruitTypeValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscTypeInconsistentAsFruitTypeCopyWith<
          _$ComposedDiscTypeInconsistentAsFruitType>
      get copyWith => __$$ComposedDiscTypeInconsistentAsFruitTypeCopyWithImpl<
          _$ComposedDiscTypeInconsistentAsFruitType>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DiscTypeIncorrect discTypeIncorrectValue)
        asDiscTypeIncorrect,
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeInconsistent> deserializedModels)
        unknown,
  }) {
    return asFruitType(fruitTypeValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeInconsistent> deserializedModels)?
        unknown,
  }) {
    return asFruitType?.call(fruitTypeValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeInconsistent> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFruitType != null) {
      return asFruitType(fruitTypeValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscTypeInconsistentAsDiscTypeIncorrect value)
        asDiscTypeIncorrect,
    required TResult Function(ComposedDiscTypeInconsistentAsFruitType value)
        asFruitType,
    required TResult Function(ComposedDiscTypeInconsistentUnknown value)
        unknown,
  }) {
    return asFruitType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ComposedDiscTypeInconsistentAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult? Function(ComposedDiscTypeInconsistentAsFruitType value)?
        asFruitType,
    TResult? Function(ComposedDiscTypeInconsistentUnknown value)? unknown,
  }) {
    return asFruitType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ComposedDiscTypeInconsistentAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult Function(ComposedDiscTypeInconsistentAsFruitType value)?
        asFruitType,
    TResult Function(ComposedDiscTypeInconsistentUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFruitType != null) {
      return asFruitType(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscTypeInconsistentAsFruitType
    extends ComposedDiscTypeInconsistent {
  const factory ComposedDiscTypeInconsistentAsFruitType(
          {required final FruitType fruitTypeValue}) =
      _$ComposedDiscTypeInconsistentAsFruitType;
  const ComposedDiscTypeInconsistentAsFruitType._() : super._();

  FruitType get fruitTypeValue;
  @JsonKey(ignore: true)
  _$$ComposedDiscTypeInconsistentAsFruitTypeCopyWith<
          _$ComposedDiscTypeInconsistentAsFruitType>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposedDiscTypeInconsistentUnknownCopyWith<$Res> {
  factory _$$ComposedDiscTypeInconsistentUnknownCopyWith(
          _$ComposedDiscTypeInconsistentUnknown value,
          $Res Function(_$ComposedDiscTypeInconsistentUnknown) then) =
      __$$ComposedDiscTypeInconsistentUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<ComposedDiscTypeInconsistent> deserializedModels});
}

/// @nodoc
class __$$ComposedDiscTypeInconsistentUnknownCopyWithImpl<$Res>
    extends _$ComposedDiscTypeInconsistentCopyWithImpl<$Res,
        _$ComposedDiscTypeInconsistentUnknown>
    implements _$$ComposedDiscTypeInconsistentUnknownCopyWith<$Res> {
  __$$ComposedDiscTypeInconsistentUnknownCopyWithImpl(
      _$ComposedDiscTypeInconsistentUnknown _value,
      $Res Function(_$ComposedDiscTypeInconsistentUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$ComposedDiscTypeInconsistentUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<ComposedDiscTypeInconsistent>,
    ));
  }
}

/// @nodoc

class _$ComposedDiscTypeInconsistentUnknown
    extends ComposedDiscTypeInconsistentUnknown {
  const _$ComposedDiscTypeInconsistentUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        DiscTypeIncorrect,
        FruitType
      ],
      final List<ComposedDiscTypeInconsistent> deserializedModels =
          const <ComposedDiscTypeInconsistent>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<ComposedDiscTypeInconsistent> _deserializedModels;
  @override
  @JsonKey()
  List<ComposedDiscTypeInconsistent> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'ComposedDiscTypeInconsistent.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscTypeInconsistentUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscTypeInconsistentUnknownCopyWith<
          _$ComposedDiscTypeInconsistentUnknown>
      get copyWith => __$$ComposedDiscTypeInconsistentUnknownCopyWithImpl<
          _$ComposedDiscTypeInconsistentUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DiscTypeIncorrect discTypeIncorrectValue)
        asDiscTypeIncorrect,
    required TResult Function(FruitType fruitTypeValue) asFruitType,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeInconsistent> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult? Function(FruitType fruitTypeValue)? asFruitType,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeInconsistent> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult Function(FruitType fruitTypeValue)? asFruitType,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeInconsistent> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscTypeInconsistentAsDiscTypeIncorrect value)
        asDiscTypeIncorrect,
    required TResult Function(ComposedDiscTypeInconsistentAsFruitType value)
        asFruitType,
    required TResult Function(ComposedDiscTypeInconsistentUnknown value)
        unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ComposedDiscTypeInconsistentAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult? Function(ComposedDiscTypeInconsistentAsFruitType value)?
        asFruitType,
    TResult? Function(ComposedDiscTypeInconsistentUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ComposedDiscTypeInconsistentAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult Function(ComposedDiscTypeInconsistentAsFruitType value)?
        asFruitType,
    TResult Function(ComposedDiscTypeInconsistentUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscTypeInconsistentUnknown
    extends ComposedDiscTypeInconsistent {
  const factory ComposedDiscTypeInconsistentUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<ComposedDiscTypeInconsistent> deserializedModels}) =
      _$ComposedDiscTypeInconsistentUnknown;
  const ComposedDiscTypeInconsistentUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<ComposedDiscTypeInconsistent> get deserializedModels;
  @JsonKey(ignore: true)
  _$$ComposedDiscTypeInconsistentUnknownCopyWith<
          _$ComposedDiscTypeInconsistentUnknown>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ComposedDiscTypeIncorrect {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DiscTypeIncorrect discTypeIncorrectValue)
        asDiscTypeIncorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeIncorrect> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeIncorrect> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeIncorrect> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscTypeIncorrectAsDiscTypeIncorrect value)
        asDiscTypeIncorrect,
    required TResult Function(ComposedDiscTypeIncorrectUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ComposedDiscTypeIncorrectAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult? Function(ComposedDiscTypeIncorrectUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ComposedDiscTypeIncorrectAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult Function(ComposedDiscTypeIncorrectUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComposedDiscTypeIncorrectCopyWith<$Res> {
  factory $ComposedDiscTypeIncorrectCopyWith(ComposedDiscTypeIncorrect value,
          $Res Function(ComposedDiscTypeIncorrect) then) =
      _$ComposedDiscTypeIncorrectCopyWithImpl<$Res, ComposedDiscTypeIncorrect>;
}

/// @nodoc
class _$ComposedDiscTypeIncorrectCopyWithImpl<$Res,
        $Val extends ComposedDiscTypeIncorrect>
    implements $ComposedDiscTypeIncorrectCopyWith<$Res> {
  _$ComposedDiscTypeIncorrectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ComposedDiscTypeIncorrectAsDiscTypeIncorrectCopyWith<$Res> {
  factory _$$ComposedDiscTypeIncorrectAsDiscTypeIncorrectCopyWith(
          _$ComposedDiscTypeIncorrectAsDiscTypeIncorrect value,
          $Res Function(_$ComposedDiscTypeIncorrectAsDiscTypeIncorrect) then) =
      __$$ComposedDiscTypeIncorrectAsDiscTypeIncorrectCopyWithImpl<$Res>;
  @useResult
  $Res call({DiscTypeIncorrect discTypeIncorrectValue});

  $DiscTypeIncorrectCopyWith<$Res> get discTypeIncorrectValue;
}

/// @nodoc
class __$$ComposedDiscTypeIncorrectAsDiscTypeIncorrectCopyWithImpl<$Res>
    extends _$ComposedDiscTypeIncorrectCopyWithImpl<$Res,
        _$ComposedDiscTypeIncorrectAsDiscTypeIncorrect>
    implements _$$ComposedDiscTypeIncorrectAsDiscTypeIncorrectCopyWith<$Res> {
  __$$ComposedDiscTypeIncorrectAsDiscTypeIncorrectCopyWithImpl(
      _$ComposedDiscTypeIncorrectAsDiscTypeIncorrect _value,
      $Res Function(_$ComposedDiscTypeIncorrectAsDiscTypeIncorrect) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? discTypeIncorrectValue = null,
  }) {
    return _then(_$ComposedDiscTypeIncorrectAsDiscTypeIncorrect(
      discTypeIncorrectValue: null == discTypeIncorrectValue
          ? _value.discTypeIncorrectValue
          : discTypeIncorrectValue // ignore: cast_nullable_to_non_nullable
              as DiscTypeIncorrect,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DiscTypeIncorrectCopyWith<$Res> get discTypeIncorrectValue {
    return $DiscTypeIncorrectCopyWith<$Res>(_value.discTypeIncorrectValue,
        (value) {
      return _then(_value.copyWith(discTypeIncorrectValue: value));
    });
  }
}

/// @nodoc

class _$ComposedDiscTypeIncorrectAsDiscTypeIncorrect
    extends ComposedDiscTypeIncorrectAsDiscTypeIncorrect {
  const _$ComposedDiscTypeIncorrectAsDiscTypeIncorrect(
      {required this.discTypeIncorrectValue})
      : super._();

  @override
  final DiscTypeIncorrect discTypeIncorrectValue;

  @override
  String toString() {
    return 'ComposedDiscTypeIncorrect.asDiscTypeIncorrect(discTypeIncorrectValue: $discTypeIncorrectValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscTypeIncorrectAsDiscTypeIncorrect &&
            (identical(other.discTypeIncorrectValue, discTypeIncorrectValue) ||
                other.discTypeIncorrectValue == discTypeIncorrectValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, discTypeIncorrectValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscTypeIncorrectAsDiscTypeIncorrectCopyWith<
          _$ComposedDiscTypeIncorrectAsDiscTypeIncorrect>
      get copyWith =>
          __$$ComposedDiscTypeIncorrectAsDiscTypeIncorrectCopyWithImpl<
              _$ComposedDiscTypeIncorrectAsDiscTypeIncorrect>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DiscTypeIncorrect discTypeIncorrectValue)
        asDiscTypeIncorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeIncorrect> deserializedModels)
        unknown,
  }) {
    return asDiscTypeIncorrect(discTypeIncorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeIncorrect> deserializedModels)?
        unknown,
  }) {
    return asDiscTypeIncorrect?.call(discTypeIncorrectValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeIncorrect> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asDiscTypeIncorrect != null) {
      return asDiscTypeIncorrect(discTypeIncorrectValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscTypeIncorrectAsDiscTypeIncorrect value)
        asDiscTypeIncorrect,
    required TResult Function(ComposedDiscTypeIncorrectUnknown value) unknown,
  }) {
    return asDiscTypeIncorrect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ComposedDiscTypeIncorrectAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult? Function(ComposedDiscTypeIncorrectUnknown value)? unknown,
  }) {
    return asDiscTypeIncorrect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ComposedDiscTypeIncorrectAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult Function(ComposedDiscTypeIncorrectUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asDiscTypeIncorrect != null) {
      return asDiscTypeIncorrect(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscTypeIncorrectAsDiscTypeIncorrect
    extends ComposedDiscTypeIncorrect {
  const factory ComposedDiscTypeIncorrectAsDiscTypeIncorrect(
          {required final DiscTypeIncorrect discTypeIncorrectValue}) =
      _$ComposedDiscTypeIncorrectAsDiscTypeIncorrect;
  const ComposedDiscTypeIncorrectAsDiscTypeIncorrect._() : super._();

  DiscTypeIncorrect get discTypeIncorrectValue;
  @JsonKey(ignore: true)
  _$$ComposedDiscTypeIncorrectAsDiscTypeIncorrectCopyWith<
          _$ComposedDiscTypeIncorrectAsDiscTypeIncorrect>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ComposedDiscTypeIncorrectUnknownCopyWith<$Res> {
  factory _$$ComposedDiscTypeIncorrectUnknownCopyWith(
          _$ComposedDiscTypeIncorrectUnknown value,
          $Res Function(_$ComposedDiscTypeIncorrectUnknown) then) =
      __$$ComposedDiscTypeIncorrectUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<ComposedDiscTypeIncorrect> deserializedModels});
}

/// @nodoc
class __$$ComposedDiscTypeIncorrectUnknownCopyWithImpl<$Res>
    extends _$ComposedDiscTypeIncorrectCopyWithImpl<$Res,
        _$ComposedDiscTypeIncorrectUnknown>
    implements _$$ComposedDiscTypeIncorrectUnknownCopyWith<$Res> {
  __$$ComposedDiscTypeIncorrectUnknownCopyWithImpl(
      _$ComposedDiscTypeIncorrectUnknown _value,
      $Res Function(_$ComposedDiscTypeIncorrectUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$ComposedDiscTypeIncorrectUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<ComposedDiscTypeIncorrect>,
    ));
  }
}

/// @nodoc

class _$ComposedDiscTypeIncorrectUnknown
    extends ComposedDiscTypeIncorrectUnknown {
  const _$ComposedDiscTypeIncorrectUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[DiscTypeIncorrect],
      final List<ComposedDiscTypeIncorrect> deserializedModels =
          const <ComposedDiscTypeIncorrect>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<ComposedDiscTypeIncorrect> _deserializedModels;
  @override
  @JsonKey()
  List<ComposedDiscTypeIncorrect> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'ComposedDiscTypeIncorrect.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ComposedDiscTypeIncorrectUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ComposedDiscTypeIncorrectUnknownCopyWith<
          _$ComposedDiscTypeIncorrectUnknown>
      get copyWith => __$$ComposedDiscTypeIncorrectUnknownCopyWithImpl<
          _$ComposedDiscTypeIncorrectUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DiscTypeIncorrect discTypeIncorrectValue)
        asDiscTypeIncorrect,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeIncorrect> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeIncorrect> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DiscTypeIncorrect discTypeIncorrectValue)?
        asDiscTypeIncorrect,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<ComposedDiscTypeIncorrect> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ComposedDiscTypeIncorrectAsDiscTypeIncorrect value)
        asDiscTypeIncorrect,
    required TResult Function(ComposedDiscTypeIncorrectUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ComposedDiscTypeIncorrectAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult? Function(ComposedDiscTypeIncorrectUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ComposedDiscTypeIncorrectAsDiscTypeIncorrect value)?
        asDiscTypeIncorrect,
    TResult Function(ComposedDiscTypeIncorrectUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class ComposedDiscTypeIncorrectUnknown
    extends ComposedDiscTypeIncorrect {
  const factory ComposedDiscTypeIncorrectUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<ComposedDiscTypeIncorrect> deserializedModels}) =
      _$ComposedDiscTypeIncorrectUnknown;
  const ComposedDiscTypeIncorrectUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<ComposedDiscTypeIncorrect> get deserializedModels;
  @JsonKey(ignore: true)
  _$$ComposedDiscTypeIncorrectUnknownCopyWith<
          _$ComposedDiscTypeIncorrectUnknown>
      get copyWith => throw _privateConstructorUsedError;
}

DiscMissingFromProperties _$DiscMissingFromPropertiesFromJson(
    Map<String, dynamic> json) {
  return _DiscMissingFromProperties.fromJson(json);
}

/// @nodoc
mixin _$DiscMissingFromProperties {
  @JsonKey(name: r'length')
  int? get length => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DiscMissingFromPropertiesCopyWith<DiscMissingFromProperties> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DiscMissingFromPropertiesCopyWith<$Res> {
  factory $DiscMissingFromPropertiesCopyWith(DiscMissingFromProperties value,
          $Res Function(DiscMissingFromProperties) then) =
      _$DiscMissingFromPropertiesCopyWithImpl<$Res, DiscMissingFromProperties>;
  @useResult
  $Res call({@JsonKey(name: r'length') int? length});
}

/// @nodoc
class _$DiscMissingFromPropertiesCopyWithImpl<$Res,
        $Val extends DiscMissingFromProperties>
    implements $DiscMissingFromPropertiesCopyWith<$Res> {
  _$DiscMissingFromPropertiesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = freezed,
  }) {
    return _then(_value.copyWith(
      length: freezed == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DiscMissingFromPropertiesCopyWith<$Res>
    implements $DiscMissingFromPropertiesCopyWith<$Res> {
  factory _$$_DiscMissingFromPropertiesCopyWith(
          _$_DiscMissingFromProperties value,
          $Res Function(_$_DiscMissingFromProperties) then) =
      __$$_DiscMissingFromPropertiesCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: r'length') int? length});
}

/// @nodoc
class __$$_DiscMissingFromPropertiesCopyWithImpl<$Res>
    extends _$DiscMissingFromPropertiesCopyWithImpl<$Res,
        _$_DiscMissingFromProperties>
    implements _$$_DiscMissingFromPropertiesCopyWith<$Res> {
  __$$_DiscMissingFromPropertiesCopyWithImpl(
      _$_DiscMissingFromProperties _value,
      $Res Function(_$_DiscMissingFromProperties) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = freezed,
  }) {
    return _then(_$_DiscMissingFromProperties(
      length: freezed == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DiscMissingFromProperties extends _DiscMissingFromProperties {
  const _$_DiscMissingFromProperties({@JsonKey(name: r'length') this.length})
      : super._();

  factory _$_DiscMissingFromProperties.fromJson(Map<String, dynamic> json) =>
      _$$_DiscMissingFromPropertiesFromJson(json);

  @override
  @JsonKey(name: r'length')
  final int? length;

  @override
  String toString() {
    return 'DiscMissingFromProperties(length: $length)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DiscMissingFromProperties &&
            (identical(other.length, length) || other.length == length));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, length);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DiscMissingFromPropertiesCopyWith<_$_DiscMissingFromProperties>
      get copyWith => __$$_DiscMissingFromPropertiesCopyWithImpl<
          _$_DiscMissingFromProperties>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DiscMissingFromPropertiesToJson(
      this,
    );
  }
}

abstract class _DiscMissingFromProperties extends DiscMissingFromProperties {
  const factory _DiscMissingFromProperties(
          {@JsonKey(name: r'length') final int? length}) =
      _$_DiscMissingFromProperties;
  const _DiscMissingFromProperties._() : super._();

  factory _DiscMissingFromProperties.fromJson(Map<String, dynamic> json) =
      _$_DiscMissingFromProperties.fromJson;

  @override
  @JsonKey(name: r'length')
  int? get length;
  @override
  @JsonKey(ignore: true)
  _$$_DiscMissingFromPropertiesCopyWith<_$_DiscMissingFromProperties>
      get copyWith => throw _privateConstructorUsedError;
}

DiscOptionalTypeCorrect _$DiscOptionalTypeCorrectFromJson(
    Map<String, dynamic> json) {
  return _DiscOptionalTypeCorrect.fromJson(json);
}

/// @nodoc
mixin _$DiscOptionalTypeCorrect {
  @JsonKey(name: r'fruitType')
  String? get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DiscOptionalTypeCorrectCopyWith<DiscOptionalTypeCorrect> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DiscOptionalTypeCorrectCopyWith<$Res> {
  factory $DiscOptionalTypeCorrectCopyWith(DiscOptionalTypeCorrect value,
          $Res Function(DiscOptionalTypeCorrect) then) =
      _$DiscOptionalTypeCorrectCopyWithImpl<$Res, DiscOptionalTypeCorrect>;
  @useResult
  $Res call({@JsonKey(name: r'fruitType') String? fruitType});
}

/// @nodoc
class _$DiscOptionalTypeCorrectCopyWithImpl<$Res,
        $Val extends DiscOptionalTypeCorrect>
    implements $DiscOptionalTypeCorrectCopyWith<$Res> {
  _$DiscOptionalTypeCorrectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitType = freezed,
  }) {
    return _then(_value.copyWith(
      fruitType: freezed == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DiscOptionalTypeCorrectCopyWith<$Res>
    implements $DiscOptionalTypeCorrectCopyWith<$Res> {
  factory _$$_DiscOptionalTypeCorrectCopyWith(_$_DiscOptionalTypeCorrect value,
          $Res Function(_$_DiscOptionalTypeCorrect) then) =
      __$$_DiscOptionalTypeCorrectCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: r'fruitType') String? fruitType});
}

/// @nodoc
class __$$_DiscOptionalTypeCorrectCopyWithImpl<$Res>
    extends _$DiscOptionalTypeCorrectCopyWithImpl<$Res,
        _$_DiscOptionalTypeCorrect>
    implements _$$_DiscOptionalTypeCorrectCopyWith<$Res> {
  __$$_DiscOptionalTypeCorrectCopyWithImpl(_$_DiscOptionalTypeCorrect _value,
      $Res Function(_$_DiscOptionalTypeCorrect) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitType = freezed,
  }) {
    return _then(_$_DiscOptionalTypeCorrect(
      fruitType: freezed == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DiscOptionalTypeCorrect extends _DiscOptionalTypeCorrect {
  const _$_DiscOptionalTypeCorrect(
      {@JsonKey(name: r'fruitType') this.fruitType})
      : super._();

  factory _$_DiscOptionalTypeCorrect.fromJson(Map<String, dynamic> json) =>
      _$$_DiscOptionalTypeCorrectFromJson(json);

  @override
  @JsonKey(name: r'fruitType')
  final String? fruitType;

  @override
  String toString() {
    return 'DiscOptionalTypeCorrect(fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DiscOptionalTypeCorrect &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DiscOptionalTypeCorrectCopyWith<_$_DiscOptionalTypeCorrect>
      get copyWith =>
          __$$_DiscOptionalTypeCorrectCopyWithImpl<_$_DiscOptionalTypeCorrect>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DiscOptionalTypeCorrectToJson(
      this,
    );
  }
}

abstract class _DiscOptionalTypeCorrect extends DiscOptionalTypeCorrect {
  const factory _DiscOptionalTypeCorrect(
          {@JsonKey(name: r'fruitType') final String? fruitType}) =
      _$_DiscOptionalTypeCorrect;
  const _DiscOptionalTypeCorrect._() : super._();

  factory _DiscOptionalTypeCorrect.fromJson(Map<String, dynamic> json) =
      _$_DiscOptionalTypeCorrect.fromJson;

  @override
  @JsonKey(name: r'fruitType')
  String? get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_DiscOptionalTypeCorrectCopyWith<_$_DiscOptionalTypeCorrect>
      get copyWith => throw _privateConstructorUsedError;
}

DiscOptionalTypeIncorrect _$DiscOptionalTypeIncorrectFromJson(
    Map<String, dynamic> json) {
  return _DiscOptionalTypeIncorrect.fromJson(json);
}

/// @nodoc
mixin _$DiscOptionalTypeIncorrect {
  @JsonKey(name: r'fruitType')
  int? get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DiscOptionalTypeIncorrectCopyWith<DiscOptionalTypeIncorrect> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DiscOptionalTypeIncorrectCopyWith<$Res> {
  factory $DiscOptionalTypeIncorrectCopyWith(DiscOptionalTypeIncorrect value,
          $Res Function(DiscOptionalTypeIncorrect) then) =
      _$DiscOptionalTypeIncorrectCopyWithImpl<$Res, DiscOptionalTypeIncorrect>;
  @useResult
  $Res call({@JsonKey(name: r'fruitType') int? fruitType});
}

/// @nodoc
class _$DiscOptionalTypeIncorrectCopyWithImpl<$Res,
        $Val extends DiscOptionalTypeIncorrect>
    implements $DiscOptionalTypeIncorrectCopyWith<$Res> {
  _$DiscOptionalTypeIncorrectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitType = freezed,
  }) {
    return _then(_value.copyWith(
      fruitType: freezed == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DiscOptionalTypeIncorrectCopyWith<$Res>
    implements $DiscOptionalTypeIncorrectCopyWith<$Res> {
  factory _$$_DiscOptionalTypeIncorrectCopyWith(
          _$_DiscOptionalTypeIncorrect value,
          $Res Function(_$_DiscOptionalTypeIncorrect) then) =
      __$$_DiscOptionalTypeIncorrectCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: r'fruitType') int? fruitType});
}

/// @nodoc
class __$$_DiscOptionalTypeIncorrectCopyWithImpl<$Res>
    extends _$DiscOptionalTypeIncorrectCopyWithImpl<$Res,
        _$_DiscOptionalTypeIncorrect>
    implements _$$_DiscOptionalTypeIncorrectCopyWith<$Res> {
  __$$_DiscOptionalTypeIncorrectCopyWithImpl(
      _$_DiscOptionalTypeIncorrect _value,
      $Res Function(_$_DiscOptionalTypeIncorrect) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitType = freezed,
  }) {
    return _then(_$_DiscOptionalTypeIncorrect(
      fruitType: freezed == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DiscOptionalTypeIncorrect extends _DiscOptionalTypeIncorrect {
  const _$_DiscOptionalTypeIncorrect(
      {@JsonKey(name: r'fruitType') this.fruitType})
      : super._();

  factory _$_DiscOptionalTypeIncorrect.fromJson(Map<String, dynamic> json) =>
      _$$_DiscOptionalTypeIncorrectFromJson(json);

  @override
  @JsonKey(name: r'fruitType')
  final int? fruitType;

  @override
  String toString() {
    return 'DiscOptionalTypeIncorrect(fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DiscOptionalTypeIncorrect &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DiscOptionalTypeIncorrectCopyWith<_$_DiscOptionalTypeIncorrect>
      get copyWith => __$$_DiscOptionalTypeIncorrectCopyWithImpl<
          _$_DiscOptionalTypeIncorrect>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DiscOptionalTypeIncorrectToJson(
      this,
    );
  }
}

abstract class _DiscOptionalTypeIncorrect extends DiscOptionalTypeIncorrect {
  const factory _DiscOptionalTypeIncorrect(
          {@JsonKey(name: r'fruitType') final int? fruitType}) =
      _$_DiscOptionalTypeIncorrect;
  const _DiscOptionalTypeIncorrect._() : super._();

  factory _DiscOptionalTypeIncorrect.fromJson(Map<String, dynamic> json) =
      _$_DiscOptionalTypeIncorrect.fromJson;

  @override
  @JsonKey(name: r'fruitType')
  int? get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_DiscOptionalTypeIncorrectCopyWith<_$_DiscOptionalTypeIncorrect>
      get copyWith => throw _privateConstructorUsedError;
}

DiscTypeIncorrect _$DiscTypeIncorrectFromJson(Map<String, dynamic> json) {
  return _DiscTypeIncorrect.fromJson(json);
}

/// @nodoc
mixin _$DiscTypeIncorrect {
  @JsonKey(name: r'fruitType')
  int get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DiscTypeIncorrectCopyWith<DiscTypeIncorrect> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DiscTypeIncorrectCopyWith<$Res> {
  factory $DiscTypeIncorrectCopyWith(
          DiscTypeIncorrect value, $Res Function(DiscTypeIncorrect) then) =
      _$DiscTypeIncorrectCopyWithImpl<$Res, DiscTypeIncorrect>;
  @useResult
  $Res call({@JsonKey(name: r'fruitType') int fruitType});
}

/// @nodoc
class _$DiscTypeIncorrectCopyWithImpl<$Res, $Val extends DiscTypeIncorrect>
    implements $DiscTypeIncorrectCopyWith<$Res> {
  _$DiscTypeIncorrectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitType = null,
  }) {
    return _then(_value.copyWith(
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DiscTypeIncorrectCopyWith<$Res>
    implements $DiscTypeIncorrectCopyWith<$Res> {
  factory _$$_DiscTypeIncorrectCopyWith(_$_DiscTypeIncorrect value,
          $Res Function(_$_DiscTypeIncorrect) then) =
      __$$_DiscTypeIncorrectCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: r'fruitType') int fruitType});
}

/// @nodoc
class __$$_DiscTypeIncorrectCopyWithImpl<$Res>
    extends _$DiscTypeIncorrectCopyWithImpl<$Res, _$_DiscTypeIncorrect>
    implements _$$_DiscTypeIncorrectCopyWith<$Res> {
  __$$_DiscTypeIncorrectCopyWithImpl(
      _$_DiscTypeIncorrect _value, $Res Function(_$_DiscTypeIncorrect) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitType = null,
  }) {
    return _then(_$_DiscTypeIncorrect(
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DiscTypeIncorrect extends _DiscTypeIncorrect {
  const _$_DiscTypeIncorrect(
      {@JsonKey(name: r'fruitType') required this.fruitType})
      : super._();

  factory _$_DiscTypeIncorrect.fromJson(Map<String, dynamic> json) =>
      _$$_DiscTypeIncorrectFromJson(json);

  @override
  @JsonKey(name: r'fruitType')
  final int fruitType;

  @override
  String toString() {
    return 'DiscTypeIncorrect(fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DiscTypeIncorrect &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DiscTypeIncorrectCopyWith<_$_DiscTypeIncorrect> get copyWith =>
      __$$_DiscTypeIncorrectCopyWithImpl<_$_DiscTypeIncorrect>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DiscTypeIncorrectToJson(
      this,
    );
  }
}

abstract class _DiscTypeIncorrect extends DiscTypeIncorrect {
  const factory _DiscTypeIncorrect(
          {@JsonKey(name: r'fruitType') required final int fruitType}) =
      _$_DiscTypeIncorrect;
  const _DiscTypeIncorrect._() : super._();

  factory _DiscTypeIncorrect.fromJson(Map<String, dynamic> json) =
      _$_DiscTypeIncorrect.fromJson;

  @override
  @JsonKey(name: r'fruitType')
  int get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_DiscTypeIncorrectCopyWith<_$_DiscTypeIncorrect> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FruitAllOfDisc {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleAllOfDisc appleAllOfDiscValue)
        asAppleAllOfDisc,
    required TResult Function(BananaAllOfDisc bananaAllOfDiscValue)
        asBananaAllOfDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAllOfDisc> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleAllOfDisc appleAllOfDiscValue)? asAppleAllOfDisc,
    TResult? Function(BananaAllOfDisc bananaAllOfDiscValue)? asBananaAllOfDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAllOfDisc> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleAllOfDisc appleAllOfDiscValue)? asAppleAllOfDisc,
    TResult Function(BananaAllOfDisc bananaAllOfDiscValue)? asBananaAllOfDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAllOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitAllOfDiscAsAppleAllOfDisc value)
        asAppleAllOfDisc,
    required TResult Function(FruitAllOfDiscAsBananaAllOfDisc value)
        asBananaAllOfDisc,
    required TResult Function(FruitAllOfDiscUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitAllOfDiscAsAppleAllOfDisc value)? asAppleAllOfDisc,
    TResult? Function(FruitAllOfDiscAsBananaAllOfDisc value)? asBananaAllOfDisc,
    TResult? Function(FruitAllOfDiscUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitAllOfDiscAsAppleAllOfDisc value)? asAppleAllOfDisc,
    TResult Function(FruitAllOfDiscAsBananaAllOfDisc value)? asBananaAllOfDisc,
    TResult Function(FruitAllOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitAllOfDiscCopyWith<$Res> {
  factory $FruitAllOfDiscCopyWith(
          FruitAllOfDisc value, $Res Function(FruitAllOfDisc) then) =
      _$FruitAllOfDiscCopyWithImpl<$Res, FruitAllOfDisc>;
}

/// @nodoc
class _$FruitAllOfDiscCopyWithImpl<$Res, $Val extends FruitAllOfDisc>
    implements $FruitAllOfDiscCopyWith<$Res> {
  _$FruitAllOfDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FruitAllOfDiscAsAppleAllOfDiscCopyWith<$Res> {
  factory _$$FruitAllOfDiscAsAppleAllOfDiscCopyWith(
          _$FruitAllOfDiscAsAppleAllOfDisc value,
          $Res Function(_$FruitAllOfDiscAsAppleAllOfDisc) then) =
      __$$FruitAllOfDiscAsAppleAllOfDiscCopyWithImpl<$Res>;
  @useResult
  $Res call({AppleAllOfDisc appleAllOfDiscValue});

  $AppleAllOfDiscCopyWith<$Res> get appleAllOfDiscValue;
}

/// @nodoc
class __$$FruitAllOfDiscAsAppleAllOfDiscCopyWithImpl<$Res>
    extends _$FruitAllOfDiscCopyWithImpl<$Res, _$FruitAllOfDiscAsAppleAllOfDisc>
    implements _$$FruitAllOfDiscAsAppleAllOfDiscCopyWith<$Res> {
  __$$FruitAllOfDiscAsAppleAllOfDiscCopyWithImpl(
      _$FruitAllOfDiscAsAppleAllOfDisc _value,
      $Res Function(_$FruitAllOfDiscAsAppleAllOfDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? appleAllOfDiscValue = null,
  }) {
    return _then(_$FruitAllOfDiscAsAppleAllOfDisc(
      appleAllOfDiscValue: null == appleAllOfDiscValue
          ? _value.appleAllOfDiscValue
          : appleAllOfDiscValue // ignore: cast_nullable_to_non_nullable
              as AppleAllOfDisc,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AppleAllOfDiscCopyWith<$Res> get appleAllOfDiscValue {
    return $AppleAllOfDiscCopyWith<$Res>(_value.appleAllOfDiscValue, (value) {
      return _then(_value.copyWith(appleAllOfDiscValue: value));
    });
  }
}

/// @nodoc

class _$FruitAllOfDiscAsAppleAllOfDisc extends FruitAllOfDiscAsAppleAllOfDisc {
  const _$FruitAllOfDiscAsAppleAllOfDisc({required this.appleAllOfDiscValue})
      : super._();

  @override
  final AppleAllOfDisc appleAllOfDiscValue;

  @override
  String toString() {
    return 'FruitAllOfDisc.asAppleAllOfDisc(appleAllOfDiscValue: $appleAllOfDiscValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitAllOfDiscAsAppleAllOfDisc &&
            (identical(other.appleAllOfDiscValue, appleAllOfDiscValue) ||
                other.appleAllOfDiscValue == appleAllOfDiscValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, appleAllOfDiscValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitAllOfDiscAsAppleAllOfDiscCopyWith<_$FruitAllOfDiscAsAppleAllOfDisc>
      get copyWith => __$$FruitAllOfDiscAsAppleAllOfDiscCopyWithImpl<
          _$FruitAllOfDiscAsAppleAllOfDisc>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleAllOfDisc appleAllOfDiscValue)
        asAppleAllOfDisc,
    required TResult Function(BananaAllOfDisc bananaAllOfDiscValue)
        asBananaAllOfDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAllOfDisc> deserializedModels)
        unknown,
  }) {
    return asAppleAllOfDisc(appleAllOfDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleAllOfDisc appleAllOfDiscValue)? asAppleAllOfDisc,
    TResult? Function(BananaAllOfDisc bananaAllOfDiscValue)? asBananaAllOfDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAllOfDisc> deserializedModels)?
        unknown,
  }) {
    return asAppleAllOfDisc?.call(appleAllOfDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleAllOfDisc appleAllOfDiscValue)? asAppleAllOfDisc,
    TResult Function(BananaAllOfDisc bananaAllOfDiscValue)? asBananaAllOfDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAllOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asAppleAllOfDisc != null) {
      return asAppleAllOfDisc(appleAllOfDiscValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitAllOfDiscAsAppleAllOfDisc value)
        asAppleAllOfDisc,
    required TResult Function(FruitAllOfDiscAsBananaAllOfDisc value)
        asBananaAllOfDisc,
    required TResult Function(FruitAllOfDiscUnknown value) unknown,
  }) {
    return asAppleAllOfDisc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitAllOfDiscAsAppleAllOfDisc value)? asAppleAllOfDisc,
    TResult? Function(FruitAllOfDiscAsBananaAllOfDisc value)? asBananaAllOfDisc,
    TResult? Function(FruitAllOfDiscUnknown value)? unknown,
  }) {
    return asAppleAllOfDisc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitAllOfDiscAsAppleAllOfDisc value)? asAppleAllOfDisc,
    TResult Function(FruitAllOfDiscAsBananaAllOfDisc value)? asBananaAllOfDisc,
    TResult Function(FruitAllOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asAppleAllOfDisc != null) {
      return asAppleAllOfDisc(this);
    }
    return orElse();
  }
}

abstract class FruitAllOfDiscAsAppleAllOfDisc extends FruitAllOfDisc {
  const factory FruitAllOfDiscAsAppleAllOfDisc(
          {required final AppleAllOfDisc appleAllOfDiscValue}) =
      _$FruitAllOfDiscAsAppleAllOfDisc;
  const FruitAllOfDiscAsAppleAllOfDisc._() : super._();

  AppleAllOfDisc get appleAllOfDiscValue;
  @JsonKey(ignore: true)
  _$$FruitAllOfDiscAsAppleAllOfDiscCopyWith<_$FruitAllOfDiscAsAppleAllOfDisc>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitAllOfDiscAsBananaAllOfDiscCopyWith<$Res> {
  factory _$$FruitAllOfDiscAsBananaAllOfDiscCopyWith(
          _$FruitAllOfDiscAsBananaAllOfDisc value,
          $Res Function(_$FruitAllOfDiscAsBananaAllOfDisc) then) =
      __$$FruitAllOfDiscAsBananaAllOfDiscCopyWithImpl<$Res>;
  @useResult
  $Res call({BananaAllOfDisc bananaAllOfDiscValue});

  $BananaAllOfDiscCopyWith<$Res> get bananaAllOfDiscValue;
}

/// @nodoc
class __$$FruitAllOfDiscAsBananaAllOfDiscCopyWithImpl<$Res>
    extends _$FruitAllOfDiscCopyWithImpl<$Res,
        _$FruitAllOfDiscAsBananaAllOfDisc>
    implements _$$FruitAllOfDiscAsBananaAllOfDiscCopyWith<$Res> {
  __$$FruitAllOfDiscAsBananaAllOfDiscCopyWithImpl(
      _$FruitAllOfDiscAsBananaAllOfDisc _value,
      $Res Function(_$FruitAllOfDiscAsBananaAllOfDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bananaAllOfDiscValue = null,
  }) {
    return _then(_$FruitAllOfDiscAsBananaAllOfDisc(
      bananaAllOfDiscValue: null == bananaAllOfDiscValue
          ? _value.bananaAllOfDiscValue
          : bananaAllOfDiscValue // ignore: cast_nullable_to_non_nullable
              as BananaAllOfDisc,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BananaAllOfDiscCopyWith<$Res> get bananaAllOfDiscValue {
    return $BananaAllOfDiscCopyWith<$Res>(_value.bananaAllOfDiscValue, (value) {
      return _then(_value.copyWith(bananaAllOfDiscValue: value));
    });
  }
}

/// @nodoc

class _$FruitAllOfDiscAsBananaAllOfDisc
    extends FruitAllOfDiscAsBananaAllOfDisc {
  const _$FruitAllOfDiscAsBananaAllOfDisc({required this.bananaAllOfDiscValue})
      : super._();

  @override
  final BananaAllOfDisc bananaAllOfDiscValue;

  @override
  String toString() {
    return 'FruitAllOfDisc.asBananaAllOfDisc(bananaAllOfDiscValue: $bananaAllOfDiscValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitAllOfDiscAsBananaAllOfDisc &&
            (identical(other.bananaAllOfDiscValue, bananaAllOfDiscValue) ||
                other.bananaAllOfDiscValue == bananaAllOfDiscValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bananaAllOfDiscValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitAllOfDiscAsBananaAllOfDiscCopyWith<_$FruitAllOfDiscAsBananaAllOfDisc>
      get copyWith => __$$FruitAllOfDiscAsBananaAllOfDiscCopyWithImpl<
          _$FruitAllOfDiscAsBananaAllOfDisc>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleAllOfDisc appleAllOfDiscValue)
        asAppleAllOfDisc,
    required TResult Function(BananaAllOfDisc bananaAllOfDiscValue)
        asBananaAllOfDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAllOfDisc> deserializedModels)
        unknown,
  }) {
    return asBananaAllOfDisc(bananaAllOfDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleAllOfDisc appleAllOfDiscValue)? asAppleAllOfDisc,
    TResult? Function(BananaAllOfDisc bananaAllOfDiscValue)? asBananaAllOfDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAllOfDisc> deserializedModels)?
        unknown,
  }) {
    return asBananaAllOfDisc?.call(bananaAllOfDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleAllOfDisc appleAllOfDiscValue)? asAppleAllOfDisc,
    TResult Function(BananaAllOfDisc bananaAllOfDiscValue)? asBananaAllOfDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAllOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asBananaAllOfDisc != null) {
      return asBananaAllOfDisc(bananaAllOfDiscValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitAllOfDiscAsAppleAllOfDisc value)
        asAppleAllOfDisc,
    required TResult Function(FruitAllOfDiscAsBananaAllOfDisc value)
        asBananaAllOfDisc,
    required TResult Function(FruitAllOfDiscUnknown value) unknown,
  }) {
    return asBananaAllOfDisc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitAllOfDiscAsAppleAllOfDisc value)? asAppleAllOfDisc,
    TResult? Function(FruitAllOfDiscAsBananaAllOfDisc value)? asBananaAllOfDisc,
    TResult? Function(FruitAllOfDiscUnknown value)? unknown,
  }) {
    return asBananaAllOfDisc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitAllOfDiscAsAppleAllOfDisc value)? asAppleAllOfDisc,
    TResult Function(FruitAllOfDiscAsBananaAllOfDisc value)? asBananaAllOfDisc,
    TResult Function(FruitAllOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asBananaAllOfDisc != null) {
      return asBananaAllOfDisc(this);
    }
    return orElse();
  }
}

abstract class FruitAllOfDiscAsBananaAllOfDisc extends FruitAllOfDisc {
  const factory FruitAllOfDiscAsBananaAllOfDisc(
          {required final BananaAllOfDisc bananaAllOfDiscValue}) =
      _$FruitAllOfDiscAsBananaAllOfDisc;
  const FruitAllOfDiscAsBananaAllOfDisc._() : super._();

  BananaAllOfDisc get bananaAllOfDiscValue;
  @JsonKey(ignore: true)
  _$$FruitAllOfDiscAsBananaAllOfDiscCopyWith<_$FruitAllOfDiscAsBananaAllOfDisc>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitAllOfDiscUnknownCopyWith<$Res> {
  factory _$$FruitAllOfDiscUnknownCopyWith(_$FruitAllOfDiscUnknown value,
          $Res Function(_$FruitAllOfDiscUnknown) then) =
      __$$FruitAllOfDiscUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<FruitAllOfDisc> deserializedModels});
}

/// @nodoc
class __$$FruitAllOfDiscUnknownCopyWithImpl<$Res>
    extends _$FruitAllOfDiscCopyWithImpl<$Res, _$FruitAllOfDiscUnknown>
    implements _$$FruitAllOfDiscUnknownCopyWith<$Res> {
  __$$FruitAllOfDiscUnknownCopyWithImpl(_$FruitAllOfDiscUnknown _value,
      $Res Function(_$FruitAllOfDiscUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$FruitAllOfDiscUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<FruitAllOfDisc>,
    ));
  }
}

/// @nodoc

class _$FruitAllOfDiscUnknown extends FruitAllOfDiscUnknown {
  const _$FruitAllOfDiscUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        AppleAllOfDisc,
        BananaAllOfDisc
      ],
      final List<FruitAllOfDisc> deserializedModels = const <FruitAllOfDisc>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<FruitAllOfDisc> _deserializedModels;
  @override
  @JsonKey()
  List<FruitAllOfDisc> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'FruitAllOfDisc.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitAllOfDiscUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitAllOfDiscUnknownCopyWith<_$FruitAllOfDiscUnknown> get copyWith =>
      __$$FruitAllOfDiscUnknownCopyWithImpl<_$FruitAllOfDiscUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleAllOfDisc appleAllOfDiscValue)
        asAppleAllOfDisc,
    required TResult Function(BananaAllOfDisc bananaAllOfDiscValue)
        asBananaAllOfDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAllOfDisc> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleAllOfDisc appleAllOfDiscValue)? asAppleAllOfDisc,
    TResult? Function(BananaAllOfDisc bananaAllOfDiscValue)? asBananaAllOfDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAllOfDisc> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleAllOfDisc appleAllOfDiscValue)? asAppleAllOfDisc,
    TResult Function(BananaAllOfDisc bananaAllOfDiscValue)? asBananaAllOfDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAllOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitAllOfDiscAsAppleAllOfDisc value)
        asAppleAllOfDisc,
    required TResult Function(FruitAllOfDiscAsBananaAllOfDisc value)
        asBananaAllOfDisc,
    required TResult Function(FruitAllOfDiscUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitAllOfDiscAsAppleAllOfDisc value)? asAppleAllOfDisc,
    TResult? Function(FruitAllOfDiscAsBananaAllOfDisc value)? asBananaAllOfDisc,
    TResult? Function(FruitAllOfDiscUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitAllOfDiscAsAppleAllOfDisc value)? asAppleAllOfDisc,
    TResult Function(FruitAllOfDiscAsBananaAllOfDisc value)? asBananaAllOfDisc,
    TResult Function(FruitAllOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class FruitAllOfDiscUnknown extends FruitAllOfDisc {
  const factory FruitAllOfDiscUnknown(
      {final String message,
      required final Map<String, dynamic> json,
      final DeserializationErrorType errorType,
      final List<Type> possibleTypes,
      final List<FruitAllOfDisc> deserializedModels}) = _$FruitAllOfDiscUnknown;
  const FruitAllOfDiscUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<FruitAllOfDisc> get deserializedModels;
  @JsonKey(ignore: true)
  _$$FruitAllOfDiscUnknownCopyWith<_$FruitAllOfDiscUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FruitAnyOfDisc {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleAnyOfDisc appleAnyOfDiscValue)
        asAppleAnyOfDisc,
    required TResult Function(BananaAnyOfDisc bananaAnyOfDiscValue)
        asBananaAnyOfDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAnyOfDisc> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleAnyOfDisc appleAnyOfDiscValue)? asAppleAnyOfDisc,
    TResult? Function(BananaAnyOfDisc bananaAnyOfDiscValue)? asBananaAnyOfDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAnyOfDisc> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleAnyOfDisc appleAnyOfDiscValue)? asAppleAnyOfDisc,
    TResult Function(BananaAnyOfDisc bananaAnyOfDiscValue)? asBananaAnyOfDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAnyOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitAnyOfDiscAsAppleAnyOfDisc value)
        asAppleAnyOfDisc,
    required TResult Function(FruitAnyOfDiscAsBananaAnyOfDisc value)
        asBananaAnyOfDisc,
    required TResult Function(FruitAnyOfDiscUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitAnyOfDiscAsAppleAnyOfDisc value)? asAppleAnyOfDisc,
    TResult? Function(FruitAnyOfDiscAsBananaAnyOfDisc value)? asBananaAnyOfDisc,
    TResult? Function(FruitAnyOfDiscUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitAnyOfDiscAsAppleAnyOfDisc value)? asAppleAnyOfDisc,
    TResult Function(FruitAnyOfDiscAsBananaAnyOfDisc value)? asBananaAnyOfDisc,
    TResult Function(FruitAnyOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitAnyOfDiscCopyWith<$Res> {
  factory $FruitAnyOfDiscCopyWith(
          FruitAnyOfDisc value, $Res Function(FruitAnyOfDisc) then) =
      _$FruitAnyOfDiscCopyWithImpl<$Res, FruitAnyOfDisc>;
}

/// @nodoc
class _$FruitAnyOfDiscCopyWithImpl<$Res, $Val extends FruitAnyOfDisc>
    implements $FruitAnyOfDiscCopyWith<$Res> {
  _$FruitAnyOfDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FruitAnyOfDiscAsAppleAnyOfDiscCopyWith<$Res> {
  factory _$$FruitAnyOfDiscAsAppleAnyOfDiscCopyWith(
          _$FruitAnyOfDiscAsAppleAnyOfDisc value,
          $Res Function(_$FruitAnyOfDiscAsAppleAnyOfDisc) then) =
      __$$FruitAnyOfDiscAsAppleAnyOfDiscCopyWithImpl<$Res>;
  @useResult
  $Res call({AppleAnyOfDisc appleAnyOfDiscValue});

  $AppleAnyOfDiscCopyWith<$Res> get appleAnyOfDiscValue;
}

/// @nodoc
class __$$FruitAnyOfDiscAsAppleAnyOfDiscCopyWithImpl<$Res>
    extends _$FruitAnyOfDiscCopyWithImpl<$Res, _$FruitAnyOfDiscAsAppleAnyOfDisc>
    implements _$$FruitAnyOfDiscAsAppleAnyOfDiscCopyWith<$Res> {
  __$$FruitAnyOfDiscAsAppleAnyOfDiscCopyWithImpl(
      _$FruitAnyOfDiscAsAppleAnyOfDisc _value,
      $Res Function(_$FruitAnyOfDiscAsAppleAnyOfDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? appleAnyOfDiscValue = null,
  }) {
    return _then(_$FruitAnyOfDiscAsAppleAnyOfDisc(
      appleAnyOfDiscValue: null == appleAnyOfDiscValue
          ? _value.appleAnyOfDiscValue
          : appleAnyOfDiscValue // ignore: cast_nullable_to_non_nullable
              as AppleAnyOfDisc,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AppleAnyOfDiscCopyWith<$Res> get appleAnyOfDiscValue {
    return $AppleAnyOfDiscCopyWith<$Res>(_value.appleAnyOfDiscValue, (value) {
      return _then(_value.copyWith(appleAnyOfDiscValue: value));
    });
  }
}

/// @nodoc

class _$FruitAnyOfDiscAsAppleAnyOfDisc extends FruitAnyOfDiscAsAppleAnyOfDisc {
  const _$FruitAnyOfDiscAsAppleAnyOfDisc({required this.appleAnyOfDiscValue})
      : super._();

  @override
  final AppleAnyOfDisc appleAnyOfDiscValue;

  @override
  String toString() {
    return 'FruitAnyOfDisc.asAppleAnyOfDisc(appleAnyOfDiscValue: $appleAnyOfDiscValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitAnyOfDiscAsAppleAnyOfDisc &&
            (identical(other.appleAnyOfDiscValue, appleAnyOfDiscValue) ||
                other.appleAnyOfDiscValue == appleAnyOfDiscValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, appleAnyOfDiscValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitAnyOfDiscAsAppleAnyOfDiscCopyWith<_$FruitAnyOfDiscAsAppleAnyOfDisc>
      get copyWith => __$$FruitAnyOfDiscAsAppleAnyOfDiscCopyWithImpl<
          _$FruitAnyOfDiscAsAppleAnyOfDisc>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleAnyOfDisc appleAnyOfDiscValue)
        asAppleAnyOfDisc,
    required TResult Function(BananaAnyOfDisc bananaAnyOfDiscValue)
        asBananaAnyOfDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAnyOfDisc> deserializedModels)
        unknown,
  }) {
    return asAppleAnyOfDisc(appleAnyOfDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleAnyOfDisc appleAnyOfDiscValue)? asAppleAnyOfDisc,
    TResult? Function(BananaAnyOfDisc bananaAnyOfDiscValue)? asBananaAnyOfDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAnyOfDisc> deserializedModels)?
        unknown,
  }) {
    return asAppleAnyOfDisc?.call(appleAnyOfDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleAnyOfDisc appleAnyOfDiscValue)? asAppleAnyOfDisc,
    TResult Function(BananaAnyOfDisc bananaAnyOfDiscValue)? asBananaAnyOfDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAnyOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asAppleAnyOfDisc != null) {
      return asAppleAnyOfDisc(appleAnyOfDiscValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitAnyOfDiscAsAppleAnyOfDisc value)
        asAppleAnyOfDisc,
    required TResult Function(FruitAnyOfDiscAsBananaAnyOfDisc value)
        asBananaAnyOfDisc,
    required TResult Function(FruitAnyOfDiscUnknown value) unknown,
  }) {
    return asAppleAnyOfDisc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitAnyOfDiscAsAppleAnyOfDisc value)? asAppleAnyOfDisc,
    TResult? Function(FruitAnyOfDiscAsBananaAnyOfDisc value)? asBananaAnyOfDisc,
    TResult? Function(FruitAnyOfDiscUnknown value)? unknown,
  }) {
    return asAppleAnyOfDisc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitAnyOfDiscAsAppleAnyOfDisc value)? asAppleAnyOfDisc,
    TResult Function(FruitAnyOfDiscAsBananaAnyOfDisc value)? asBananaAnyOfDisc,
    TResult Function(FruitAnyOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asAppleAnyOfDisc != null) {
      return asAppleAnyOfDisc(this);
    }
    return orElse();
  }
}

abstract class FruitAnyOfDiscAsAppleAnyOfDisc extends FruitAnyOfDisc {
  const factory FruitAnyOfDiscAsAppleAnyOfDisc(
          {required final AppleAnyOfDisc appleAnyOfDiscValue}) =
      _$FruitAnyOfDiscAsAppleAnyOfDisc;
  const FruitAnyOfDiscAsAppleAnyOfDisc._() : super._();

  AppleAnyOfDisc get appleAnyOfDiscValue;
  @JsonKey(ignore: true)
  _$$FruitAnyOfDiscAsAppleAnyOfDiscCopyWith<_$FruitAnyOfDiscAsAppleAnyOfDisc>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitAnyOfDiscAsBananaAnyOfDiscCopyWith<$Res> {
  factory _$$FruitAnyOfDiscAsBananaAnyOfDiscCopyWith(
          _$FruitAnyOfDiscAsBananaAnyOfDisc value,
          $Res Function(_$FruitAnyOfDiscAsBananaAnyOfDisc) then) =
      __$$FruitAnyOfDiscAsBananaAnyOfDiscCopyWithImpl<$Res>;
  @useResult
  $Res call({BananaAnyOfDisc bananaAnyOfDiscValue});

  $BananaAnyOfDiscCopyWith<$Res> get bananaAnyOfDiscValue;
}

/// @nodoc
class __$$FruitAnyOfDiscAsBananaAnyOfDiscCopyWithImpl<$Res>
    extends _$FruitAnyOfDiscCopyWithImpl<$Res,
        _$FruitAnyOfDiscAsBananaAnyOfDisc>
    implements _$$FruitAnyOfDiscAsBananaAnyOfDiscCopyWith<$Res> {
  __$$FruitAnyOfDiscAsBananaAnyOfDiscCopyWithImpl(
      _$FruitAnyOfDiscAsBananaAnyOfDisc _value,
      $Res Function(_$FruitAnyOfDiscAsBananaAnyOfDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bananaAnyOfDiscValue = null,
  }) {
    return _then(_$FruitAnyOfDiscAsBananaAnyOfDisc(
      bananaAnyOfDiscValue: null == bananaAnyOfDiscValue
          ? _value.bananaAnyOfDiscValue
          : bananaAnyOfDiscValue // ignore: cast_nullable_to_non_nullable
              as BananaAnyOfDisc,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BananaAnyOfDiscCopyWith<$Res> get bananaAnyOfDiscValue {
    return $BananaAnyOfDiscCopyWith<$Res>(_value.bananaAnyOfDiscValue, (value) {
      return _then(_value.copyWith(bananaAnyOfDiscValue: value));
    });
  }
}

/// @nodoc

class _$FruitAnyOfDiscAsBananaAnyOfDisc
    extends FruitAnyOfDiscAsBananaAnyOfDisc {
  const _$FruitAnyOfDiscAsBananaAnyOfDisc({required this.bananaAnyOfDiscValue})
      : super._();

  @override
  final BananaAnyOfDisc bananaAnyOfDiscValue;

  @override
  String toString() {
    return 'FruitAnyOfDisc.asBananaAnyOfDisc(bananaAnyOfDiscValue: $bananaAnyOfDiscValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitAnyOfDiscAsBananaAnyOfDisc &&
            (identical(other.bananaAnyOfDiscValue, bananaAnyOfDiscValue) ||
                other.bananaAnyOfDiscValue == bananaAnyOfDiscValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bananaAnyOfDiscValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitAnyOfDiscAsBananaAnyOfDiscCopyWith<_$FruitAnyOfDiscAsBananaAnyOfDisc>
      get copyWith => __$$FruitAnyOfDiscAsBananaAnyOfDiscCopyWithImpl<
          _$FruitAnyOfDiscAsBananaAnyOfDisc>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleAnyOfDisc appleAnyOfDiscValue)
        asAppleAnyOfDisc,
    required TResult Function(BananaAnyOfDisc bananaAnyOfDiscValue)
        asBananaAnyOfDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAnyOfDisc> deserializedModels)
        unknown,
  }) {
    return asBananaAnyOfDisc(bananaAnyOfDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleAnyOfDisc appleAnyOfDiscValue)? asAppleAnyOfDisc,
    TResult? Function(BananaAnyOfDisc bananaAnyOfDiscValue)? asBananaAnyOfDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAnyOfDisc> deserializedModels)?
        unknown,
  }) {
    return asBananaAnyOfDisc?.call(bananaAnyOfDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleAnyOfDisc appleAnyOfDiscValue)? asAppleAnyOfDisc,
    TResult Function(BananaAnyOfDisc bananaAnyOfDiscValue)? asBananaAnyOfDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAnyOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asBananaAnyOfDisc != null) {
      return asBananaAnyOfDisc(bananaAnyOfDiscValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitAnyOfDiscAsAppleAnyOfDisc value)
        asAppleAnyOfDisc,
    required TResult Function(FruitAnyOfDiscAsBananaAnyOfDisc value)
        asBananaAnyOfDisc,
    required TResult Function(FruitAnyOfDiscUnknown value) unknown,
  }) {
    return asBananaAnyOfDisc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitAnyOfDiscAsAppleAnyOfDisc value)? asAppleAnyOfDisc,
    TResult? Function(FruitAnyOfDiscAsBananaAnyOfDisc value)? asBananaAnyOfDisc,
    TResult? Function(FruitAnyOfDiscUnknown value)? unknown,
  }) {
    return asBananaAnyOfDisc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitAnyOfDiscAsAppleAnyOfDisc value)? asAppleAnyOfDisc,
    TResult Function(FruitAnyOfDiscAsBananaAnyOfDisc value)? asBananaAnyOfDisc,
    TResult Function(FruitAnyOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asBananaAnyOfDisc != null) {
      return asBananaAnyOfDisc(this);
    }
    return orElse();
  }
}

abstract class FruitAnyOfDiscAsBananaAnyOfDisc extends FruitAnyOfDisc {
  const factory FruitAnyOfDiscAsBananaAnyOfDisc(
          {required final BananaAnyOfDisc bananaAnyOfDiscValue}) =
      _$FruitAnyOfDiscAsBananaAnyOfDisc;
  const FruitAnyOfDiscAsBananaAnyOfDisc._() : super._();

  BananaAnyOfDisc get bananaAnyOfDiscValue;
  @JsonKey(ignore: true)
  _$$FruitAnyOfDiscAsBananaAnyOfDiscCopyWith<_$FruitAnyOfDiscAsBananaAnyOfDisc>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitAnyOfDiscUnknownCopyWith<$Res> {
  factory _$$FruitAnyOfDiscUnknownCopyWith(_$FruitAnyOfDiscUnknown value,
          $Res Function(_$FruitAnyOfDiscUnknown) then) =
      __$$FruitAnyOfDiscUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<FruitAnyOfDisc> deserializedModels});
}

/// @nodoc
class __$$FruitAnyOfDiscUnknownCopyWithImpl<$Res>
    extends _$FruitAnyOfDiscCopyWithImpl<$Res, _$FruitAnyOfDiscUnknown>
    implements _$$FruitAnyOfDiscUnknownCopyWith<$Res> {
  __$$FruitAnyOfDiscUnknownCopyWithImpl(_$FruitAnyOfDiscUnknown _value,
      $Res Function(_$FruitAnyOfDiscUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$FruitAnyOfDiscUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<FruitAnyOfDisc>,
    ));
  }
}

/// @nodoc

class _$FruitAnyOfDiscUnknown extends FruitAnyOfDiscUnknown {
  const _$FruitAnyOfDiscUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        AppleAnyOfDisc,
        BananaAnyOfDisc
      ],
      final List<FruitAnyOfDisc> deserializedModels = const <FruitAnyOfDisc>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<FruitAnyOfDisc> _deserializedModels;
  @override
  @JsonKey()
  List<FruitAnyOfDisc> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'FruitAnyOfDisc.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitAnyOfDiscUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitAnyOfDiscUnknownCopyWith<_$FruitAnyOfDiscUnknown> get copyWith =>
      __$$FruitAnyOfDiscUnknownCopyWithImpl<_$FruitAnyOfDiscUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleAnyOfDisc appleAnyOfDiscValue)
        asAppleAnyOfDisc,
    required TResult Function(BananaAnyOfDisc bananaAnyOfDiscValue)
        asBananaAnyOfDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAnyOfDisc> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleAnyOfDisc appleAnyOfDiscValue)? asAppleAnyOfDisc,
    TResult? Function(BananaAnyOfDisc bananaAnyOfDiscValue)? asBananaAnyOfDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAnyOfDisc> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleAnyOfDisc appleAnyOfDiscValue)? asAppleAnyOfDisc,
    TResult Function(BananaAnyOfDisc bananaAnyOfDiscValue)? asBananaAnyOfDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitAnyOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitAnyOfDiscAsAppleAnyOfDisc value)
        asAppleAnyOfDisc,
    required TResult Function(FruitAnyOfDiscAsBananaAnyOfDisc value)
        asBananaAnyOfDisc,
    required TResult Function(FruitAnyOfDiscUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitAnyOfDiscAsAppleAnyOfDisc value)? asAppleAnyOfDisc,
    TResult? Function(FruitAnyOfDiscAsBananaAnyOfDisc value)? asBananaAnyOfDisc,
    TResult? Function(FruitAnyOfDiscUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitAnyOfDiscAsAppleAnyOfDisc value)? asAppleAnyOfDisc,
    TResult Function(FruitAnyOfDiscAsBananaAnyOfDisc value)? asBananaAnyOfDisc,
    TResult Function(FruitAnyOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class FruitAnyOfDiscUnknown extends FruitAnyOfDisc {
  const factory FruitAnyOfDiscUnknown(
      {final String message,
      required final Map<String, dynamic> json,
      final DeserializationErrorType errorType,
      final List<Type> possibleTypes,
      final List<FruitAnyOfDisc> deserializedModels}) = _$FruitAnyOfDiscUnknown;
  const FruitAnyOfDiscUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<FruitAnyOfDisc> get deserializedModels;
  @JsonKey(ignore: true)
  _$$FruitAnyOfDiscUnknownCopyWith<_$FruitAnyOfDiscUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FruitGrandparentDisc {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleGrandparentDisc appleGrandparentDiscValue)
        asAppleGrandparentDisc,
    required TResult Function(BananaGrandparentDisc bananaGrandparentDiscValue)
        asBananaGrandparentDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitGrandparentDisc> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleGrandparentDisc appleGrandparentDiscValue)?
        asAppleGrandparentDisc,
    TResult? Function(BananaGrandparentDisc bananaGrandparentDiscValue)?
        asBananaGrandparentDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitGrandparentDisc> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleGrandparentDisc appleGrandparentDiscValue)?
        asAppleGrandparentDisc,
    TResult Function(BananaGrandparentDisc bananaGrandparentDiscValue)?
        asBananaGrandparentDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitGrandparentDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitGrandparentDiscAsAppleGrandparentDisc value)
        asAppleGrandparentDisc,
    required TResult Function(FruitGrandparentDiscAsBananaGrandparentDisc value)
        asBananaGrandparentDisc,
    required TResult Function(FruitGrandparentDiscUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitGrandparentDiscAsAppleGrandparentDisc value)?
        asAppleGrandparentDisc,
    TResult? Function(FruitGrandparentDiscAsBananaGrandparentDisc value)?
        asBananaGrandparentDisc,
    TResult? Function(FruitGrandparentDiscUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitGrandparentDiscAsAppleGrandparentDisc value)?
        asAppleGrandparentDisc,
    TResult Function(FruitGrandparentDiscAsBananaGrandparentDisc value)?
        asBananaGrandparentDisc,
    TResult Function(FruitGrandparentDiscUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitGrandparentDiscCopyWith<$Res> {
  factory $FruitGrandparentDiscCopyWith(FruitGrandparentDisc value,
          $Res Function(FruitGrandparentDisc) then) =
      _$FruitGrandparentDiscCopyWithImpl<$Res, FruitGrandparentDisc>;
}

/// @nodoc
class _$FruitGrandparentDiscCopyWithImpl<$Res,
        $Val extends FruitGrandparentDisc>
    implements $FruitGrandparentDiscCopyWith<$Res> {
  _$FruitGrandparentDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FruitGrandparentDiscAsAppleGrandparentDiscCopyWith<$Res> {
  factory _$$FruitGrandparentDiscAsAppleGrandparentDiscCopyWith(
          _$FruitGrandparentDiscAsAppleGrandparentDisc value,
          $Res Function(_$FruitGrandparentDiscAsAppleGrandparentDisc) then) =
      __$$FruitGrandparentDiscAsAppleGrandparentDiscCopyWithImpl<$Res>;
  @useResult
  $Res call({AppleGrandparentDisc appleGrandparentDiscValue});

  $AppleGrandparentDiscCopyWith<$Res> get appleGrandparentDiscValue;
}

/// @nodoc
class __$$FruitGrandparentDiscAsAppleGrandparentDiscCopyWithImpl<$Res>
    extends _$FruitGrandparentDiscCopyWithImpl<$Res,
        _$FruitGrandparentDiscAsAppleGrandparentDisc>
    implements _$$FruitGrandparentDiscAsAppleGrandparentDiscCopyWith<$Res> {
  __$$FruitGrandparentDiscAsAppleGrandparentDiscCopyWithImpl(
      _$FruitGrandparentDiscAsAppleGrandparentDisc _value,
      $Res Function(_$FruitGrandparentDiscAsAppleGrandparentDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? appleGrandparentDiscValue = null,
  }) {
    return _then(_$FruitGrandparentDiscAsAppleGrandparentDisc(
      appleGrandparentDiscValue: null == appleGrandparentDiscValue
          ? _value.appleGrandparentDiscValue
          : appleGrandparentDiscValue // ignore: cast_nullable_to_non_nullable
              as AppleGrandparentDisc,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AppleGrandparentDiscCopyWith<$Res> get appleGrandparentDiscValue {
    return $AppleGrandparentDiscCopyWith<$Res>(_value.appleGrandparentDiscValue,
        (value) {
      return _then(_value.copyWith(appleGrandparentDiscValue: value));
    });
  }
}

/// @nodoc

class _$FruitGrandparentDiscAsAppleGrandparentDisc
    extends FruitGrandparentDiscAsAppleGrandparentDisc {
  const _$FruitGrandparentDiscAsAppleGrandparentDisc(
      {required this.appleGrandparentDiscValue})
      : super._();

  @override
  final AppleGrandparentDisc appleGrandparentDiscValue;

  @override
  String toString() {
    return 'FruitGrandparentDisc.asAppleGrandparentDisc(appleGrandparentDiscValue: $appleGrandparentDiscValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitGrandparentDiscAsAppleGrandparentDisc &&
            (identical(other.appleGrandparentDiscValue,
                    appleGrandparentDiscValue) ||
                other.appleGrandparentDiscValue == appleGrandparentDiscValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, appleGrandparentDiscValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitGrandparentDiscAsAppleGrandparentDiscCopyWith<
          _$FruitGrandparentDiscAsAppleGrandparentDisc>
      get copyWith =>
          __$$FruitGrandparentDiscAsAppleGrandparentDiscCopyWithImpl<
              _$FruitGrandparentDiscAsAppleGrandparentDisc>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleGrandparentDisc appleGrandparentDiscValue)
        asAppleGrandparentDisc,
    required TResult Function(BananaGrandparentDisc bananaGrandparentDiscValue)
        asBananaGrandparentDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitGrandparentDisc> deserializedModels)
        unknown,
  }) {
    return asAppleGrandparentDisc(appleGrandparentDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleGrandparentDisc appleGrandparentDiscValue)?
        asAppleGrandparentDisc,
    TResult? Function(BananaGrandparentDisc bananaGrandparentDiscValue)?
        asBananaGrandparentDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitGrandparentDisc> deserializedModels)?
        unknown,
  }) {
    return asAppleGrandparentDisc?.call(appleGrandparentDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleGrandparentDisc appleGrandparentDiscValue)?
        asAppleGrandparentDisc,
    TResult Function(BananaGrandparentDisc bananaGrandparentDiscValue)?
        asBananaGrandparentDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitGrandparentDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asAppleGrandparentDisc != null) {
      return asAppleGrandparentDisc(appleGrandparentDiscValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitGrandparentDiscAsAppleGrandparentDisc value)
        asAppleGrandparentDisc,
    required TResult Function(FruitGrandparentDiscAsBananaGrandparentDisc value)
        asBananaGrandparentDisc,
    required TResult Function(FruitGrandparentDiscUnknown value) unknown,
  }) {
    return asAppleGrandparentDisc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitGrandparentDiscAsAppleGrandparentDisc value)?
        asAppleGrandparentDisc,
    TResult? Function(FruitGrandparentDiscAsBananaGrandparentDisc value)?
        asBananaGrandparentDisc,
    TResult? Function(FruitGrandparentDiscUnknown value)? unknown,
  }) {
    return asAppleGrandparentDisc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitGrandparentDiscAsAppleGrandparentDisc value)?
        asAppleGrandparentDisc,
    TResult Function(FruitGrandparentDiscAsBananaGrandparentDisc value)?
        asBananaGrandparentDisc,
    TResult Function(FruitGrandparentDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asAppleGrandparentDisc != null) {
      return asAppleGrandparentDisc(this);
    }
    return orElse();
  }
}

abstract class FruitGrandparentDiscAsAppleGrandparentDisc
    extends FruitGrandparentDisc {
  const factory FruitGrandparentDiscAsAppleGrandparentDisc(
          {required final AppleGrandparentDisc appleGrandparentDiscValue}) =
      _$FruitGrandparentDiscAsAppleGrandparentDisc;
  const FruitGrandparentDiscAsAppleGrandparentDisc._() : super._();

  AppleGrandparentDisc get appleGrandparentDiscValue;
  @JsonKey(ignore: true)
  _$$FruitGrandparentDiscAsAppleGrandparentDiscCopyWith<
          _$FruitGrandparentDiscAsAppleGrandparentDisc>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitGrandparentDiscAsBananaGrandparentDiscCopyWith<$Res> {
  factory _$$FruitGrandparentDiscAsBananaGrandparentDiscCopyWith(
          _$FruitGrandparentDiscAsBananaGrandparentDisc value,
          $Res Function(_$FruitGrandparentDiscAsBananaGrandparentDisc) then) =
      __$$FruitGrandparentDiscAsBananaGrandparentDiscCopyWithImpl<$Res>;
  @useResult
  $Res call({BananaGrandparentDisc bananaGrandparentDiscValue});

  $BananaGrandparentDiscCopyWith<$Res> get bananaGrandparentDiscValue;
}

/// @nodoc
class __$$FruitGrandparentDiscAsBananaGrandparentDiscCopyWithImpl<$Res>
    extends _$FruitGrandparentDiscCopyWithImpl<$Res,
        _$FruitGrandparentDiscAsBananaGrandparentDisc>
    implements _$$FruitGrandparentDiscAsBananaGrandparentDiscCopyWith<$Res> {
  __$$FruitGrandparentDiscAsBananaGrandparentDiscCopyWithImpl(
      _$FruitGrandparentDiscAsBananaGrandparentDisc _value,
      $Res Function(_$FruitGrandparentDiscAsBananaGrandparentDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bananaGrandparentDiscValue = null,
  }) {
    return _then(_$FruitGrandparentDiscAsBananaGrandparentDisc(
      bananaGrandparentDiscValue: null == bananaGrandparentDiscValue
          ? _value.bananaGrandparentDiscValue
          : bananaGrandparentDiscValue // ignore: cast_nullable_to_non_nullable
              as BananaGrandparentDisc,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BananaGrandparentDiscCopyWith<$Res> get bananaGrandparentDiscValue {
    return $BananaGrandparentDiscCopyWith<$Res>(
        _value.bananaGrandparentDiscValue, (value) {
      return _then(_value.copyWith(bananaGrandparentDiscValue: value));
    });
  }
}

/// @nodoc

class _$FruitGrandparentDiscAsBananaGrandparentDisc
    extends FruitGrandparentDiscAsBananaGrandparentDisc {
  const _$FruitGrandparentDiscAsBananaGrandparentDisc(
      {required this.bananaGrandparentDiscValue})
      : super._();

  @override
  final BananaGrandparentDisc bananaGrandparentDiscValue;

  @override
  String toString() {
    return 'FruitGrandparentDisc.asBananaGrandparentDisc(bananaGrandparentDiscValue: $bananaGrandparentDiscValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitGrandparentDiscAsBananaGrandparentDisc &&
            (identical(other.bananaGrandparentDiscValue,
                    bananaGrandparentDiscValue) ||
                other.bananaGrandparentDiscValue ==
                    bananaGrandparentDiscValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bananaGrandparentDiscValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitGrandparentDiscAsBananaGrandparentDiscCopyWith<
          _$FruitGrandparentDiscAsBananaGrandparentDisc>
      get copyWith =>
          __$$FruitGrandparentDiscAsBananaGrandparentDiscCopyWithImpl<
              _$FruitGrandparentDiscAsBananaGrandparentDisc>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleGrandparentDisc appleGrandparentDiscValue)
        asAppleGrandparentDisc,
    required TResult Function(BananaGrandparentDisc bananaGrandparentDiscValue)
        asBananaGrandparentDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitGrandparentDisc> deserializedModels)
        unknown,
  }) {
    return asBananaGrandparentDisc(bananaGrandparentDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleGrandparentDisc appleGrandparentDiscValue)?
        asAppleGrandparentDisc,
    TResult? Function(BananaGrandparentDisc bananaGrandparentDiscValue)?
        asBananaGrandparentDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitGrandparentDisc> deserializedModels)?
        unknown,
  }) {
    return asBananaGrandparentDisc?.call(bananaGrandparentDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleGrandparentDisc appleGrandparentDiscValue)?
        asAppleGrandparentDisc,
    TResult Function(BananaGrandparentDisc bananaGrandparentDiscValue)?
        asBananaGrandparentDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitGrandparentDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asBananaGrandparentDisc != null) {
      return asBananaGrandparentDisc(bananaGrandparentDiscValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitGrandparentDiscAsAppleGrandparentDisc value)
        asAppleGrandparentDisc,
    required TResult Function(FruitGrandparentDiscAsBananaGrandparentDisc value)
        asBananaGrandparentDisc,
    required TResult Function(FruitGrandparentDiscUnknown value) unknown,
  }) {
    return asBananaGrandparentDisc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitGrandparentDiscAsAppleGrandparentDisc value)?
        asAppleGrandparentDisc,
    TResult? Function(FruitGrandparentDiscAsBananaGrandparentDisc value)?
        asBananaGrandparentDisc,
    TResult? Function(FruitGrandparentDiscUnknown value)? unknown,
  }) {
    return asBananaGrandparentDisc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitGrandparentDiscAsAppleGrandparentDisc value)?
        asAppleGrandparentDisc,
    TResult Function(FruitGrandparentDiscAsBananaGrandparentDisc value)?
        asBananaGrandparentDisc,
    TResult Function(FruitGrandparentDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asBananaGrandparentDisc != null) {
      return asBananaGrandparentDisc(this);
    }
    return orElse();
  }
}

abstract class FruitGrandparentDiscAsBananaGrandparentDisc
    extends FruitGrandparentDisc {
  const factory FruitGrandparentDiscAsBananaGrandparentDisc(
          {required final BananaGrandparentDisc bananaGrandparentDiscValue}) =
      _$FruitGrandparentDiscAsBananaGrandparentDisc;
  const FruitGrandparentDiscAsBananaGrandparentDisc._() : super._();

  BananaGrandparentDisc get bananaGrandparentDiscValue;
  @JsonKey(ignore: true)
  _$$FruitGrandparentDiscAsBananaGrandparentDiscCopyWith<
          _$FruitGrandparentDiscAsBananaGrandparentDisc>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitGrandparentDiscUnknownCopyWith<$Res> {
  factory _$$FruitGrandparentDiscUnknownCopyWith(
          _$FruitGrandparentDiscUnknown value,
          $Res Function(_$FruitGrandparentDiscUnknown) then) =
      __$$FruitGrandparentDiscUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<FruitGrandparentDisc> deserializedModels});
}

/// @nodoc
class __$$FruitGrandparentDiscUnknownCopyWithImpl<$Res>
    extends _$FruitGrandparentDiscCopyWithImpl<$Res,
        _$FruitGrandparentDiscUnknown>
    implements _$$FruitGrandparentDiscUnknownCopyWith<$Res> {
  __$$FruitGrandparentDiscUnknownCopyWithImpl(
      _$FruitGrandparentDiscUnknown _value,
      $Res Function(_$FruitGrandparentDiscUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$FruitGrandparentDiscUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<FruitGrandparentDisc>,
    ));
  }
}

/// @nodoc

class _$FruitGrandparentDiscUnknown extends FruitGrandparentDiscUnknown {
  const _$FruitGrandparentDiscUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        AppleGrandparentDisc,
        BananaGrandparentDisc
      ],
      final List<FruitGrandparentDisc> deserializedModels =
          const <FruitGrandparentDisc>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<FruitGrandparentDisc> _deserializedModels;
  @override
  @JsonKey()
  List<FruitGrandparentDisc> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'FruitGrandparentDisc.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitGrandparentDiscUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitGrandparentDiscUnknownCopyWith<_$FruitGrandparentDiscUnknown>
      get copyWith => __$$FruitGrandparentDiscUnknownCopyWithImpl<
          _$FruitGrandparentDiscUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleGrandparentDisc appleGrandparentDiscValue)
        asAppleGrandparentDisc,
    required TResult Function(BananaGrandparentDisc bananaGrandparentDiscValue)
        asBananaGrandparentDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitGrandparentDisc> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleGrandparentDisc appleGrandparentDiscValue)?
        asAppleGrandparentDisc,
    TResult? Function(BananaGrandparentDisc bananaGrandparentDiscValue)?
        asBananaGrandparentDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitGrandparentDisc> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleGrandparentDisc appleGrandparentDiscValue)?
        asAppleGrandparentDisc,
    TResult Function(BananaGrandparentDisc bananaGrandparentDiscValue)?
        asBananaGrandparentDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitGrandparentDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitGrandparentDiscAsAppleGrandparentDisc value)
        asAppleGrandparentDisc,
    required TResult Function(FruitGrandparentDiscAsBananaGrandparentDisc value)
        asBananaGrandparentDisc,
    required TResult Function(FruitGrandparentDiscUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitGrandparentDiscAsAppleGrandparentDisc value)?
        asAppleGrandparentDisc,
    TResult? Function(FruitGrandparentDiscAsBananaGrandparentDisc value)?
        asBananaGrandparentDisc,
    TResult? Function(FruitGrandparentDiscUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitGrandparentDiscAsAppleGrandparentDisc value)?
        asAppleGrandparentDisc,
    TResult Function(FruitGrandparentDiscAsBananaGrandparentDisc value)?
        asBananaGrandparentDisc,
    TResult Function(FruitGrandparentDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class FruitGrandparentDiscUnknown extends FruitGrandparentDisc {
  const factory FruitGrandparentDiscUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<FruitGrandparentDisc> deserializedModels}) =
      _$FruitGrandparentDiscUnknown;
  const FruitGrandparentDiscUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<FruitGrandparentDisc> get deserializedModels;
  @JsonKey(ignore: true)
  _$$FruitGrandparentDiscUnknownCopyWith<_$FruitGrandparentDiscUnknown>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FruitInlineDisc {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitInlineDiscOneOf fruitInlineDiscOneOfValue)
        asFruitInlineDiscOneOf,
    required TResult Function(FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value)
        asFruitInlineDiscOneOf1,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineDisc> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitInlineDiscOneOf fruitInlineDiscOneOfValue)?
        asFruitInlineDiscOneOf,
    TResult? Function(FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value)?
        asFruitInlineDiscOneOf1,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineDisc> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitInlineDiscOneOf fruitInlineDiscOneOfValue)?
        asFruitInlineDiscOneOf,
    TResult Function(FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value)?
        asFruitInlineDiscOneOf1,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf value)
        asFruitInlineDiscOneOf,
    required TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf1 value)
        asFruitInlineDiscOneOf1,
    required TResult Function(FruitInlineDiscUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitInlineDiscAsFruitInlineDiscOneOf value)?
        asFruitInlineDiscOneOf,
    TResult? Function(FruitInlineDiscAsFruitInlineDiscOneOf1 value)?
        asFruitInlineDiscOneOf1,
    TResult? Function(FruitInlineDiscUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf value)?
        asFruitInlineDiscOneOf,
    TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf1 value)?
        asFruitInlineDiscOneOf1,
    TResult Function(FruitInlineDiscUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitInlineDiscCopyWith<$Res> {
  factory $FruitInlineDiscCopyWith(
          FruitInlineDisc value, $Res Function(FruitInlineDisc) then) =
      _$FruitInlineDiscCopyWithImpl<$Res, FruitInlineDisc>;
}

/// @nodoc
class _$FruitInlineDiscCopyWithImpl<$Res, $Val extends FruitInlineDisc>
    implements $FruitInlineDiscCopyWith<$Res> {
  _$FruitInlineDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FruitInlineDiscAsFruitInlineDiscOneOfCopyWith<$Res> {
  factory _$$FruitInlineDiscAsFruitInlineDiscOneOfCopyWith(
          _$FruitInlineDiscAsFruitInlineDiscOneOf value,
          $Res Function(_$FruitInlineDiscAsFruitInlineDiscOneOf) then) =
      __$$FruitInlineDiscAsFruitInlineDiscOneOfCopyWithImpl<$Res>;
  @useResult
  $Res call({FruitInlineDiscOneOf fruitInlineDiscOneOfValue});

  $FruitInlineDiscOneOfCopyWith<$Res> get fruitInlineDiscOneOfValue;
}

/// @nodoc
class __$$FruitInlineDiscAsFruitInlineDiscOneOfCopyWithImpl<$Res>
    extends _$FruitInlineDiscCopyWithImpl<$Res,
        _$FruitInlineDiscAsFruitInlineDiscOneOf>
    implements _$$FruitInlineDiscAsFruitInlineDiscOneOfCopyWith<$Res> {
  __$$FruitInlineDiscAsFruitInlineDiscOneOfCopyWithImpl(
      _$FruitInlineDiscAsFruitInlineDiscOneOf _value,
      $Res Function(_$FruitInlineDiscAsFruitInlineDiscOneOf) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitInlineDiscOneOfValue = null,
  }) {
    return _then(_$FruitInlineDiscAsFruitInlineDiscOneOf(
      fruitInlineDiscOneOfValue: null == fruitInlineDiscOneOfValue
          ? _value.fruitInlineDiscOneOfValue
          : fruitInlineDiscOneOfValue // ignore: cast_nullable_to_non_nullable
              as FruitInlineDiscOneOf,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitInlineDiscOneOfCopyWith<$Res> get fruitInlineDiscOneOfValue {
    return $FruitInlineDiscOneOfCopyWith<$Res>(_value.fruitInlineDiscOneOfValue,
        (value) {
      return _then(_value.copyWith(fruitInlineDiscOneOfValue: value));
    });
  }
}

/// @nodoc

class _$FruitInlineDiscAsFruitInlineDiscOneOf
    extends FruitInlineDiscAsFruitInlineDiscOneOf {
  const _$FruitInlineDiscAsFruitInlineDiscOneOf(
      {required this.fruitInlineDiscOneOfValue})
      : super._();

  @override
  final FruitInlineDiscOneOf fruitInlineDiscOneOfValue;

  @override
  String toString() {
    return 'FruitInlineDisc.asFruitInlineDiscOneOf(fruitInlineDiscOneOfValue: $fruitInlineDiscOneOfValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitInlineDiscAsFruitInlineDiscOneOf &&
            (identical(other.fruitInlineDiscOneOfValue,
                    fruitInlineDiscOneOfValue) ||
                other.fruitInlineDiscOneOfValue == fruitInlineDiscOneOfValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fruitInlineDiscOneOfValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitInlineDiscAsFruitInlineDiscOneOfCopyWith<
          _$FruitInlineDiscAsFruitInlineDiscOneOf>
      get copyWith => __$$FruitInlineDiscAsFruitInlineDiscOneOfCopyWithImpl<
          _$FruitInlineDiscAsFruitInlineDiscOneOf>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitInlineDiscOneOf fruitInlineDiscOneOfValue)
        asFruitInlineDiscOneOf,
    required TResult Function(FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value)
        asFruitInlineDiscOneOf1,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineDisc> deserializedModels)
        unknown,
  }) {
    return asFruitInlineDiscOneOf(fruitInlineDiscOneOfValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitInlineDiscOneOf fruitInlineDiscOneOfValue)?
        asFruitInlineDiscOneOf,
    TResult? Function(FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value)?
        asFruitInlineDiscOneOf1,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineDisc> deserializedModels)?
        unknown,
  }) {
    return asFruitInlineDiscOneOf?.call(fruitInlineDiscOneOfValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitInlineDiscOneOf fruitInlineDiscOneOfValue)?
        asFruitInlineDiscOneOf,
    TResult Function(FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value)?
        asFruitInlineDiscOneOf1,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFruitInlineDiscOneOf != null) {
      return asFruitInlineDiscOneOf(fruitInlineDiscOneOfValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf value)
        asFruitInlineDiscOneOf,
    required TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf1 value)
        asFruitInlineDiscOneOf1,
    required TResult Function(FruitInlineDiscUnknown value) unknown,
  }) {
    return asFruitInlineDiscOneOf(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitInlineDiscAsFruitInlineDiscOneOf value)?
        asFruitInlineDiscOneOf,
    TResult? Function(FruitInlineDiscAsFruitInlineDiscOneOf1 value)?
        asFruitInlineDiscOneOf1,
    TResult? Function(FruitInlineDiscUnknown value)? unknown,
  }) {
    return asFruitInlineDiscOneOf?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf value)?
        asFruitInlineDiscOneOf,
    TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf1 value)?
        asFruitInlineDiscOneOf1,
    TResult Function(FruitInlineDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFruitInlineDiscOneOf != null) {
      return asFruitInlineDiscOneOf(this);
    }
    return orElse();
  }
}

abstract class FruitInlineDiscAsFruitInlineDiscOneOf extends FruitInlineDisc {
  const factory FruitInlineDiscAsFruitInlineDiscOneOf(
          {required final FruitInlineDiscOneOf fruitInlineDiscOneOfValue}) =
      _$FruitInlineDiscAsFruitInlineDiscOneOf;
  const FruitInlineDiscAsFruitInlineDiscOneOf._() : super._();

  FruitInlineDiscOneOf get fruitInlineDiscOneOfValue;
  @JsonKey(ignore: true)
  _$$FruitInlineDiscAsFruitInlineDiscOneOfCopyWith<
          _$FruitInlineDiscAsFruitInlineDiscOneOf>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitInlineDiscAsFruitInlineDiscOneOf1CopyWith<$Res> {
  factory _$$FruitInlineDiscAsFruitInlineDiscOneOf1CopyWith(
          _$FruitInlineDiscAsFruitInlineDiscOneOf1 value,
          $Res Function(_$FruitInlineDiscAsFruitInlineDiscOneOf1) then) =
      __$$FruitInlineDiscAsFruitInlineDiscOneOf1CopyWithImpl<$Res>;
  @useResult
  $Res call({FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value});

  $FruitInlineDiscOneOf1CopyWith<$Res> get fruitInlineDiscOneOf1Value;
}

/// @nodoc
class __$$FruitInlineDiscAsFruitInlineDiscOneOf1CopyWithImpl<$Res>
    extends _$FruitInlineDiscCopyWithImpl<$Res,
        _$FruitInlineDiscAsFruitInlineDiscOneOf1>
    implements _$$FruitInlineDiscAsFruitInlineDiscOneOf1CopyWith<$Res> {
  __$$FruitInlineDiscAsFruitInlineDiscOneOf1CopyWithImpl(
      _$FruitInlineDiscAsFruitInlineDiscOneOf1 _value,
      $Res Function(_$FruitInlineDiscAsFruitInlineDiscOneOf1) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitInlineDiscOneOf1Value = null,
  }) {
    return _then(_$FruitInlineDiscAsFruitInlineDiscOneOf1(
      fruitInlineDiscOneOf1Value: null == fruitInlineDiscOneOf1Value
          ? _value.fruitInlineDiscOneOf1Value
          : fruitInlineDiscOneOf1Value // ignore: cast_nullable_to_non_nullable
              as FruitInlineDiscOneOf1,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitInlineDiscOneOf1CopyWith<$Res> get fruitInlineDiscOneOf1Value {
    return $FruitInlineDiscOneOf1CopyWith<$Res>(
        _value.fruitInlineDiscOneOf1Value, (value) {
      return _then(_value.copyWith(fruitInlineDiscOneOf1Value: value));
    });
  }
}

/// @nodoc

class _$FruitInlineDiscAsFruitInlineDiscOneOf1
    extends FruitInlineDiscAsFruitInlineDiscOneOf1 {
  const _$FruitInlineDiscAsFruitInlineDiscOneOf1(
      {required this.fruitInlineDiscOneOf1Value})
      : super._();

  @override
  final FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value;

  @override
  String toString() {
    return 'FruitInlineDisc.asFruitInlineDiscOneOf1(fruitInlineDiscOneOf1Value: $fruitInlineDiscOneOf1Value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitInlineDiscAsFruitInlineDiscOneOf1 &&
            (identical(other.fruitInlineDiscOneOf1Value,
                    fruitInlineDiscOneOf1Value) ||
                other.fruitInlineDiscOneOf1Value ==
                    fruitInlineDiscOneOf1Value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fruitInlineDiscOneOf1Value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitInlineDiscAsFruitInlineDiscOneOf1CopyWith<
          _$FruitInlineDiscAsFruitInlineDiscOneOf1>
      get copyWith => __$$FruitInlineDiscAsFruitInlineDiscOneOf1CopyWithImpl<
          _$FruitInlineDiscAsFruitInlineDiscOneOf1>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitInlineDiscOneOf fruitInlineDiscOneOfValue)
        asFruitInlineDiscOneOf,
    required TResult Function(FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value)
        asFruitInlineDiscOneOf1,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineDisc> deserializedModels)
        unknown,
  }) {
    return asFruitInlineDiscOneOf1(fruitInlineDiscOneOf1Value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitInlineDiscOneOf fruitInlineDiscOneOfValue)?
        asFruitInlineDiscOneOf,
    TResult? Function(FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value)?
        asFruitInlineDiscOneOf1,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineDisc> deserializedModels)?
        unknown,
  }) {
    return asFruitInlineDiscOneOf1?.call(fruitInlineDiscOneOf1Value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitInlineDiscOneOf fruitInlineDiscOneOfValue)?
        asFruitInlineDiscOneOf,
    TResult Function(FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value)?
        asFruitInlineDiscOneOf1,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFruitInlineDiscOneOf1 != null) {
      return asFruitInlineDiscOneOf1(fruitInlineDiscOneOf1Value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf value)
        asFruitInlineDiscOneOf,
    required TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf1 value)
        asFruitInlineDiscOneOf1,
    required TResult Function(FruitInlineDiscUnknown value) unknown,
  }) {
    return asFruitInlineDiscOneOf1(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitInlineDiscAsFruitInlineDiscOneOf value)?
        asFruitInlineDiscOneOf,
    TResult? Function(FruitInlineDiscAsFruitInlineDiscOneOf1 value)?
        asFruitInlineDiscOneOf1,
    TResult? Function(FruitInlineDiscUnknown value)? unknown,
  }) {
    return asFruitInlineDiscOneOf1?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf value)?
        asFruitInlineDiscOneOf,
    TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf1 value)?
        asFruitInlineDiscOneOf1,
    TResult Function(FruitInlineDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFruitInlineDiscOneOf1 != null) {
      return asFruitInlineDiscOneOf1(this);
    }
    return orElse();
  }
}

abstract class FruitInlineDiscAsFruitInlineDiscOneOf1 extends FruitInlineDisc {
  const factory FruitInlineDiscAsFruitInlineDiscOneOf1(
          {required final FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value}) =
      _$FruitInlineDiscAsFruitInlineDiscOneOf1;
  const FruitInlineDiscAsFruitInlineDiscOneOf1._() : super._();

  FruitInlineDiscOneOf1 get fruitInlineDiscOneOf1Value;
  @JsonKey(ignore: true)
  _$$FruitInlineDiscAsFruitInlineDiscOneOf1CopyWith<
          _$FruitInlineDiscAsFruitInlineDiscOneOf1>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitInlineDiscUnknownCopyWith<$Res> {
  factory _$$FruitInlineDiscUnknownCopyWith(_$FruitInlineDiscUnknown value,
          $Res Function(_$FruitInlineDiscUnknown) then) =
      __$$FruitInlineDiscUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<FruitInlineDisc> deserializedModels});
}

/// @nodoc
class __$$FruitInlineDiscUnknownCopyWithImpl<$Res>
    extends _$FruitInlineDiscCopyWithImpl<$Res, _$FruitInlineDiscUnknown>
    implements _$$FruitInlineDiscUnknownCopyWith<$Res> {
  __$$FruitInlineDiscUnknownCopyWithImpl(_$FruitInlineDiscUnknown _value,
      $Res Function(_$FruitInlineDiscUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$FruitInlineDiscUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<FruitInlineDisc>,
    ));
  }
}

/// @nodoc

class _$FruitInlineDiscUnknown extends FruitInlineDiscUnknown {
  const _$FruitInlineDiscUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        FruitInlineDiscOneOf,
        FruitInlineDiscOneOf1
      ],
      final List<FruitInlineDisc> deserializedModels =
          const <FruitInlineDisc>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<FruitInlineDisc> _deserializedModels;
  @override
  @JsonKey()
  List<FruitInlineDisc> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'FruitInlineDisc.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitInlineDiscUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitInlineDiscUnknownCopyWith<_$FruitInlineDiscUnknown> get copyWith =>
      __$$FruitInlineDiscUnknownCopyWithImpl<_$FruitInlineDiscUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FruitInlineDiscOneOf fruitInlineDiscOneOfValue)
        asFruitInlineDiscOneOf,
    required TResult Function(FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value)
        asFruitInlineDiscOneOf1,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineDisc> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FruitInlineDiscOneOf fruitInlineDiscOneOfValue)?
        asFruitInlineDiscOneOf,
    TResult? Function(FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value)?
        asFruitInlineDiscOneOf1,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineDisc> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FruitInlineDiscOneOf fruitInlineDiscOneOfValue)?
        asFruitInlineDiscOneOf,
    TResult Function(FruitInlineDiscOneOf1 fruitInlineDiscOneOf1Value)?
        asFruitInlineDiscOneOf1,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf value)
        asFruitInlineDiscOneOf,
    required TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf1 value)
        asFruitInlineDiscOneOf1,
    required TResult Function(FruitInlineDiscUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitInlineDiscAsFruitInlineDiscOneOf value)?
        asFruitInlineDiscOneOf,
    TResult? Function(FruitInlineDiscAsFruitInlineDiscOneOf1 value)?
        asFruitInlineDiscOneOf1,
    TResult? Function(FruitInlineDiscUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf value)?
        asFruitInlineDiscOneOf,
    TResult Function(FruitInlineDiscAsFruitInlineDiscOneOf1 value)?
        asFruitInlineDiscOneOf1,
    TResult Function(FruitInlineDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class FruitInlineDiscUnknown extends FruitInlineDisc {
  const factory FruitInlineDiscUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<FruitInlineDisc> deserializedModels}) =
      _$FruitInlineDiscUnknown;
  const FruitInlineDiscUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<FruitInlineDisc> get deserializedModels;
  @JsonKey(ignore: true)
  _$$FruitInlineDiscUnknownCopyWith<_$FruitInlineDiscUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

FruitInlineDiscOneOf _$FruitInlineDiscOneOfFromJson(Map<String, dynamic> json) {
  return _FruitInlineDiscOneOf.fromJson(json);
}

/// @nodoc
mixin _$FruitInlineDiscOneOf {
  @JsonKey(name: r'seeds')
  int get seeds => throw _privateConstructorUsedError;
  @JsonKey(name: r'fruitType')
  String get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FruitInlineDiscOneOfCopyWith<FruitInlineDiscOneOf> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitInlineDiscOneOfCopyWith<$Res> {
  factory $FruitInlineDiscOneOfCopyWith(FruitInlineDiscOneOf value,
          $Res Function(FruitInlineDiscOneOf) then) =
      _$FruitInlineDiscOneOfCopyWithImpl<$Res, FruitInlineDiscOneOf>;
  @useResult
  $Res call(
      {@JsonKey(name: r'seeds') int seeds,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class _$FruitInlineDiscOneOfCopyWithImpl<$Res,
        $Val extends FruitInlineDiscOneOf>
    implements $FruitInlineDiscOneOfCopyWith<$Res> {
  _$FruitInlineDiscOneOfCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? seeds = null,
    Object? fruitType = null,
  }) {
    return _then(_value.copyWith(
      seeds: null == seeds
          ? _value.seeds
          : seeds // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FruitInlineDiscOneOfCopyWith<$Res>
    implements $FruitInlineDiscOneOfCopyWith<$Res> {
  factory _$$_FruitInlineDiscOneOfCopyWith(_$_FruitInlineDiscOneOf value,
          $Res Function(_$_FruitInlineDiscOneOf) then) =
      __$$_FruitInlineDiscOneOfCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'seeds') int seeds,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class __$$_FruitInlineDiscOneOfCopyWithImpl<$Res>
    extends _$FruitInlineDiscOneOfCopyWithImpl<$Res, _$_FruitInlineDiscOneOf>
    implements _$$_FruitInlineDiscOneOfCopyWith<$Res> {
  __$$_FruitInlineDiscOneOfCopyWithImpl(_$_FruitInlineDiscOneOf _value,
      $Res Function(_$_FruitInlineDiscOneOf) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? seeds = null,
    Object? fruitType = null,
  }) {
    return _then(_$_FruitInlineDiscOneOf(
      seeds: null == seeds
          ? _value.seeds
          : seeds // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FruitInlineDiscOneOf extends _FruitInlineDiscOneOf {
  const _$_FruitInlineDiscOneOf(
      {@JsonKey(name: r'seeds') required this.seeds,
      @JsonKey(name: r'fruitType') required this.fruitType})
      : super._();

  factory _$_FruitInlineDiscOneOf.fromJson(Map<String, dynamic> json) =>
      _$$_FruitInlineDiscOneOfFromJson(json);

  @override
  @JsonKey(name: r'seeds')
  final int seeds;
  @override
  @JsonKey(name: r'fruitType')
  final String fruitType;

  @override
  String toString() {
    return 'FruitInlineDiscOneOf(seeds: $seeds, fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FruitInlineDiscOneOf &&
            (identical(other.seeds, seeds) || other.seeds == seeds) &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, seeds, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FruitInlineDiscOneOfCopyWith<_$_FruitInlineDiscOneOf> get copyWith =>
      __$$_FruitInlineDiscOneOfCopyWithImpl<_$_FruitInlineDiscOneOf>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FruitInlineDiscOneOfToJson(
      this,
    );
  }
}

abstract class _FruitInlineDiscOneOf extends FruitInlineDiscOneOf {
  const factory _FruitInlineDiscOneOf(
          {@JsonKey(name: r'seeds') required final int seeds,
          @JsonKey(name: r'fruitType') required final String fruitType}) =
      _$_FruitInlineDiscOneOf;
  const _FruitInlineDiscOneOf._() : super._();

  factory _FruitInlineDiscOneOf.fromJson(Map<String, dynamic> json) =
      _$_FruitInlineDiscOneOf.fromJson;

  @override
  @JsonKey(name: r'seeds')
  int get seeds;
  @override
  @JsonKey(name: r'fruitType')
  String get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_FruitInlineDiscOneOfCopyWith<_$_FruitInlineDiscOneOf> get copyWith =>
      throw _privateConstructorUsedError;
}

FruitInlineDiscOneOf1 _$FruitInlineDiscOneOf1FromJson(
    Map<String, dynamic> json) {
  return _FruitInlineDiscOneOf1.fromJson(json);
}

/// @nodoc
mixin _$FruitInlineDiscOneOf1 {
  @JsonKey(name: r'length')
  int get length => throw _privateConstructorUsedError;
  @JsonKey(name: r'fruitType')
  String get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FruitInlineDiscOneOf1CopyWith<FruitInlineDiscOneOf1> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitInlineDiscOneOf1CopyWith<$Res> {
  factory $FruitInlineDiscOneOf1CopyWith(FruitInlineDiscOneOf1 value,
          $Res Function(FruitInlineDiscOneOf1) then) =
      _$FruitInlineDiscOneOf1CopyWithImpl<$Res, FruitInlineDiscOneOf1>;
  @useResult
  $Res call(
      {@JsonKey(name: r'length') int length,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class _$FruitInlineDiscOneOf1CopyWithImpl<$Res,
        $Val extends FruitInlineDiscOneOf1>
    implements $FruitInlineDiscOneOf1CopyWith<$Res> {
  _$FruitInlineDiscOneOf1CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = null,
    Object? fruitType = null,
  }) {
    return _then(_value.copyWith(
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FruitInlineDiscOneOf1CopyWith<$Res>
    implements $FruitInlineDiscOneOf1CopyWith<$Res> {
  factory _$$_FruitInlineDiscOneOf1CopyWith(_$_FruitInlineDiscOneOf1 value,
          $Res Function(_$_FruitInlineDiscOneOf1) then) =
      __$$_FruitInlineDiscOneOf1CopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: r'length') int length,
      @JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class __$$_FruitInlineDiscOneOf1CopyWithImpl<$Res>
    extends _$FruitInlineDiscOneOf1CopyWithImpl<$Res, _$_FruitInlineDiscOneOf1>
    implements _$$_FruitInlineDiscOneOf1CopyWith<$Res> {
  __$$_FruitInlineDiscOneOf1CopyWithImpl(_$_FruitInlineDiscOneOf1 _value,
      $Res Function(_$_FruitInlineDiscOneOf1) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = null,
    Object? fruitType = null,
  }) {
    return _then(_$_FruitInlineDiscOneOf1(
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FruitInlineDiscOneOf1 extends _FruitInlineDiscOneOf1 {
  const _$_FruitInlineDiscOneOf1(
      {@JsonKey(name: r'length') required this.length,
      @JsonKey(name: r'fruitType') required this.fruitType})
      : super._();

  factory _$_FruitInlineDiscOneOf1.fromJson(Map<String, dynamic> json) =>
      _$$_FruitInlineDiscOneOf1FromJson(json);

  @override
  @JsonKey(name: r'length')
  final int length;
  @override
  @JsonKey(name: r'fruitType')
  final String fruitType;

  @override
  String toString() {
    return 'FruitInlineDiscOneOf1(length: $length, fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FruitInlineDiscOneOf1 &&
            (identical(other.length, length) || other.length == length) &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, length, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FruitInlineDiscOneOf1CopyWith<_$_FruitInlineDiscOneOf1> get copyWith =>
      __$$_FruitInlineDiscOneOf1CopyWithImpl<_$_FruitInlineDiscOneOf1>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FruitInlineDiscOneOf1ToJson(
      this,
    );
  }
}

abstract class _FruitInlineDiscOneOf1 extends FruitInlineDiscOneOf1 {
  const factory _FruitInlineDiscOneOf1(
          {@JsonKey(name: r'length') required final int length,
          @JsonKey(name: r'fruitType') required final String fruitType}) =
      _$_FruitInlineDiscOneOf1;
  const _FruitInlineDiscOneOf1._() : super._();

  factory _FruitInlineDiscOneOf1.fromJson(Map<String, dynamic> json) =
      _$_FruitInlineDiscOneOf1.fromJson;

  @override
  @JsonKey(name: r'length')
  int get length;
  @override
  @JsonKey(name: r'fruitType')
  String get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_FruitInlineDiscOneOf1CopyWith<_$_FruitInlineDiscOneOf1> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FruitInlineInlineDisc {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue)
        asFruitInlineInlineDiscOneOf,
    required TResult Function(
            FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value)
        asFruitInlineInlineDiscOneOf1,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDisc> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue)?
        asFruitInlineInlineDiscOneOf,
    TResult? Function(
            FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value)?
        asFruitInlineInlineDiscOneOf1,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDisc> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue)?
        asFruitInlineInlineDiscOneOf,
    TResult Function(
            FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value)?
        asFruitInlineInlineDiscOneOf1,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value)
        asFruitInlineInlineDiscOneOf,
    required TResult Function(
            FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value)
        asFruitInlineInlineDiscOneOf1,
    required TResult Function(FruitInlineInlineDiscUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value)?
        asFruitInlineInlineDiscOneOf,
    TResult? Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value)?
        asFruitInlineInlineDiscOneOf1,
    TResult? Function(FruitInlineInlineDiscUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value)?
        asFruitInlineInlineDiscOneOf,
    TResult Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value)?
        asFruitInlineInlineDiscOneOf1,
    TResult Function(FruitInlineInlineDiscUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitInlineInlineDiscCopyWith<$Res> {
  factory $FruitInlineInlineDiscCopyWith(FruitInlineInlineDisc value,
          $Res Function(FruitInlineInlineDisc) then) =
      _$FruitInlineInlineDiscCopyWithImpl<$Res, FruitInlineInlineDisc>;
}

/// @nodoc
class _$FruitInlineInlineDiscCopyWithImpl<$Res,
        $Val extends FruitInlineInlineDisc>
    implements $FruitInlineInlineDiscCopyWith<$Res> {
  _$FruitInlineInlineDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOfCopyWith<
    $Res> {
  factory _$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOfCopyWith(
          _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value,
          $Res Function(_$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf)
              then) =
      __$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOfCopyWithImpl<$Res>;
  @useResult
  $Res call({FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue});

  $FruitInlineInlineDiscOneOfCopyWith<$Res> get fruitInlineInlineDiscOneOfValue;
}

/// @nodoc
class __$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOfCopyWithImpl<$Res>
    extends _$FruitInlineInlineDiscCopyWithImpl<$Res,
        _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf>
    implements
        _$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOfCopyWith<$Res> {
  __$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOfCopyWithImpl(
      _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf _value,
      $Res Function(_$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitInlineInlineDiscOneOfValue = null,
  }) {
    return _then(_$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf(
      fruitInlineInlineDiscOneOfValue: null == fruitInlineInlineDiscOneOfValue
          ? _value.fruitInlineInlineDiscOneOfValue
          : fruitInlineInlineDiscOneOfValue // ignore: cast_nullable_to_non_nullable
              as FruitInlineInlineDiscOneOf,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitInlineInlineDiscOneOfCopyWith<$Res>
      get fruitInlineInlineDiscOneOfValue {
    return $FruitInlineInlineDiscOneOfCopyWith<$Res>(
        _value.fruitInlineInlineDiscOneOfValue, (value) {
      return _then(_value.copyWith(fruitInlineInlineDiscOneOfValue: value));
    });
  }
}

/// @nodoc

class _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf
    extends FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf {
  const _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf(
      {required this.fruitInlineInlineDiscOneOfValue})
      : super._();

  @override
  final FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue;

  @override
  String toString() {
    return 'FruitInlineInlineDisc.asFruitInlineInlineDiscOneOf(fruitInlineInlineDiscOneOfValue: $fruitInlineInlineDiscOneOfValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf &&
            (identical(other.fruitInlineInlineDiscOneOfValue,
                    fruitInlineInlineDiscOneOfValue) ||
                other.fruitInlineInlineDiscOneOfValue ==
                    fruitInlineInlineDiscOneOfValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fruitInlineInlineDiscOneOfValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOfCopyWith<
          _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf>
      get copyWith =>
          __$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOfCopyWithImpl<
                  _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue)
        asFruitInlineInlineDiscOneOf,
    required TResult Function(
            FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value)
        asFruitInlineInlineDiscOneOf1,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDisc> deserializedModels)
        unknown,
  }) {
    return asFruitInlineInlineDiscOneOf(fruitInlineInlineDiscOneOfValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue)?
        asFruitInlineInlineDiscOneOf,
    TResult? Function(
            FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value)?
        asFruitInlineInlineDiscOneOf1,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDisc> deserializedModels)?
        unknown,
  }) {
    return asFruitInlineInlineDiscOneOf?.call(fruitInlineInlineDiscOneOfValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue)?
        asFruitInlineInlineDiscOneOf,
    TResult Function(
            FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value)?
        asFruitInlineInlineDiscOneOf1,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFruitInlineInlineDiscOneOf != null) {
      return asFruitInlineInlineDiscOneOf(fruitInlineInlineDiscOneOfValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value)
        asFruitInlineInlineDiscOneOf,
    required TResult Function(
            FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value)
        asFruitInlineInlineDiscOneOf1,
    required TResult Function(FruitInlineInlineDiscUnknown value) unknown,
  }) {
    return asFruitInlineInlineDiscOneOf(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value)?
        asFruitInlineInlineDiscOneOf,
    TResult? Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value)?
        asFruitInlineInlineDiscOneOf1,
    TResult? Function(FruitInlineInlineDiscUnknown value)? unknown,
  }) {
    return asFruitInlineInlineDiscOneOf?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value)?
        asFruitInlineInlineDiscOneOf,
    TResult Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value)?
        asFruitInlineInlineDiscOneOf1,
    TResult Function(FruitInlineInlineDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFruitInlineInlineDiscOneOf != null) {
      return asFruitInlineInlineDiscOneOf(this);
    }
    return orElse();
  }
}

abstract class FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf
    extends FruitInlineInlineDisc {
  const factory FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf(
          {required final FruitInlineInlineDiscOneOf
              fruitInlineInlineDiscOneOfValue}) =
      _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf;
  const FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf._() : super._();

  FruitInlineInlineDiscOneOf get fruitInlineInlineDiscOneOfValue;
  @JsonKey(ignore: true)
  _$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOfCopyWith<
          _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1CopyWith<
    $Res> {
  factory _$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1CopyWith(
          _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value,
          $Res Function(_$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1)
              then) =
      __$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1CopyWithImpl<$Res>;
  @useResult
  $Res call({FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value});

  $FruitInlineInlineDiscOneOf1CopyWith<$Res>
      get fruitInlineInlineDiscOneOf1Value;
}

/// @nodoc
class __$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1CopyWithImpl<$Res>
    extends _$FruitInlineInlineDiscCopyWithImpl<$Res,
        _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1>
    implements
        _$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1CopyWith<$Res> {
  __$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1CopyWithImpl(
      _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 _value,
      $Res Function(_$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitInlineInlineDiscOneOf1Value = null,
  }) {
    return _then(_$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1(
      fruitInlineInlineDiscOneOf1Value: null == fruitInlineInlineDiscOneOf1Value
          ? _value.fruitInlineInlineDiscOneOf1Value
          : fruitInlineInlineDiscOneOf1Value // ignore: cast_nullable_to_non_nullable
              as FruitInlineInlineDiscOneOf1,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitInlineInlineDiscOneOf1CopyWith<$Res>
      get fruitInlineInlineDiscOneOf1Value {
    return $FruitInlineInlineDiscOneOf1CopyWith<$Res>(
        _value.fruitInlineInlineDiscOneOf1Value, (value) {
      return _then(_value.copyWith(fruitInlineInlineDiscOneOf1Value: value));
    });
  }
}

/// @nodoc

class _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1
    extends FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 {
  const _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1(
      {required this.fruitInlineInlineDiscOneOf1Value})
      : super._();

  @override
  final FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value;

  @override
  String toString() {
    return 'FruitInlineInlineDisc.asFruitInlineInlineDiscOneOf1(fruitInlineInlineDiscOneOf1Value: $fruitInlineInlineDiscOneOf1Value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 &&
            (identical(other.fruitInlineInlineDiscOneOf1Value,
                    fruitInlineInlineDiscOneOf1Value) ||
                other.fruitInlineInlineDiscOneOf1Value ==
                    fruitInlineInlineDiscOneOf1Value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, fruitInlineInlineDiscOneOf1Value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1CopyWith<
          _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1>
      get copyWith =>
          __$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1CopyWithImpl<
                  _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue)
        asFruitInlineInlineDiscOneOf,
    required TResult Function(
            FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value)
        asFruitInlineInlineDiscOneOf1,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDisc> deserializedModels)
        unknown,
  }) {
    return asFruitInlineInlineDiscOneOf1(fruitInlineInlineDiscOneOf1Value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue)?
        asFruitInlineInlineDiscOneOf,
    TResult? Function(
            FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value)?
        asFruitInlineInlineDiscOneOf1,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDisc> deserializedModels)?
        unknown,
  }) {
    return asFruitInlineInlineDiscOneOf1
        ?.call(fruitInlineInlineDiscOneOf1Value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue)?
        asFruitInlineInlineDiscOneOf,
    TResult Function(
            FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value)?
        asFruitInlineInlineDiscOneOf1,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFruitInlineInlineDiscOneOf1 != null) {
      return asFruitInlineInlineDiscOneOf1(fruitInlineInlineDiscOneOf1Value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value)
        asFruitInlineInlineDiscOneOf,
    required TResult Function(
            FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value)
        asFruitInlineInlineDiscOneOf1,
    required TResult Function(FruitInlineInlineDiscUnknown value) unknown,
  }) {
    return asFruitInlineInlineDiscOneOf1(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value)?
        asFruitInlineInlineDiscOneOf,
    TResult? Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value)?
        asFruitInlineInlineDiscOneOf1,
    TResult? Function(FruitInlineInlineDiscUnknown value)? unknown,
  }) {
    return asFruitInlineInlineDiscOneOf1?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value)?
        asFruitInlineInlineDiscOneOf,
    TResult Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value)?
        asFruitInlineInlineDiscOneOf1,
    TResult Function(FruitInlineInlineDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFruitInlineInlineDiscOneOf1 != null) {
      return asFruitInlineInlineDiscOneOf1(this);
    }
    return orElse();
  }
}

abstract class FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1
    extends FruitInlineInlineDisc {
  const factory FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1(
          {required final FruitInlineInlineDiscOneOf1
              fruitInlineInlineDiscOneOf1Value}) =
      _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1;
  const FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1._() : super._();

  FruitInlineInlineDiscOneOf1 get fruitInlineInlineDiscOneOf1Value;
  @JsonKey(ignore: true)
  _$$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1CopyWith<
          _$FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitInlineInlineDiscUnknownCopyWith<$Res> {
  factory _$$FruitInlineInlineDiscUnknownCopyWith(
          _$FruitInlineInlineDiscUnknown value,
          $Res Function(_$FruitInlineInlineDiscUnknown) then) =
      __$$FruitInlineInlineDiscUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<FruitInlineInlineDisc> deserializedModels});
}

/// @nodoc
class __$$FruitInlineInlineDiscUnknownCopyWithImpl<$Res>
    extends _$FruitInlineInlineDiscCopyWithImpl<$Res,
        _$FruitInlineInlineDiscUnknown>
    implements _$$FruitInlineInlineDiscUnknownCopyWith<$Res> {
  __$$FruitInlineInlineDiscUnknownCopyWithImpl(
      _$FruitInlineInlineDiscUnknown _value,
      $Res Function(_$FruitInlineInlineDiscUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$FruitInlineInlineDiscUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<FruitInlineInlineDisc>,
    ));
  }
}

/// @nodoc

class _$FruitInlineInlineDiscUnknown extends FruitInlineInlineDiscUnknown {
  const _$FruitInlineInlineDiscUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        FruitInlineInlineDiscOneOf,
        FruitInlineInlineDiscOneOf1
      ],
      final List<FruitInlineInlineDisc> deserializedModels =
          const <FruitInlineInlineDisc>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<FruitInlineInlineDisc> _deserializedModels;
  @override
  @JsonKey()
  List<FruitInlineInlineDisc> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'FruitInlineInlineDisc.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitInlineInlineDiscUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitInlineInlineDiscUnknownCopyWith<_$FruitInlineInlineDiscUnknown>
      get copyWith => __$$FruitInlineInlineDiscUnknownCopyWithImpl<
          _$FruitInlineInlineDiscUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue)
        asFruitInlineInlineDiscOneOf,
    required TResult Function(
            FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value)
        asFruitInlineInlineDiscOneOf1,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDisc> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue)?
        asFruitInlineInlineDiscOneOf,
    TResult? Function(
            FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value)?
        asFruitInlineInlineDiscOneOf1,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDisc> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOf fruitInlineInlineDiscOneOfValue)?
        asFruitInlineInlineDiscOneOf,
    TResult Function(
            FruitInlineInlineDiscOneOf1 fruitInlineInlineDiscOneOf1Value)?
        asFruitInlineInlineDiscOneOf1,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value)
        asFruitInlineInlineDiscOneOf,
    required TResult Function(
            FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value)
        asFruitInlineInlineDiscOneOf1,
    required TResult Function(FruitInlineInlineDiscUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value)?
        asFruitInlineInlineDiscOneOf,
    TResult? Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value)?
        asFruitInlineInlineDiscOneOf1,
    TResult? Function(FruitInlineInlineDiscUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf value)?
        asFruitInlineInlineDiscOneOf,
    TResult Function(FruitInlineInlineDiscAsFruitInlineInlineDiscOneOf1 value)?
        asFruitInlineInlineDiscOneOf1,
    TResult Function(FruitInlineInlineDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class FruitInlineInlineDiscUnknown extends FruitInlineInlineDisc {
  const factory FruitInlineInlineDiscUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<FruitInlineInlineDisc> deserializedModels}) =
      _$FruitInlineInlineDiscUnknown;
  const FruitInlineInlineDiscUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<FruitInlineInlineDisc> get deserializedModels;
  @JsonKey(ignore: true)
  _$$FruitInlineInlineDiscUnknownCopyWith<_$FruitInlineInlineDiscUnknown>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FruitInlineInlineDiscOneOf {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)
        asFruitInlineInlineDiscOneOfOneOf,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf value)
        asFruitInlineInlineDiscOneOfOneOf,
    required TResult Function(FruitInlineInlineDiscOneOfUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf value)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult? Function(FruitInlineInlineDiscOneOfUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf value)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult Function(FruitInlineInlineDiscOneOfUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitInlineInlineDiscOneOfCopyWith<$Res> {
  factory $FruitInlineInlineDiscOneOfCopyWith(FruitInlineInlineDiscOneOf value,
          $Res Function(FruitInlineInlineDiscOneOf) then) =
      _$FruitInlineInlineDiscOneOfCopyWithImpl<$Res,
          FruitInlineInlineDiscOneOf>;
}

/// @nodoc
class _$FruitInlineInlineDiscOneOfCopyWithImpl<$Res,
        $Val extends FruitInlineInlineDiscOneOf>
    implements $FruitInlineInlineDiscOneOfCopyWith<$Res> {
  _$FruitInlineInlineDiscOneOfCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOfCopyWith<
    $Res> {
  factory _$$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOfCopyWith(
          _$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf value,
          $Res Function(
                  _$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf)
              then) =
      __$$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOfCopyWithImpl<
          $Res>;
  @useResult
  $Res call(
      {FruitInlineInlineDiscOneOfOneOf fruitInlineInlineDiscOneOfOneOfValue});

  $FruitInlineInlineDiscOneOfOneOfCopyWith<$Res>
      get fruitInlineInlineDiscOneOfOneOfValue;
}

/// @nodoc
class __$$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOfCopyWithImpl<
        $Res>
    extends _$FruitInlineInlineDiscOneOfCopyWithImpl<$Res,
        _$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf>
    implements
        _$$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOfCopyWith<
            $Res> {
  __$$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOfCopyWithImpl(
      _$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf _value,
      $Res Function(
              _$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitInlineInlineDiscOneOfOneOfValue = null,
  }) {
    return _then(_$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf(
      fruitInlineInlineDiscOneOfOneOfValue: null ==
              fruitInlineInlineDiscOneOfOneOfValue
          ? _value.fruitInlineInlineDiscOneOfOneOfValue
          : fruitInlineInlineDiscOneOfOneOfValue // ignore: cast_nullable_to_non_nullable
              as FruitInlineInlineDiscOneOfOneOf,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitInlineInlineDiscOneOfOneOfCopyWith<$Res>
      get fruitInlineInlineDiscOneOfOneOfValue {
    return $FruitInlineInlineDiscOneOfOneOfCopyWith<$Res>(
        _value.fruitInlineInlineDiscOneOfOneOfValue, (value) {
      return _then(
          _value.copyWith(fruitInlineInlineDiscOneOfOneOfValue: value));
    });
  }
}

/// @nodoc

class _$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf
    extends FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf {
  const _$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf(
      {required this.fruitInlineInlineDiscOneOfOneOfValue})
      : super._();

  @override
  final FruitInlineInlineDiscOneOfOneOf fruitInlineInlineDiscOneOfOneOfValue;

  @override
  String toString() {
    return 'FruitInlineInlineDiscOneOf.asFruitInlineInlineDiscOneOfOneOf(fruitInlineInlineDiscOneOfOneOfValue: $fruitInlineInlineDiscOneOfOneOfValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf &&
            (identical(other.fruitInlineInlineDiscOneOfOneOfValue,
                    fruitInlineInlineDiscOneOfOneOfValue) ||
                other.fruitInlineInlineDiscOneOfOneOfValue ==
                    fruitInlineInlineDiscOneOfOneOfValue));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, fruitInlineInlineDiscOneOfOneOfValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOfCopyWith<
          _$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf>
      get copyWith =>
          __$$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOfCopyWithImpl<
                  _$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)
        asFruitInlineInlineDiscOneOfOneOf,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf> deserializedModels)
        unknown,
  }) {
    return asFruitInlineInlineDiscOneOfOneOf(
        fruitInlineInlineDiscOneOfOneOfValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf> deserializedModels)?
        unknown,
  }) {
    return asFruitInlineInlineDiscOneOfOneOf
        ?.call(fruitInlineInlineDiscOneOfOneOfValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFruitInlineInlineDiscOneOfOneOf != null) {
      return asFruitInlineInlineDiscOneOfOneOf(
          fruitInlineInlineDiscOneOfOneOfValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf value)
        asFruitInlineInlineDiscOneOfOneOf,
    required TResult Function(FruitInlineInlineDiscOneOfUnknown value) unknown,
  }) {
    return asFruitInlineInlineDiscOneOfOneOf(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf value)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult? Function(FruitInlineInlineDiscOneOfUnknown value)? unknown,
  }) {
    return asFruitInlineInlineDiscOneOfOneOf?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf value)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult Function(FruitInlineInlineDiscOneOfUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFruitInlineInlineDiscOneOfOneOf != null) {
      return asFruitInlineInlineDiscOneOfOneOf(this);
    }
    return orElse();
  }
}

abstract class FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf
    extends FruitInlineInlineDiscOneOf {
  const factory FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf(
          {required final FruitInlineInlineDiscOneOfOneOf
              fruitInlineInlineDiscOneOfOneOfValue}) =
      _$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf;
  const FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf._()
      : super._();

  FruitInlineInlineDiscOneOfOneOf get fruitInlineInlineDiscOneOfOneOfValue;
  @JsonKey(ignore: true)
  _$$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOfCopyWith<
          _$FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitInlineInlineDiscOneOfUnknownCopyWith<$Res> {
  factory _$$FruitInlineInlineDiscOneOfUnknownCopyWith(
          _$FruitInlineInlineDiscOneOfUnknown value,
          $Res Function(_$FruitInlineInlineDiscOneOfUnknown) then) =
      __$$FruitInlineInlineDiscOneOfUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<FruitInlineInlineDiscOneOf> deserializedModels});
}

/// @nodoc
class __$$FruitInlineInlineDiscOneOfUnknownCopyWithImpl<$Res>
    extends _$FruitInlineInlineDiscOneOfCopyWithImpl<$Res,
        _$FruitInlineInlineDiscOneOfUnknown>
    implements _$$FruitInlineInlineDiscOneOfUnknownCopyWith<$Res> {
  __$$FruitInlineInlineDiscOneOfUnknownCopyWithImpl(
      _$FruitInlineInlineDiscOneOfUnknown _value,
      $Res Function(_$FruitInlineInlineDiscOneOfUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$FruitInlineInlineDiscOneOfUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<FruitInlineInlineDiscOneOf>,
    ));
  }
}

/// @nodoc

class _$FruitInlineInlineDiscOneOfUnknown
    extends FruitInlineInlineDiscOneOfUnknown {
  const _$FruitInlineInlineDiscOneOfUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        FruitInlineInlineDiscOneOfOneOf
      ],
      final List<FruitInlineInlineDiscOneOf> deserializedModels =
          const <FruitInlineInlineDiscOneOf>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<FruitInlineInlineDiscOneOf> _deserializedModels;
  @override
  @JsonKey()
  List<FruitInlineInlineDiscOneOf> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'FruitInlineInlineDiscOneOf.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitInlineInlineDiscOneOfUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitInlineInlineDiscOneOfUnknownCopyWith<
          _$FruitInlineInlineDiscOneOfUnknown>
      get copyWith => __$$FruitInlineInlineDiscOneOfUnknownCopyWithImpl<
          _$FruitInlineInlineDiscOneOfUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)
        asFruitInlineInlineDiscOneOfOneOf,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf value)
        asFruitInlineInlineDiscOneOfOneOf,
    required TResult Function(FruitInlineInlineDiscOneOfUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf value)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult? Function(FruitInlineInlineDiscOneOfUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOfAsFruitInlineInlineDiscOneOfOneOf value)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult Function(FruitInlineInlineDiscOneOfUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class FruitInlineInlineDiscOneOfUnknown
    extends FruitInlineInlineDiscOneOf {
  const factory FruitInlineInlineDiscOneOfUnknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<FruitInlineInlineDiscOneOf> deserializedModels}) =
      _$FruitInlineInlineDiscOneOfUnknown;
  const FruitInlineInlineDiscOneOfUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<FruitInlineInlineDiscOneOf> get deserializedModels;
  @JsonKey(ignore: true)
  _$$FruitInlineInlineDiscOneOfUnknownCopyWith<
          _$FruitInlineInlineDiscOneOfUnknown>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FruitInlineInlineDiscOneOf1 {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)
        asFruitInlineInlineDiscOneOfOneOf,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf1> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf1> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf1> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf value)
        asFruitInlineInlineDiscOneOfOneOf,
    required TResult Function(FruitInlineInlineDiscOneOf1Unknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf value)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult? Function(FruitInlineInlineDiscOneOf1Unknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf value)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult Function(FruitInlineInlineDiscOneOf1Unknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitInlineInlineDiscOneOf1CopyWith<$Res> {
  factory $FruitInlineInlineDiscOneOf1CopyWith(
          FruitInlineInlineDiscOneOf1 value,
          $Res Function(FruitInlineInlineDiscOneOf1) then) =
      _$FruitInlineInlineDiscOneOf1CopyWithImpl<$Res,
          FruitInlineInlineDiscOneOf1>;
}

/// @nodoc
class _$FruitInlineInlineDiscOneOf1CopyWithImpl<$Res,
        $Val extends FruitInlineInlineDiscOneOf1>
    implements $FruitInlineInlineDiscOneOf1CopyWith<$Res> {
  _$FruitInlineInlineDiscOneOf1CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOfCopyWith<
    $Res> {
  factory _$$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOfCopyWith(
          _$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf value,
          $Res Function(
                  _$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf)
              then) =
      __$$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOfCopyWithImpl<
          $Res>;
  @useResult
  $Res call(
      {FruitInlineInlineDiscOneOfOneOf fruitInlineInlineDiscOneOfOneOfValue});

  $FruitInlineInlineDiscOneOfOneOfCopyWith<$Res>
      get fruitInlineInlineDiscOneOfOneOfValue;
}

/// @nodoc
class __$$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOfCopyWithImpl<
        $Res>
    extends _$FruitInlineInlineDiscOneOf1CopyWithImpl<$Res,
        _$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf>
    implements
        _$$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOfCopyWith<
            $Res> {
  __$$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOfCopyWithImpl(
      _$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf _value,
      $Res Function(
              _$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitInlineInlineDiscOneOfOneOfValue = null,
  }) {
    return _then(_$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf(
      fruitInlineInlineDiscOneOfOneOfValue: null ==
              fruitInlineInlineDiscOneOfOneOfValue
          ? _value.fruitInlineInlineDiscOneOfOneOfValue
          : fruitInlineInlineDiscOneOfOneOfValue // ignore: cast_nullable_to_non_nullable
              as FruitInlineInlineDiscOneOfOneOf,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitInlineInlineDiscOneOfOneOfCopyWith<$Res>
      get fruitInlineInlineDiscOneOfOneOfValue {
    return $FruitInlineInlineDiscOneOfOneOfCopyWith<$Res>(
        _value.fruitInlineInlineDiscOneOfOneOfValue, (value) {
      return _then(
          _value.copyWith(fruitInlineInlineDiscOneOfOneOfValue: value));
    });
  }
}

/// @nodoc

class _$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf
    extends FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf {
  const _$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf(
      {required this.fruitInlineInlineDiscOneOfOneOfValue})
      : super._();

  @override
  final FruitInlineInlineDiscOneOfOneOf fruitInlineInlineDiscOneOfOneOfValue;

  @override
  String toString() {
    return 'FruitInlineInlineDiscOneOf1.asFruitInlineInlineDiscOneOfOneOf(fruitInlineInlineDiscOneOfOneOfValue: $fruitInlineInlineDiscOneOfOneOfValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf &&
            (identical(other.fruitInlineInlineDiscOneOfOneOfValue,
                    fruitInlineInlineDiscOneOfOneOfValue) ||
                other.fruitInlineInlineDiscOneOfOneOfValue ==
                    fruitInlineInlineDiscOneOfOneOfValue));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, fruitInlineInlineDiscOneOfOneOfValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOfCopyWith<
          _$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf>
      get copyWith =>
          __$$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOfCopyWithImpl<
                  _$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)
        asFruitInlineInlineDiscOneOfOneOf,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf1> deserializedModels)
        unknown,
  }) {
    return asFruitInlineInlineDiscOneOfOneOf(
        fruitInlineInlineDiscOneOfOneOfValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf1> deserializedModels)?
        unknown,
  }) {
    return asFruitInlineInlineDiscOneOfOneOf
        ?.call(fruitInlineInlineDiscOneOfOneOfValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf1> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asFruitInlineInlineDiscOneOfOneOf != null) {
      return asFruitInlineInlineDiscOneOfOneOf(
          fruitInlineInlineDiscOneOfOneOfValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf value)
        asFruitInlineInlineDiscOneOfOneOf,
    required TResult Function(FruitInlineInlineDiscOneOf1Unknown value) unknown,
  }) {
    return asFruitInlineInlineDiscOneOfOneOf(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf value)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult? Function(FruitInlineInlineDiscOneOf1Unknown value)? unknown,
  }) {
    return asFruitInlineInlineDiscOneOfOneOf?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf value)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult Function(FruitInlineInlineDiscOneOf1Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asFruitInlineInlineDiscOneOfOneOf != null) {
      return asFruitInlineInlineDiscOneOfOneOf(this);
    }
    return orElse();
  }
}

abstract class FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf
    extends FruitInlineInlineDiscOneOf1 {
  const factory FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf(
          {required final FruitInlineInlineDiscOneOfOneOf
              fruitInlineInlineDiscOneOfOneOfValue}) =
      _$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf;
  const FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf._()
      : super._();

  FruitInlineInlineDiscOneOfOneOf get fruitInlineInlineDiscOneOfOneOfValue;
  @JsonKey(ignore: true)
  _$$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOfCopyWith<
          _$FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitInlineInlineDiscOneOf1UnknownCopyWith<$Res> {
  factory _$$FruitInlineInlineDiscOneOf1UnknownCopyWith(
          _$FruitInlineInlineDiscOneOf1Unknown value,
          $Res Function(_$FruitInlineInlineDiscOneOf1Unknown) then) =
      __$$FruitInlineInlineDiscOneOf1UnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<FruitInlineInlineDiscOneOf1> deserializedModels});
}

/// @nodoc
class __$$FruitInlineInlineDiscOneOf1UnknownCopyWithImpl<$Res>
    extends _$FruitInlineInlineDiscOneOf1CopyWithImpl<$Res,
        _$FruitInlineInlineDiscOneOf1Unknown>
    implements _$$FruitInlineInlineDiscOneOf1UnknownCopyWith<$Res> {
  __$$FruitInlineInlineDiscOneOf1UnknownCopyWithImpl(
      _$FruitInlineInlineDiscOneOf1Unknown _value,
      $Res Function(_$FruitInlineInlineDiscOneOf1Unknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$FruitInlineInlineDiscOneOf1Unknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<FruitInlineInlineDiscOneOf1>,
    ));
  }
}

/// @nodoc

class _$FruitInlineInlineDiscOneOf1Unknown
    extends FruitInlineInlineDiscOneOf1Unknown {
  const _$FruitInlineInlineDiscOneOf1Unknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        FruitInlineInlineDiscOneOfOneOf
      ],
      final List<FruitInlineInlineDiscOneOf1> deserializedModels =
          const <FruitInlineInlineDiscOneOf1>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<FruitInlineInlineDiscOneOf1> _deserializedModels;
  @override
  @JsonKey()
  List<FruitInlineInlineDiscOneOf1> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'FruitInlineInlineDiscOneOf1.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitInlineInlineDiscOneOf1Unknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitInlineInlineDiscOneOf1UnknownCopyWith<
          _$FruitInlineInlineDiscOneOf1Unknown>
      get copyWith => __$$FruitInlineInlineDiscOneOf1UnknownCopyWithImpl<
          _$FruitInlineInlineDiscOneOf1Unknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)
        asFruitInlineInlineDiscOneOfOneOf,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf1> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf1> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOfOneOf
                fruitInlineInlineDiscOneOfOneOfValue)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitInlineInlineDiscOneOf1> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf value)
        asFruitInlineInlineDiscOneOfOneOf,
    required TResult Function(FruitInlineInlineDiscOneOf1Unknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf value)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult? Function(FruitInlineInlineDiscOneOf1Unknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            FruitInlineInlineDiscOneOf1AsFruitInlineInlineDiscOneOfOneOf value)?
        asFruitInlineInlineDiscOneOfOneOf,
    TResult Function(FruitInlineInlineDiscOneOf1Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class FruitInlineInlineDiscOneOf1Unknown
    extends FruitInlineInlineDiscOneOf1 {
  const factory FruitInlineInlineDiscOneOf1Unknown(
          {final String message,
          required final Map<String, dynamic> json,
          final DeserializationErrorType errorType,
          final List<Type> possibleTypes,
          final List<FruitInlineInlineDiscOneOf1> deserializedModels}) =
      _$FruitInlineInlineDiscOneOf1Unknown;
  const FruitInlineInlineDiscOneOf1Unknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<FruitInlineInlineDiscOneOf1> get deserializedModels;
  @JsonKey(ignore: true)
  _$$FruitInlineInlineDiscOneOf1UnknownCopyWith<
          _$FruitInlineInlineDiscOneOf1Unknown>
      get copyWith => throw _privateConstructorUsedError;
}

FruitInlineInlineDiscOneOfOneOf _$FruitInlineInlineDiscOneOfOneOfFromJson(
    Map<String, dynamic> json) {
  return _FruitInlineInlineDiscOneOfOneOf.fromJson(json);
}

/// @nodoc
mixin _$FruitInlineInlineDiscOneOfOneOf {
  @JsonKey(name: r'fruitType')
  String get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FruitInlineInlineDiscOneOfOneOfCopyWith<FruitInlineInlineDiscOneOfOneOf>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitInlineInlineDiscOneOfOneOfCopyWith<$Res> {
  factory $FruitInlineInlineDiscOneOfOneOfCopyWith(
          FruitInlineInlineDiscOneOfOneOf value,
          $Res Function(FruitInlineInlineDiscOneOfOneOf) then) =
      _$FruitInlineInlineDiscOneOfOneOfCopyWithImpl<$Res,
          FruitInlineInlineDiscOneOfOneOf>;
  @useResult
  $Res call({@JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class _$FruitInlineInlineDiscOneOfOneOfCopyWithImpl<$Res,
        $Val extends FruitInlineInlineDiscOneOfOneOf>
    implements $FruitInlineInlineDiscOneOfOneOfCopyWith<$Res> {
  _$FruitInlineInlineDiscOneOfOneOfCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitType = null,
  }) {
    return _then(_value.copyWith(
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FruitInlineInlineDiscOneOfOneOfCopyWith<$Res>
    implements $FruitInlineInlineDiscOneOfOneOfCopyWith<$Res> {
  factory _$$_FruitInlineInlineDiscOneOfOneOfCopyWith(
          _$_FruitInlineInlineDiscOneOfOneOf value,
          $Res Function(_$_FruitInlineInlineDiscOneOfOneOf) then) =
      __$$_FruitInlineInlineDiscOneOfOneOfCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class __$$_FruitInlineInlineDiscOneOfOneOfCopyWithImpl<$Res>
    extends _$FruitInlineInlineDiscOneOfOneOfCopyWithImpl<$Res,
        _$_FruitInlineInlineDiscOneOfOneOf>
    implements _$$_FruitInlineInlineDiscOneOfOneOfCopyWith<$Res> {
  __$$_FruitInlineInlineDiscOneOfOneOfCopyWithImpl(
      _$_FruitInlineInlineDiscOneOfOneOf _value,
      $Res Function(_$_FruitInlineInlineDiscOneOfOneOf) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitType = null,
  }) {
    return _then(_$_FruitInlineInlineDiscOneOfOneOf(
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FruitInlineInlineDiscOneOfOneOf
    extends _FruitInlineInlineDiscOneOfOneOf {
  const _$_FruitInlineInlineDiscOneOfOneOf(
      {@JsonKey(name: r'fruitType') required this.fruitType})
      : super._();

  factory _$_FruitInlineInlineDiscOneOfOneOf.fromJson(
          Map<String, dynamic> json) =>
      _$$_FruitInlineInlineDiscOneOfOneOfFromJson(json);

  @override
  @JsonKey(name: r'fruitType')
  final String fruitType;

  @override
  String toString() {
    return 'FruitInlineInlineDiscOneOfOneOf(fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FruitInlineInlineDiscOneOfOneOf &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FruitInlineInlineDiscOneOfOneOfCopyWith<
          _$_FruitInlineInlineDiscOneOfOneOf>
      get copyWith => __$$_FruitInlineInlineDiscOneOfOneOfCopyWithImpl<
          _$_FruitInlineInlineDiscOneOfOneOf>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FruitInlineInlineDiscOneOfOneOfToJson(
      this,
    );
  }
}

abstract class _FruitInlineInlineDiscOneOfOneOf
    extends FruitInlineInlineDiscOneOfOneOf {
  const factory _FruitInlineInlineDiscOneOfOneOf(
          {@JsonKey(name: r'fruitType') required final String fruitType}) =
      _$_FruitInlineInlineDiscOneOfOneOf;
  const _FruitInlineInlineDiscOneOfOneOf._() : super._();

  factory _FruitInlineInlineDiscOneOfOneOf.fromJson(Map<String, dynamic> json) =
      _$_FruitInlineInlineDiscOneOfOneOf.fromJson;

  @override
  @JsonKey(name: r'fruitType')
  String get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_FruitInlineInlineDiscOneOfOneOfCopyWith<
          _$_FruitInlineInlineDiscOneOfOneOf>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FruitOneOfDisc {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleOneOfDisc appleOneOfDiscValue)
        asAppleOneOfDisc,
    required TResult Function(BananaOneOfDisc bananaOneOfDiscValue)
        asBananaOneOfDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitOneOfDisc> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleOneOfDisc appleOneOfDiscValue)? asAppleOneOfDisc,
    TResult? Function(BananaOneOfDisc bananaOneOfDiscValue)? asBananaOneOfDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitOneOfDisc> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleOneOfDisc appleOneOfDiscValue)? asAppleOneOfDisc,
    TResult Function(BananaOneOfDisc bananaOneOfDiscValue)? asBananaOneOfDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitOneOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitOneOfDiscAsAppleOneOfDisc value)
        asAppleOneOfDisc,
    required TResult Function(FruitOneOfDiscAsBananaOneOfDisc value)
        asBananaOneOfDisc,
    required TResult Function(FruitOneOfDiscUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitOneOfDiscAsAppleOneOfDisc value)? asAppleOneOfDisc,
    TResult? Function(FruitOneOfDiscAsBananaOneOfDisc value)? asBananaOneOfDisc,
    TResult? Function(FruitOneOfDiscUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitOneOfDiscAsAppleOneOfDisc value)? asAppleOneOfDisc,
    TResult Function(FruitOneOfDiscAsBananaOneOfDisc value)? asBananaOneOfDisc,
    TResult Function(FruitOneOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitOneOfDiscCopyWith<$Res> {
  factory $FruitOneOfDiscCopyWith(
          FruitOneOfDisc value, $Res Function(FruitOneOfDisc) then) =
      _$FruitOneOfDiscCopyWithImpl<$Res, FruitOneOfDisc>;
}

/// @nodoc
class _$FruitOneOfDiscCopyWithImpl<$Res, $Val extends FruitOneOfDisc>
    implements $FruitOneOfDiscCopyWith<$Res> {
  _$FruitOneOfDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FruitOneOfDiscAsAppleOneOfDiscCopyWith<$Res> {
  factory _$$FruitOneOfDiscAsAppleOneOfDiscCopyWith(
          _$FruitOneOfDiscAsAppleOneOfDisc value,
          $Res Function(_$FruitOneOfDiscAsAppleOneOfDisc) then) =
      __$$FruitOneOfDiscAsAppleOneOfDiscCopyWithImpl<$Res>;
  @useResult
  $Res call({AppleOneOfDisc appleOneOfDiscValue});

  $AppleOneOfDiscCopyWith<$Res> get appleOneOfDiscValue;
}

/// @nodoc
class __$$FruitOneOfDiscAsAppleOneOfDiscCopyWithImpl<$Res>
    extends _$FruitOneOfDiscCopyWithImpl<$Res, _$FruitOneOfDiscAsAppleOneOfDisc>
    implements _$$FruitOneOfDiscAsAppleOneOfDiscCopyWith<$Res> {
  __$$FruitOneOfDiscAsAppleOneOfDiscCopyWithImpl(
      _$FruitOneOfDiscAsAppleOneOfDisc _value,
      $Res Function(_$FruitOneOfDiscAsAppleOneOfDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? appleOneOfDiscValue = null,
  }) {
    return _then(_$FruitOneOfDiscAsAppleOneOfDisc(
      appleOneOfDiscValue: null == appleOneOfDiscValue
          ? _value.appleOneOfDiscValue
          : appleOneOfDiscValue // ignore: cast_nullable_to_non_nullable
              as AppleOneOfDisc,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AppleOneOfDiscCopyWith<$Res> get appleOneOfDiscValue {
    return $AppleOneOfDiscCopyWith<$Res>(_value.appleOneOfDiscValue, (value) {
      return _then(_value.copyWith(appleOneOfDiscValue: value));
    });
  }
}

/// @nodoc

class _$FruitOneOfDiscAsAppleOneOfDisc extends FruitOneOfDiscAsAppleOneOfDisc {
  const _$FruitOneOfDiscAsAppleOneOfDisc({required this.appleOneOfDiscValue})
      : super._();

  @override
  final AppleOneOfDisc appleOneOfDiscValue;

  @override
  String toString() {
    return 'FruitOneOfDisc.asAppleOneOfDisc(appleOneOfDiscValue: $appleOneOfDiscValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitOneOfDiscAsAppleOneOfDisc &&
            (identical(other.appleOneOfDiscValue, appleOneOfDiscValue) ||
                other.appleOneOfDiscValue == appleOneOfDiscValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, appleOneOfDiscValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitOneOfDiscAsAppleOneOfDiscCopyWith<_$FruitOneOfDiscAsAppleOneOfDisc>
      get copyWith => __$$FruitOneOfDiscAsAppleOneOfDiscCopyWithImpl<
          _$FruitOneOfDiscAsAppleOneOfDisc>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleOneOfDisc appleOneOfDiscValue)
        asAppleOneOfDisc,
    required TResult Function(BananaOneOfDisc bananaOneOfDiscValue)
        asBananaOneOfDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitOneOfDisc> deserializedModels)
        unknown,
  }) {
    return asAppleOneOfDisc(appleOneOfDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleOneOfDisc appleOneOfDiscValue)? asAppleOneOfDisc,
    TResult? Function(BananaOneOfDisc bananaOneOfDiscValue)? asBananaOneOfDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitOneOfDisc> deserializedModels)?
        unknown,
  }) {
    return asAppleOneOfDisc?.call(appleOneOfDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleOneOfDisc appleOneOfDiscValue)? asAppleOneOfDisc,
    TResult Function(BananaOneOfDisc bananaOneOfDiscValue)? asBananaOneOfDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitOneOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asAppleOneOfDisc != null) {
      return asAppleOneOfDisc(appleOneOfDiscValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitOneOfDiscAsAppleOneOfDisc value)
        asAppleOneOfDisc,
    required TResult Function(FruitOneOfDiscAsBananaOneOfDisc value)
        asBananaOneOfDisc,
    required TResult Function(FruitOneOfDiscUnknown value) unknown,
  }) {
    return asAppleOneOfDisc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitOneOfDiscAsAppleOneOfDisc value)? asAppleOneOfDisc,
    TResult? Function(FruitOneOfDiscAsBananaOneOfDisc value)? asBananaOneOfDisc,
    TResult? Function(FruitOneOfDiscUnknown value)? unknown,
  }) {
    return asAppleOneOfDisc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitOneOfDiscAsAppleOneOfDisc value)? asAppleOneOfDisc,
    TResult Function(FruitOneOfDiscAsBananaOneOfDisc value)? asBananaOneOfDisc,
    TResult Function(FruitOneOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asAppleOneOfDisc != null) {
      return asAppleOneOfDisc(this);
    }
    return orElse();
  }
}

abstract class FruitOneOfDiscAsAppleOneOfDisc extends FruitOneOfDisc {
  const factory FruitOneOfDiscAsAppleOneOfDisc(
          {required final AppleOneOfDisc appleOneOfDiscValue}) =
      _$FruitOneOfDiscAsAppleOneOfDisc;
  const FruitOneOfDiscAsAppleOneOfDisc._() : super._();

  AppleOneOfDisc get appleOneOfDiscValue;
  @JsonKey(ignore: true)
  _$$FruitOneOfDiscAsAppleOneOfDiscCopyWith<_$FruitOneOfDiscAsAppleOneOfDisc>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitOneOfDiscAsBananaOneOfDiscCopyWith<$Res> {
  factory _$$FruitOneOfDiscAsBananaOneOfDiscCopyWith(
          _$FruitOneOfDiscAsBananaOneOfDisc value,
          $Res Function(_$FruitOneOfDiscAsBananaOneOfDisc) then) =
      __$$FruitOneOfDiscAsBananaOneOfDiscCopyWithImpl<$Res>;
  @useResult
  $Res call({BananaOneOfDisc bananaOneOfDiscValue});

  $BananaOneOfDiscCopyWith<$Res> get bananaOneOfDiscValue;
}

/// @nodoc
class __$$FruitOneOfDiscAsBananaOneOfDiscCopyWithImpl<$Res>
    extends _$FruitOneOfDiscCopyWithImpl<$Res,
        _$FruitOneOfDiscAsBananaOneOfDisc>
    implements _$$FruitOneOfDiscAsBananaOneOfDiscCopyWith<$Res> {
  __$$FruitOneOfDiscAsBananaOneOfDiscCopyWithImpl(
      _$FruitOneOfDiscAsBananaOneOfDisc _value,
      $Res Function(_$FruitOneOfDiscAsBananaOneOfDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bananaOneOfDiscValue = null,
  }) {
    return _then(_$FruitOneOfDiscAsBananaOneOfDisc(
      bananaOneOfDiscValue: null == bananaOneOfDiscValue
          ? _value.bananaOneOfDiscValue
          : bananaOneOfDiscValue // ignore: cast_nullable_to_non_nullable
              as BananaOneOfDisc,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BananaOneOfDiscCopyWith<$Res> get bananaOneOfDiscValue {
    return $BananaOneOfDiscCopyWith<$Res>(_value.bananaOneOfDiscValue, (value) {
      return _then(_value.copyWith(bananaOneOfDiscValue: value));
    });
  }
}

/// @nodoc

class _$FruitOneOfDiscAsBananaOneOfDisc
    extends FruitOneOfDiscAsBananaOneOfDisc {
  const _$FruitOneOfDiscAsBananaOneOfDisc({required this.bananaOneOfDiscValue})
      : super._();

  @override
  final BananaOneOfDisc bananaOneOfDiscValue;

  @override
  String toString() {
    return 'FruitOneOfDisc.asBananaOneOfDisc(bananaOneOfDiscValue: $bananaOneOfDiscValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitOneOfDiscAsBananaOneOfDisc &&
            (identical(other.bananaOneOfDiscValue, bananaOneOfDiscValue) ||
                other.bananaOneOfDiscValue == bananaOneOfDiscValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bananaOneOfDiscValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitOneOfDiscAsBananaOneOfDiscCopyWith<_$FruitOneOfDiscAsBananaOneOfDisc>
      get copyWith => __$$FruitOneOfDiscAsBananaOneOfDiscCopyWithImpl<
          _$FruitOneOfDiscAsBananaOneOfDisc>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleOneOfDisc appleOneOfDiscValue)
        asAppleOneOfDisc,
    required TResult Function(BananaOneOfDisc bananaOneOfDiscValue)
        asBananaOneOfDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitOneOfDisc> deserializedModels)
        unknown,
  }) {
    return asBananaOneOfDisc(bananaOneOfDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleOneOfDisc appleOneOfDiscValue)? asAppleOneOfDisc,
    TResult? Function(BananaOneOfDisc bananaOneOfDiscValue)? asBananaOneOfDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitOneOfDisc> deserializedModels)?
        unknown,
  }) {
    return asBananaOneOfDisc?.call(bananaOneOfDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleOneOfDisc appleOneOfDiscValue)? asAppleOneOfDisc,
    TResult Function(BananaOneOfDisc bananaOneOfDiscValue)? asBananaOneOfDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitOneOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asBananaOneOfDisc != null) {
      return asBananaOneOfDisc(bananaOneOfDiscValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitOneOfDiscAsAppleOneOfDisc value)
        asAppleOneOfDisc,
    required TResult Function(FruitOneOfDiscAsBananaOneOfDisc value)
        asBananaOneOfDisc,
    required TResult Function(FruitOneOfDiscUnknown value) unknown,
  }) {
    return asBananaOneOfDisc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitOneOfDiscAsAppleOneOfDisc value)? asAppleOneOfDisc,
    TResult? Function(FruitOneOfDiscAsBananaOneOfDisc value)? asBananaOneOfDisc,
    TResult? Function(FruitOneOfDiscUnknown value)? unknown,
  }) {
    return asBananaOneOfDisc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitOneOfDiscAsAppleOneOfDisc value)? asAppleOneOfDisc,
    TResult Function(FruitOneOfDiscAsBananaOneOfDisc value)? asBananaOneOfDisc,
    TResult Function(FruitOneOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asBananaOneOfDisc != null) {
      return asBananaOneOfDisc(this);
    }
    return orElse();
  }
}

abstract class FruitOneOfDiscAsBananaOneOfDisc extends FruitOneOfDisc {
  const factory FruitOneOfDiscAsBananaOneOfDisc(
          {required final BananaOneOfDisc bananaOneOfDiscValue}) =
      _$FruitOneOfDiscAsBananaOneOfDisc;
  const FruitOneOfDiscAsBananaOneOfDisc._() : super._();

  BananaOneOfDisc get bananaOneOfDiscValue;
  @JsonKey(ignore: true)
  _$$FruitOneOfDiscAsBananaOneOfDiscCopyWith<_$FruitOneOfDiscAsBananaOneOfDisc>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitOneOfDiscUnknownCopyWith<$Res> {
  factory _$$FruitOneOfDiscUnknownCopyWith(_$FruitOneOfDiscUnknown value,
          $Res Function(_$FruitOneOfDiscUnknown) then) =
      __$$FruitOneOfDiscUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<FruitOneOfDisc> deserializedModels});
}

/// @nodoc
class __$$FruitOneOfDiscUnknownCopyWithImpl<$Res>
    extends _$FruitOneOfDiscCopyWithImpl<$Res, _$FruitOneOfDiscUnknown>
    implements _$$FruitOneOfDiscUnknownCopyWith<$Res> {
  __$$FruitOneOfDiscUnknownCopyWithImpl(_$FruitOneOfDiscUnknown _value,
      $Res Function(_$FruitOneOfDiscUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$FruitOneOfDiscUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<FruitOneOfDisc>,
    ));
  }
}

/// @nodoc

class _$FruitOneOfDiscUnknown extends FruitOneOfDiscUnknown {
  const _$FruitOneOfDiscUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        AppleOneOfDisc,
        BananaOneOfDisc
      ],
      final List<FruitOneOfDisc> deserializedModels = const <FruitOneOfDisc>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<FruitOneOfDisc> _deserializedModels;
  @override
  @JsonKey()
  List<FruitOneOfDisc> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'FruitOneOfDisc.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitOneOfDiscUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitOneOfDiscUnknownCopyWith<_$FruitOneOfDiscUnknown> get copyWith =>
      __$$FruitOneOfDiscUnknownCopyWithImpl<_$FruitOneOfDiscUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleOneOfDisc appleOneOfDiscValue)
        asAppleOneOfDisc,
    required TResult Function(BananaOneOfDisc bananaOneOfDiscValue)
        asBananaOneOfDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitOneOfDisc> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleOneOfDisc appleOneOfDiscValue)? asAppleOneOfDisc,
    TResult? Function(BananaOneOfDisc bananaOneOfDiscValue)? asBananaOneOfDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitOneOfDisc> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleOneOfDisc appleOneOfDiscValue)? asAppleOneOfDisc,
    TResult Function(BananaOneOfDisc bananaOneOfDiscValue)? asBananaOneOfDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitOneOfDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitOneOfDiscAsAppleOneOfDisc value)
        asAppleOneOfDisc,
    required TResult Function(FruitOneOfDiscAsBananaOneOfDisc value)
        asBananaOneOfDisc,
    required TResult Function(FruitOneOfDiscUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitOneOfDiscAsAppleOneOfDisc value)? asAppleOneOfDisc,
    TResult? Function(FruitOneOfDiscAsBananaOneOfDisc value)? asBananaOneOfDisc,
    TResult? Function(FruitOneOfDiscUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitOneOfDiscAsAppleOneOfDisc value)? asAppleOneOfDisc,
    TResult Function(FruitOneOfDiscAsBananaOneOfDisc value)? asBananaOneOfDisc,
    TResult Function(FruitOneOfDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class FruitOneOfDiscUnknown extends FruitOneOfDisc {
  const factory FruitOneOfDiscUnknown(
      {final String message,
      required final Map<String, dynamic> json,
      final DeserializationErrorType errorType,
      final List<Type> possibleTypes,
      final List<FruitOneOfDisc> deserializedModels}) = _$FruitOneOfDiscUnknown;
  const FruitOneOfDiscUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<FruitOneOfDisc> get deserializedModels;
  @JsonKey(ignore: true)
  _$$FruitOneOfDiscUnknownCopyWith<_$FruitOneOfDiscUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FruitReqDisc {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleReqDisc appleReqDiscValue) asAppleReqDisc,
    required TResult Function(BananaReqDisc bananaReqDiscValue) asBananaReqDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitReqDisc> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleReqDisc appleReqDiscValue)? asAppleReqDisc,
    TResult? Function(BananaReqDisc bananaReqDiscValue)? asBananaReqDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitReqDisc> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleReqDisc appleReqDiscValue)? asAppleReqDisc,
    TResult Function(BananaReqDisc bananaReqDiscValue)? asBananaReqDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitReqDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitReqDiscAsAppleReqDisc value) asAppleReqDisc,
    required TResult Function(FruitReqDiscAsBananaReqDisc value)
        asBananaReqDisc,
    required TResult Function(FruitReqDiscUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitReqDiscAsAppleReqDisc value)? asAppleReqDisc,
    TResult? Function(FruitReqDiscAsBananaReqDisc value)? asBananaReqDisc,
    TResult? Function(FruitReqDiscUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitReqDiscAsAppleReqDisc value)? asAppleReqDisc,
    TResult Function(FruitReqDiscAsBananaReqDisc value)? asBananaReqDisc,
    TResult Function(FruitReqDiscUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitReqDiscCopyWith<$Res> {
  factory $FruitReqDiscCopyWith(
          FruitReqDisc value, $Res Function(FruitReqDisc) then) =
      _$FruitReqDiscCopyWithImpl<$Res, FruitReqDisc>;
}

/// @nodoc
class _$FruitReqDiscCopyWithImpl<$Res, $Val extends FruitReqDisc>
    implements $FruitReqDiscCopyWith<$Res> {
  _$FruitReqDiscCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FruitReqDiscAsAppleReqDiscCopyWith<$Res> {
  factory _$$FruitReqDiscAsAppleReqDiscCopyWith(
          _$FruitReqDiscAsAppleReqDisc value,
          $Res Function(_$FruitReqDiscAsAppleReqDisc) then) =
      __$$FruitReqDiscAsAppleReqDiscCopyWithImpl<$Res>;
  @useResult
  $Res call({AppleReqDisc appleReqDiscValue});

  $AppleReqDiscCopyWith<$Res> get appleReqDiscValue;
}

/// @nodoc
class __$$FruitReqDiscAsAppleReqDiscCopyWithImpl<$Res>
    extends _$FruitReqDiscCopyWithImpl<$Res, _$FruitReqDiscAsAppleReqDisc>
    implements _$$FruitReqDiscAsAppleReqDiscCopyWith<$Res> {
  __$$FruitReqDiscAsAppleReqDiscCopyWithImpl(
      _$FruitReqDiscAsAppleReqDisc _value,
      $Res Function(_$FruitReqDiscAsAppleReqDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? appleReqDiscValue = null,
  }) {
    return _then(_$FruitReqDiscAsAppleReqDisc(
      appleReqDiscValue: null == appleReqDiscValue
          ? _value.appleReqDiscValue
          : appleReqDiscValue // ignore: cast_nullable_to_non_nullable
              as AppleReqDisc,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AppleReqDiscCopyWith<$Res> get appleReqDiscValue {
    return $AppleReqDiscCopyWith<$Res>(_value.appleReqDiscValue, (value) {
      return _then(_value.copyWith(appleReqDiscValue: value));
    });
  }
}

/// @nodoc

class _$FruitReqDiscAsAppleReqDisc extends FruitReqDiscAsAppleReqDisc {
  const _$FruitReqDiscAsAppleReqDisc({required this.appleReqDiscValue})
      : super._();

  @override
  final AppleReqDisc appleReqDiscValue;

  @override
  String toString() {
    return 'FruitReqDisc.asAppleReqDisc(appleReqDiscValue: $appleReqDiscValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitReqDiscAsAppleReqDisc &&
            (identical(other.appleReqDiscValue, appleReqDiscValue) ||
                other.appleReqDiscValue == appleReqDiscValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, appleReqDiscValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitReqDiscAsAppleReqDiscCopyWith<_$FruitReqDiscAsAppleReqDisc>
      get copyWith => __$$FruitReqDiscAsAppleReqDiscCopyWithImpl<
          _$FruitReqDiscAsAppleReqDisc>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleReqDisc appleReqDiscValue) asAppleReqDisc,
    required TResult Function(BananaReqDisc bananaReqDiscValue) asBananaReqDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitReqDisc> deserializedModels)
        unknown,
  }) {
    return asAppleReqDisc(appleReqDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleReqDisc appleReqDiscValue)? asAppleReqDisc,
    TResult? Function(BananaReqDisc bananaReqDiscValue)? asBananaReqDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitReqDisc> deserializedModels)?
        unknown,
  }) {
    return asAppleReqDisc?.call(appleReqDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleReqDisc appleReqDiscValue)? asAppleReqDisc,
    TResult Function(BananaReqDisc bananaReqDiscValue)? asBananaReqDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitReqDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asAppleReqDisc != null) {
      return asAppleReqDisc(appleReqDiscValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitReqDiscAsAppleReqDisc value) asAppleReqDisc,
    required TResult Function(FruitReqDiscAsBananaReqDisc value)
        asBananaReqDisc,
    required TResult Function(FruitReqDiscUnknown value) unknown,
  }) {
    return asAppleReqDisc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitReqDiscAsAppleReqDisc value)? asAppleReqDisc,
    TResult? Function(FruitReqDiscAsBananaReqDisc value)? asBananaReqDisc,
    TResult? Function(FruitReqDiscUnknown value)? unknown,
  }) {
    return asAppleReqDisc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitReqDiscAsAppleReqDisc value)? asAppleReqDisc,
    TResult Function(FruitReqDiscAsBananaReqDisc value)? asBananaReqDisc,
    TResult Function(FruitReqDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asAppleReqDisc != null) {
      return asAppleReqDisc(this);
    }
    return orElse();
  }
}

abstract class FruitReqDiscAsAppleReqDisc extends FruitReqDisc {
  const factory FruitReqDiscAsAppleReqDisc(
          {required final AppleReqDisc appleReqDiscValue}) =
      _$FruitReqDiscAsAppleReqDisc;
  const FruitReqDiscAsAppleReqDisc._() : super._();

  AppleReqDisc get appleReqDiscValue;
  @JsonKey(ignore: true)
  _$$FruitReqDiscAsAppleReqDiscCopyWith<_$FruitReqDiscAsAppleReqDisc>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitReqDiscAsBananaReqDiscCopyWith<$Res> {
  factory _$$FruitReqDiscAsBananaReqDiscCopyWith(
          _$FruitReqDiscAsBananaReqDisc value,
          $Res Function(_$FruitReqDiscAsBananaReqDisc) then) =
      __$$FruitReqDiscAsBananaReqDiscCopyWithImpl<$Res>;
  @useResult
  $Res call({BananaReqDisc bananaReqDiscValue});

  $BananaReqDiscCopyWith<$Res> get bananaReqDiscValue;
}

/// @nodoc
class __$$FruitReqDiscAsBananaReqDiscCopyWithImpl<$Res>
    extends _$FruitReqDiscCopyWithImpl<$Res, _$FruitReqDiscAsBananaReqDisc>
    implements _$$FruitReqDiscAsBananaReqDiscCopyWith<$Res> {
  __$$FruitReqDiscAsBananaReqDiscCopyWithImpl(
      _$FruitReqDiscAsBananaReqDisc _value,
      $Res Function(_$FruitReqDiscAsBananaReqDisc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bananaReqDiscValue = null,
  }) {
    return _then(_$FruitReqDiscAsBananaReqDisc(
      bananaReqDiscValue: null == bananaReqDiscValue
          ? _value.bananaReqDiscValue
          : bananaReqDiscValue // ignore: cast_nullable_to_non_nullable
              as BananaReqDisc,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BananaReqDiscCopyWith<$Res> get bananaReqDiscValue {
    return $BananaReqDiscCopyWith<$Res>(_value.bananaReqDiscValue, (value) {
      return _then(_value.copyWith(bananaReqDiscValue: value));
    });
  }
}

/// @nodoc

class _$FruitReqDiscAsBananaReqDisc extends FruitReqDiscAsBananaReqDisc {
  const _$FruitReqDiscAsBananaReqDisc({required this.bananaReqDiscValue})
      : super._();

  @override
  final BananaReqDisc bananaReqDiscValue;

  @override
  String toString() {
    return 'FruitReqDisc.asBananaReqDisc(bananaReqDiscValue: $bananaReqDiscValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitReqDiscAsBananaReqDisc &&
            (identical(other.bananaReqDiscValue, bananaReqDiscValue) ||
                other.bananaReqDiscValue == bananaReqDiscValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bananaReqDiscValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitReqDiscAsBananaReqDiscCopyWith<_$FruitReqDiscAsBananaReqDisc>
      get copyWith => __$$FruitReqDiscAsBananaReqDiscCopyWithImpl<
          _$FruitReqDiscAsBananaReqDisc>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleReqDisc appleReqDiscValue) asAppleReqDisc,
    required TResult Function(BananaReqDisc bananaReqDiscValue) asBananaReqDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitReqDisc> deserializedModels)
        unknown,
  }) {
    return asBananaReqDisc(bananaReqDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleReqDisc appleReqDiscValue)? asAppleReqDisc,
    TResult? Function(BananaReqDisc bananaReqDiscValue)? asBananaReqDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitReqDisc> deserializedModels)?
        unknown,
  }) {
    return asBananaReqDisc?.call(bananaReqDiscValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleReqDisc appleReqDiscValue)? asAppleReqDisc,
    TResult Function(BananaReqDisc bananaReqDiscValue)? asBananaReqDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitReqDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asBananaReqDisc != null) {
      return asBananaReqDisc(bananaReqDiscValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitReqDiscAsAppleReqDisc value) asAppleReqDisc,
    required TResult Function(FruitReqDiscAsBananaReqDisc value)
        asBananaReqDisc,
    required TResult Function(FruitReqDiscUnknown value) unknown,
  }) {
    return asBananaReqDisc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitReqDiscAsAppleReqDisc value)? asAppleReqDisc,
    TResult? Function(FruitReqDiscAsBananaReqDisc value)? asBananaReqDisc,
    TResult? Function(FruitReqDiscUnknown value)? unknown,
  }) {
    return asBananaReqDisc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitReqDiscAsAppleReqDisc value)? asAppleReqDisc,
    TResult Function(FruitReqDiscAsBananaReqDisc value)? asBananaReqDisc,
    TResult Function(FruitReqDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asBananaReqDisc != null) {
      return asBananaReqDisc(this);
    }
    return orElse();
  }
}

abstract class FruitReqDiscAsBananaReqDisc extends FruitReqDisc {
  const factory FruitReqDiscAsBananaReqDisc(
          {required final BananaReqDisc bananaReqDiscValue}) =
      _$FruitReqDiscAsBananaReqDisc;
  const FruitReqDiscAsBananaReqDisc._() : super._();

  BananaReqDisc get bananaReqDiscValue;
  @JsonKey(ignore: true)
  _$$FruitReqDiscAsBananaReqDiscCopyWith<_$FruitReqDiscAsBananaReqDisc>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitReqDiscUnknownCopyWith<$Res> {
  factory _$$FruitReqDiscUnknownCopyWith(_$FruitReqDiscUnknown value,
          $Res Function(_$FruitReqDiscUnknown) then) =
      __$$FruitReqDiscUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<FruitReqDisc> deserializedModels});
}

/// @nodoc
class __$$FruitReqDiscUnknownCopyWithImpl<$Res>
    extends _$FruitReqDiscCopyWithImpl<$Res, _$FruitReqDiscUnknown>
    implements _$$FruitReqDiscUnknownCopyWith<$Res> {
  __$$FruitReqDiscUnknownCopyWithImpl(
      _$FruitReqDiscUnknown _value, $Res Function(_$FruitReqDiscUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$FruitReqDiscUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<FruitReqDisc>,
    ));
  }
}

/// @nodoc

class _$FruitReqDiscUnknown extends FruitReqDiscUnknown {
  const _$FruitReqDiscUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        AppleReqDisc,
        BananaReqDisc
      ],
      final List<FruitReqDisc> deserializedModels = const <FruitReqDisc>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<FruitReqDisc> _deserializedModels;
  @override
  @JsonKey()
  List<FruitReqDisc> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'FruitReqDisc.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitReqDiscUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitReqDiscUnknownCopyWith<_$FruitReqDiscUnknown> get copyWith =>
      __$$FruitReqDiscUnknownCopyWithImpl<_$FruitReqDiscUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AppleReqDisc appleReqDiscValue) asAppleReqDisc,
    required TResult Function(BananaReqDisc bananaReqDiscValue) asBananaReqDisc,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitReqDisc> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AppleReqDisc appleReqDiscValue)? asAppleReqDisc,
    TResult? Function(BananaReqDisc bananaReqDiscValue)? asBananaReqDisc,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitReqDisc> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AppleReqDisc appleReqDiscValue)? asAppleReqDisc,
    TResult Function(BananaReqDisc bananaReqDiscValue)? asBananaReqDisc,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<FruitReqDisc> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitReqDiscAsAppleReqDisc value) asAppleReqDisc,
    required TResult Function(FruitReqDiscAsBananaReqDisc value)
        asBananaReqDisc,
    required TResult Function(FruitReqDiscUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitReqDiscAsAppleReqDisc value)? asAppleReqDisc,
    TResult? Function(FruitReqDiscAsBananaReqDisc value)? asBananaReqDisc,
    TResult? Function(FruitReqDiscUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitReqDiscAsAppleReqDisc value)? asAppleReqDisc,
    TResult Function(FruitReqDiscAsBananaReqDisc value)? asBananaReqDisc,
    TResult Function(FruitReqDiscUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class FruitReqDiscUnknown extends FruitReqDisc {
  const factory FruitReqDiscUnknown(
      {final String message,
      required final Map<String, dynamic> json,
      final DeserializationErrorType errorType,
      final List<Type> possibleTypes,
      final List<FruitReqDisc> deserializedModels}) = _$FruitReqDiscUnknown;
  const FruitReqDiscUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<FruitReqDisc> get deserializedModels;
  @JsonKey(ignore: true)
  _$$FruitReqDiscUnknownCopyWith<_$FruitReqDiscUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

FruitType _$FruitTypeFromJson(Map<String, dynamic> json) {
  return _FruitType.fromJson(json);
}

/// @nodoc
mixin _$FruitType {
  @JsonKey(name: r'fruitType')
  String get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FruitTypeCopyWith<FruitType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitTypeCopyWith<$Res> {
  factory $FruitTypeCopyWith(FruitType value, $Res Function(FruitType) then) =
      _$FruitTypeCopyWithImpl<$Res, FruitType>;
  @useResult
  $Res call({@JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class _$FruitTypeCopyWithImpl<$Res, $Val extends FruitType>
    implements $FruitTypeCopyWith<$Res> {
  _$FruitTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitType = null,
  }) {
    return _then(_value.copyWith(
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FruitTypeCopyWith<$Res> implements $FruitTypeCopyWith<$Res> {
  factory _$$_FruitTypeCopyWith(
          _$_FruitType value, $Res Function(_$_FruitType) then) =
      __$$_FruitTypeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class __$$_FruitTypeCopyWithImpl<$Res>
    extends _$FruitTypeCopyWithImpl<$Res, _$_FruitType>
    implements _$$_FruitTypeCopyWith<$Res> {
  __$$_FruitTypeCopyWithImpl(
      _$_FruitType _value, $Res Function(_$_FruitType) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitType = null,
  }) {
    return _then(_$_FruitType(
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FruitType extends _FruitType {
  const _$_FruitType({@JsonKey(name: r'fruitType') required this.fruitType})
      : super._();

  factory _$_FruitType.fromJson(Map<String, dynamic> json) =>
      _$$_FruitTypeFromJson(json);

  @override
  @JsonKey(name: r'fruitType')
  final String fruitType;

  @override
  String toString() {
    return 'FruitType(fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FruitType &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FruitTypeCopyWith<_$_FruitType> get copyWith =>
      __$$_FruitTypeCopyWithImpl<_$_FruitType>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FruitTypeToJson(
      this,
    );
  }
}

abstract class _FruitType extends FruitType {
  const factory _FruitType(
          {@JsonKey(name: r'fruitType') required final String fruitType}) =
      _$_FruitType;
  const _FruitType._() : super._();

  factory _FruitType.fromJson(Map<String, dynamic> json) =
      _$_FruitType.fromJson;

  @override
  @JsonKey(name: r'fruitType')
  String get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_FruitTypeCopyWith<_$_FruitType> get copyWith =>
      throw _privateConstructorUsedError;
}

Parent _$ParentFromJson(Map<String, dynamic> json) {
  return _Parent.fromJson(json);
}

/// @nodoc
mixin _$Parent {
  @JsonKey(name: r'fruitType')
  String get fruitType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ParentCopyWith<Parent> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParentCopyWith<$Res> {
  factory $ParentCopyWith(Parent value, $Res Function(Parent) then) =
      _$ParentCopyWithImpl<$Res, Parent>;
  @useResult
  $Res call({@JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class _$ParentCopyWithImpl<$Res, $Val extends Parent>
    implements $ParentCopyWith<$Res> {
  _$ParentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitType = null,
  }) {
    return _then(_value.copyWith(
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ParentCopyWith<$Res> implements $ParentCopyWith<$Res> {
  factory _$$_ParentCopyWith(_$_Parent value, $Res Function(_$_Parent) then) =
      __$$_ParentCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: r'fruitType') String fruitType});
}

/// @nodoc
class __$$_ParentCopyWithImpl<$Res>
    extends _$ParentCopyWithImpl<$Res, _$_Parent>
    implements _$$_ParentCopyWith<$Res> {
  __$$_ParentCopyWithImpl(_$_Parent _value, $Res Function(_$_Parent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fruitType = null,
  }) {
    return _then(_$_Parent(
      fruitType: null == fruitType
          ? _value.fruitType
          : fruitType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Parent extends _Parent {
  const _$_Parent({@JsonKey(name: r'fruitType') required this.fruitType})
      : super._();

  factory _$_Parent.fromJson(Map<String, dynamic> json) =>
      _$$_ParentFromJson(json);

  @override
  @JsonKey(name: r'fruitType')
  final String fruitType;

  @override
  String toString() {
    return 'Parent(fruitType: $fruitType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Parent &&
            (identical(other.fruitType, fruitType) ||
                other.fruitType == fruitType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fruitType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ParentCopyWith<_$_Parent> get copyWith =>
      __$$_ParentCopyWithImpl<_$_Parent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ParentToJson(
      this,
    );
  }
}

abstract class _Parent extends Parent {
  const factory _Parent(
          {@JsonKey(name: r'fruitType') required final String fruitType}) =
      _$_Parent;
  const _Parent._() : super._();

  factory _Parent.fromJson(Map<String, dynamic> json) = _$_Parent.fromJson;

  @override
  @JsonKey(name: r'fruitType')
  String get fruitType;
  @override
  @JsonKey(ignore: true)
  _$$_ParentCopyWith<_$_Parent> get copyWith =>
      throw _privateConstructorUsedError;
}
