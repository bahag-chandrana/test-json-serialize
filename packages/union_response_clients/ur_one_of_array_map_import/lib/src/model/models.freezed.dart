// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

IntInUnion _$IntInUnionFromJson(Map<String, dynamic> json) {
  return _IntInUnion.fromJson(json);
}

/// @nodoc
mixin _$IntInUnion {
  int get intValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IntInUnionCopyWith<IntInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntInUnionCopyWith<$Res> {
  factory $IntInUnionCopyWith(
          IntInUnion value, $Res Function(IntInUnion) then) =
      _$IntInUnionCopyWithImpl<$Res, IntInUnion>;
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class _$IntInUnionCopyWithImpl<$Res, $Val extends IntInUnion>
    implements $IntInUnionCopyWith<$Res> {
  _$IntInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_value.copyWith(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_IntInUnionCopyWith<$Res>
    implements $IntInUnionCopyWith<$Res> {
  factory _$$_IntInUnionCopyWith(
          _$_IntInUnion value, $Res Function(_$_IntInUnion) then) =
      __$$_IntInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class __$$_IntInUnionCopyWithImpl<$Res>
    extends _$IntInUnionCopyWithImpl<$Res, _$_IntInUnion>
    implements _$$_IntInUnionCopyWith<$Res> {
  __$$_IntInUnionCopyWithImpl(
      _$_IntInUnion _value, $Res Function(_$_IntInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_$_IntInUnion(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IntInUnion implements _IntInUnion {
  const _$_IntInUnion({required this.intValue});

  factory _$_IntInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_IntInUnionFromJson(json);

  @override
  final int intValue;

  @override
  String toString() {
    return 'IntInUnion(intValue: $intValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IntInUnion &&
            (identical(other.intValue, intValue) ||
                other.intValue == intValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, intValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IntInUnionCopyWith<_$_IntInUnion> get copyWith =>
      __$$_IntInUnionCopyWithImpl<_$_IntInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IntInUnionToJson(
      this,
    );
  }
}

abstract class _IntInUnion implements IntInUnion {
  const factory _IntInUnion({required final int intValue}) = _$_IntInUnion;

  factory _IntInUnion.fromJson(Map<String, dynamic> json) =
      _$_IntInUnion.fromJson;

  @override
  int get intValue;
  @override
  @JsonKey(ignore: true)
  _$$_IntInUnionCopyWith<_$_IntInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

StringInUnion _$StringInUnionFromJson(Map<String, dynamic> json) {
  return _StringInUnion.fromJson(json);
}

/// @nodoc
mixin _$StringInUnion {
  String get stringValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StringInUnionCopyWith<StringInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringInUnionCopyWith<$Res> {
  factory $StringInUnionCopyWith(
          StringInUnion value, $Res Function(StringInUnion) then) =
      _$StringInUnionCopyWithImpl<$Res, StringInUnion>;
  @useResult
  $Res call({String stringValue});
}

/// @nodoc
class _$StringInUnionCopyWithImpl<$Res, $Val extends StringInUnion>
    implements $StringInUnionCopyWith<$Res> {
  _$StringInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stringValue = null,
  }) {
    return _then(_value.copyWith(
      stringValue: null == stringValue
          ? _value.stringValue
          : stringValue // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_StringInUnionCopyWith<$Res>
    implements $StringInUnionCopyWith<$Res> {
  factory _$$_StringInUnionCopyWith(
          _$_StringInUnion value, $Res Function(_$_StringInUnion) then) =
      __$$_StringInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String stringValue});
}

/// @nodoc
class __$$_StringInUnionCopyWithImpl<$Res>
    extends _$StringInUnionCopyWithImpl<$Res, _$_StringInUnion>
    implements _$$_StringInUnionCopyWith<$Res> {
  __$$_StringInUnionCopyWithImpl(
      _$_StringInUnion _value, $Res Function(_$_StringInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stringValue = null,
  }) {
    return _then(_$_StringInUnion(
      stringValue: null == stringValue
          ? _value.stringValue
          : stringValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_StringInUnion implements _StringInUnion {
  const _$_StringInUnion({required this.stringValue});

  factory _$_StringInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_StringInUnionFromJson(json);

  @override
  final String stringValue;

  @override
  String toString() {
    return 'StringInUnion(stringValue: $stringValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StringInUnion &&
            (identical(other.stringValue, stringValue) ||
                other.stringValue == stringValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, stringValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StringInUnionCopyWith<_$_StringInUnion> get copyWith =>
      __$$_StringInUnionCopyWithImpl<_$_StringInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_StringInUnionToJson(
      this,
    );
  }
}

abstract class _StringInUnion implements StringInUnion {
  const factory _StringInUnion({required final String stringValue}) =
      _$_StringInUnion;

  factory _StringInUnion.fromJson(Map<String, dynamic> json) =
      _$_StringInUnion.fromJson;

  @override
  String get stringValue;
  @override
  @JsonKey(ignore: true)
  _$$_StringInUnionCopyWith<_$_StringInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

BoolInUnion _$BoolInUnionFromJson(Map<String, dynamic> json) {
  return _BoolInUnion.fromJson(json);
}

/// @nodoc
mixin _$BoolInUnion {
  bool get boolValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BoolInUnionCopyWith<BoolInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BoolInUnionCopyWith<$Res> {
  factory $BoolInUnionCopyWith(
          BoolInUnion value, $Res Function(BoolInUnion) then) =
      _$BoolInUnionCopyWithImpl<$Res, BoolInUnion>;
  @useResult
  $Res call({bool boolValue});
}

/// @nodoc
class _$BoolInUnionCopyWithImpl<$Res, $Val extends BoolInUnion>
    implements $BoolInUnionCopyWith<$Res> {
  _$BoolInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boolValue = null,
  }) {
    return _then(_value.copyWith(
      boolValue: null == boolValue
          ? _value.boolValue
          : boolValue // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BoolInUnionCopyWith<$Res>
    implements $BoolInUnionCopyWith<$Res> {
  factory _$$_BoolInUnionCopyWith(
          _$_BoolInUnion value, $Res Function(_$_BoolInUnion) then) =
      __$$_BoolInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool boolValue});
}

/// @nodoc
class __$$_BoolInUnionCopyWithImpl<$Res>
    extends _$BoolInUnionCopyWithImpl<$Res, _$_BoolInUnion>
    implements _$$_BoolInUnionCopyWith<$Res> {
  __$$_BoolInUnionCopyWithImpl(
      _$_BoolInUnion _value, $Res Function(_$_BoolInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boolValue = null,
  }) {
    return _then(_$_BoolInUnion(
      boolValue: null == boolValue
          ? _value.boolValue
          : boolValue // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BoolInUnion implements _BoolInUnion {
  const _$_BoolInUnion({required this.boolValue});

  factory _$_BoolInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_BoolInUnionFromJson(json);

  @override
  final bool boolValue;

  @override
  String toString() {
    return 'BoolInUnion(boolValue: $boolValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BoolInUnion &&
            (identical(other.boolValue, boolValue) ||
                other.boolValue == boolValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, boolValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BoolInUnionCopyWith<_$_BoolInUnion> get copyWith =>
      __$$_BoolInUnionCopyWithImpl<_$_BoolInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BoolInUnionToJson(
      this,
    );
  }
}

abstract class _BoolInUnion implements BoolInUnion {
  const factory _BoolInUnion({required final bool boolValue}) = _$_BoolInUnion;

  factory _BoolInUnion.fromJson(Map<String, dynamic> json) =
      _$_BoolInUnion.fromJson;

  @override
  bool get boolValue;
  @override
  @JsonKey(ignore: true)
  _$$_BoolInUnionCopyWith<_$_BoolInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

DoubleInUnion _$DoubleInUnionFromJson(Map<String, dynamic> json) {
  return _DoubleInUnion.fromJson(json);
}

/// @nodoc
mixin _$DoubleInUnion {
  double get doubleValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DoubleInUnionCopyWith<DoubleInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DoubleInUnionCopyWith<$Res> {
  factory $DoubleInUnionCopyWith(
          DoubleInUnion value, $Res Function(DoubleInUnion) then) =
      _$DoubleInUnionCopyWithImpl<$Res, DoubleInUnion>;
  @useResult
  $Res call({double doubleValue});
}

/// @nodoc
class _$DoubleInUnionCopyWithImpl<$Res, $Val extends DoubleInUnion>
    implements $DoubleInUnionCopyWith<$Res> {
  _$DoubleInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? doubleValue = null,
  }) {
    return _then(_value.copyWith(
      doubleValue: null == doubleValue
          ? _value.doubleValue
          : doubleValue // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DoubleInUnionCopyWith<$Res>
    implements $DoubleInUnionCopyWith<$Res> {
  factory _$$_DoubleInUnionCopyWith(
          _$_DoubleInUnion value, $Res Function(_$_DoubleInUnion) then) =
      __$$_DoubleInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double doubleValue});
}

/// @nodoc
class __$$_DoubleInUnionCopyWithImpl<$Res>
    extends _$DoubleInUnionCopyWithImpl<$Res, _$_DoubleInUnion>
    implements _$$_DoubleInUnionCopyWith<$Res> {
  __$$_DoubleInUnionCopyWithImpl(
      _$_DoubleInUnion _value, $Res Function(_$_DoubleInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? doubleValue = null,
  }) {
    return _then(_$_DoubleInUnion(
      doubleValue: null == doubleValue
          ? _value.doubleValue
          : doubleValue // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DoubleInUnion implements _DoubleInUnion {
  const _$_DoubleInUnion({required this.doubleValue});

  factory _$_DoubleInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_DoubleInUnionFromJson(json);

  @override
  final double doubleValue;

  @override
  String toString() {
    return 'DoubleInUnion(doubleValue: $doubleValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DoubleInUnion &&
            (identical(other.doubleValue, doubleValue) ||
                other.doubleValue == doubleValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, doubleValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DoubleInUnionCopyWith<_$_DoubleInUnion> get copyWith =>
      __$$_DoubleInUnionCopyWithImpl<_$_DoubleInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DoubleInUnionToJson(
      this,
    );
  }
}

abstract class _DoubleInUnion implements DoubleInUnion {
  const factory _DoubleInUnion({required final double doubleValue}) =
      _$_DoubleInUnion;

  factory _DoubleInUnion.fromJson(Map<String, dynamic> json) =
      _$_DoubleInUnion.fromJson;

  @override
  double get doubleValue;
  @override
  @JsonKey(ignore: true)
  _$$_DoubleInUnionCopyWith<_$_DoubleInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

ObjectInUnion _$ObjectInUnionFromJson(Map<String, dynamic> json) {
  return _ObjectInUnion.fromJson(json);
}

/// @nodoc
mixin _$ObjectInUnion {
  Object get objectValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ObjectInUnionCopyWith<ObjectInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ObjectInUnionCopyWith<$Res> {
  factory $ObjectInUnionCopyWith(
          ObjectInUnion value, $Res Function(ObjectInUnion) then) =
      _$ObjectInUnionCopyWithImpl<$Res, ObjectInUnion>;
  @useResult
  $Res call({Object objectValue});
}

/// @nodoc
class _$ObjectInUnionCopyWithImpl<$Res, $Val extends ObjectInUnion>
    implements $ObjectInUnionCopyWith<$Res> {
  _$ObjectInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? objectValue = null,
  }) {
    return _then(_value.copyWith(
      objectValue: null == objectValue ? _value.objectValue : objectValue,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ObjectInUnionCopyWith<$Res>
    implements $ObjectInUnionCopyWith<$Res> {
  factory _$$_ObjectInUnionCopyWith(
          _$_ObjectInUnion value, $Res Function(_$_ObjectInUnion) then) =
      __$$_ObjectInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Object objectValue});
}

/// @nodoc
class __$$_ObjectInUnionCopyWithImpl<$Res>
    extends _$ObjectInUnionCopyWithImpl<$Res, _$_ObjectInUnion>
    implements _$$_ObjectInUnionCopyWith<$Res> {
  __$$_ObjectInUnionCopyWithImpl(
      _$_ObjectInUnion _value, $Res Function(_$_ObjectInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? objectValue = null,
  }) {
    return _then(_$_ObjectInUnion(
      objectValue: null == objectValue ? _value.objectValue : objectValue,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ObjectInUnion implements _ObjectInUnion {
  const _$_ObjectInUnion({required this.objectValue});

  factory _$_ObjectInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_ObjectInUnionFromJson(json);

  @override
  final Object objectValue;

  @override
  String toString() {
    return 'ObjectInUnion(objectValue: $objectValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ObjectInUnion &&
            const DeepCollectionEquality()
                .equals(other.objectValue, objectValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(objectValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ObjectInUnionCopyWith<_$_ObjectInUnion> get copyWith =>
      __$$_ObjectInUnionCopyWithImpl<_$_ObjectInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ObjectInUnionToJson(
      this,
    );
  }
}

abstract class _ObjectInUnion implements ObjectInUnion {
  const factory _ObjectInUnion({required final Object objectValue}) =
      _$_ObjectInUnion;

  factory _ObjectInUnion.fromJson(Map<String, dynamic> json) =
      _$_ObjectInUnion.fromJson;

  @override
  Object get objectValue;
  @override
  @JsonKey(ignore: true)
  _$$_ObjectInUnionCopyWith<_$_ObjectInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

NumInUnion _$NumInUnionFromJson(Map<String, dynamic> json) {
  return _NumInUnion.fromJson(json);
}

/// @nodoc
mixin _$NumInUnion {
  num get numValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NumInUnionCopyWith<NumInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NumInUnionCopyWith<$Res> {
  factory $NumInUnionCopyWith(
          NumInUnion value, $Res Function(NumInUnion) then) =
      _$NumInUnionCopyWithImpl<$Res, NumInUnion>;
  @useResult
  $Res call({num numValue});
}

/// @nodoc
class _$NumInUnionCopyWithImpl<$Res, $Val extends NumInUnion>
    implements $NumInUnionCopyWith<$Res> {
  _$NumInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? numValue = null,
  }) {
    return _then(_value.copyWith(
      numValue: null == numValue
          ? _value.numValue
          : numValue // ignore: cast_nullable_to_non_nullable
              as num,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_NumInUnionCopyWith<$Res>
    implements $NumInUnionCopyWith<$Res> {
  factory _$$_NumInUnionCopyWith(
          _$_NumInUnion value, $Res Function(_$_NumInUnion) then) =
      __$$_NumInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({num numValue});
}

/// @nodoc
class __$$_NumInUnionCopyWithImpl<$Res>
    extends _$NumInUnionCopyWithImpl<$Res, _$_NumInUnion>
    implements _$$_NumInUnionCopyWith<$Res> {
  __$$_NumInUnionCopyWithImpl(
      _$_NumInUnion _value, $Res Function(_$_NumInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? numValue = null,
  }) {
    return _then(_$_NumInUnion(
      numValue: null == numValue
          ? _value.numValue
          : numValue // ignore: cast_nullable_to_non_nullable
              as num,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NumInUnion implements _NumInUnion {
  const _$_NumInUnion({required this.numValue});

  factory _$_NumInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_NumInUnionFromJson(json);

  @override
  final num numValue;

  @override
  String toString() {
    return 'NumInUnion(numValue: $numValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NumInUnion &&
            (identical(other.numValue, numValue) ||
                other.numValue == numValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, numValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NumInUnionCopyWith<_$_NumInUnion> get copyWith =>
      __$$_NumInUnionCopyWithImpl<_$_NumInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NumInUnionToJson(
      this,
    );
  }
}

abstract class _NumInUnion implements NumInUnion {
  const factory _NumInUnion({required final num numValue}) = _$_NumInUnion;

  factory _NumInUnion.fromJson(Map<String, dynamic> json) =
      _$_NumInUnion.fromJson;

  @override
  num get numValue;
  @override
  @JsonKey(ignore: true)
  _$$_NumInUnionCopyWith<_$_NumInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

DateTimeInUnion _$DateTimeInUnionFromJson(Map<String, dynamic> json) {
  return _DateTimeInUnion.fromJson(json);
}

/// @nodoc
mixin _$DateTimeInUnion {
  DateTime get dateTimeValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DateTimeInUnionCopyWith<DateTimeInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DateTimeInUnionCopyWith<$Res> {
  factory $DateTimeInUnionCopyWith(
          DateTimeInUnion value, $Res Function(DateTimeInUnion) then) =
      _$DateTimeInUnionCopyWithImpl<$Res, DateTimeInUnion>;
  @useResult
  $Res call({DateTime dateTimeValue});
}

/// @nodoc
class _$DateTimeInUnionCopyWithImpl<$Res, $Val extends DateTimeInUnion>
    implements $DateTimeInUnionCopyWith<$Res> {
  _$DateTimeInUnionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dateTimeValue = null,
  }) {
    return _then(_value.copyWith(
      dateTimeValue: null == dateTimeValue
          ? _value.dateTimeValue
          : dateTimeValue // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DateTimeInUnionCopyWith<$Res>
    implements $DateTimeInUnionCopyWith<$Res> {
  factory _$$_DateTimeInUnionCopyWith(
          _$_DateTimeInUnion value, $Res Function(_$_DateTimeInUnion) then) =
      __$$_DateTimeInUnionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DateTime dateTimeValue});
}

/// @nodoc
class __$$_DateTimeInUnionCopyWithImpl<$Res>
    extends _$DateTimeInUnionCopyWithImpl<$Res, _$_DateTimeInUnion>
    implements _$$_DateTimeInUnionCopyWith<$Res> {
  __$$_DateTimeInUnionCopyWithImpl(
      _$_DateTimeInUnion _value, $Res Function(_$_DateTimeInUnion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dateTimeValue = null,
  }) {
    return _then(_$_DateTimeInUnion(
      dateTimeValue: null == dateTimeValue
          ? _value.dateTimeValue
          : dateTimeValue // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DateTimeInUnion implements _DateTimeInUnion {
  const _$_DateTimeInUnion({required this.dateTimeValue});

  factory _$_DateTimeInUnion.fromJson(Map<String, dynamic> json) =>
      _$$_DateTimeInUnionFromJson(json);

  @override
  final DateTime dateTimeValue;

  @override
  String toString() {
    return 'DateTimeInUnion(dateTimeValue: $dateTimeValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DateTimeInUnion &&
            (identical(other.dateTimeValue, dateTimeValue) ||
                other.dateTimeValue == dateTimeValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, dateTimeValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DateTimeInUnionCopyWith<_$_DateTimeInUnion> get copyWith =>
      __$$_DateTimeInUnionCopyWithImpl<_$_DateTimeInUnion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DateTimeInUnionToJson(
      this,
    );
  }
}

abstract class _DateTimeInUnion implements DateTimeInUnion {
  const factory _DateTimeInUnion({required final DateTime dateTimeValue}) =
      _$_DateTimeInUnion;

  factory _DateTimeInUnion.fromJson(Map<String, dynamic> json) =
      _$_DateTimeInUnion.fromJson;

  @override
  DateTime get dateTimeValue;
  @override
  @JsonKey(ignore: true)
  _$$_DateTimeInUnionCopyWith<_$_DateTimeInUnion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RootGetData {
  Object? get responseData => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Fruit responseData) as200,
    required TResult Function(int? statusCode, Object? responseData) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Fruit responseData)? as200,
    TResult? Function(int? statusCode, Object? responseData)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Fruit responseData)? as200,
    TResult Function(int? statusCode, Object? responseData)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RootGetDataAs200 value) as200,
    required TResult Function(RootGetResponseUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RootGetDataAs200 value)? as200,
    TResult? Function(RootGetResponseUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RootGetDataAs200 value)? as200,
    TResult Function(RootGetResponseUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RootGetDataCopyWith<$Res> {
  factory $RootGetDataCopyWith(
          RootGetData value, $Res Function(RootGetData) then) =
      _$RootGetDataCopyWithImpl<$Res, RootGetData>;
}

/// @nodoc
class _$RootGetDataCopyWithImpl<$Res, $Val extends RootGetData>
    implements $RootGetDataCopyWith<$Res> {
  _$RootGetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$RootGetDataAs200CopyWith<$Res> {
  factory _$$RootGetDataAs200CopyWith(
          _$RootGetDataAs200 value, $Res Function(_$RootGetDataAs200) then) =
      __$$RootGetDataAs200CopyWithImpl<$Res>;
  @useResult
  $Res call({Fruit responseData});

  $FruitCopyWith<$Res> get responseData;
}

/// @nodoc
class __$$RootGetDataAs200CopyWithImpl<$Res>
    extends _$RootGetDataCopyWithImpl<$Res, _$RootGetDataAs200>
    implements _$$RootGetDataAs200CopyWith<$Res> {
  __$$RootGetDataAs200CopyWithImpl(
      _$RootGetDataAs200 _value, $Res Function(_$RootGetDataAs200) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? responseData = null,
  }) {
    return _then(_$RootGetDataAs200(
      responseData: null == responseData
          ? _value.responseData
          : responseData // ignore: cast_nullable_to_non_nullable
              as Fruit,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FruitCopyWith<$Res> get responseData {
    return $FruitCopyWith<$Res>(_value.responseData, (value) {
      return _then(_value.copyWith(responseData: value));
    });
  }
}

/// @nodoc

class _$RootGetDataAs200 extends RootGetDataAs200 {
  const _$RootGetDataAs200({required this.responseData}) : super._();

  @override
  final Fruit responseData;

  @override
  String toString() {
    return 'RootGetData.as200(responseData: $responseData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RootGetDataAs200 &&
            (identical(other.responseData, responseData) ||
                other.responseData == responseData));
  }

  @override
  int get hashCode => Object.hash(runtimeType, responseData);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RootGetDataAs200CopyWith<_$RootGetDataAs200> get copyWith =>
      __$$RootGetDataAs200CopyWithImpl<_$RootGetDataAs200>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Fruit responseData) as200,
    required TResult Function(int? statusCode, Object? responseData) unknown,
  }) {
    return as200(responseData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Fruit responseData)? as200,
    TResult? Function(int? statusCode, Object? responseData)? unknown,
  }) {
    return as200?.call(responseData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Fruit responseData)? as200,
    TResult Function(int? statusCode, Object? responseData)? unknown,
    required TResult orElse(),
  }) {
    if (as200 != null) {
      return as200(responseData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RootGetDataAs200 value) as200,
    required TResult Function(RootGetResponseUnknown value) unknown,
  }) {
    return as200(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RootGetDataAs200 value)? as200,
    TResult? Function(RootGetResponseUnknown value)? unknown,
  }) {
    return as200?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RootGetDataAs200 value)? as200,
    TResult Function(RootGetResponseUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (as200 != null) {
      return as200(this);
    }
    return orElse();
  }
}

abstract class RootGetDataAs200 extends RootGetData {
  const factory RootGetDataAs200({required final Fruit responseData}) =
      _$RootGetDataAs200;
  const RootGetDataAs200._() : super._();

  @override
  Fruit get responseData;
  @JsonKey(ignore: true)
  _$$RootGetDataAs200CopyWith<_$RootGetDataAs200> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RootGetResponseUnknownCopyWith<$Res> {
  factory _$$RootGetResponseUnknownCopyWith(_$RootGetResponseUnknown value,
          $Res Function(_$RootGetResponseUnknown) then) =
      __$$RootGetResponseUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call({int? statusCode, Object? responseData});
}

/// @nodoc
class __$$RootGetResponseUnknownCopyWithImpl<$Res>
    extends _$RootGetDataCopyWithImpl<$Res, _$RootGetResponseUnknown>
    implements _$$RootGetResponseUnknownCopyWith<$Res> {
  __$$RootGetResponseUnknownCopyWithImpl(_$RootGetResponseUnknown _value,
      $Res Function(_$RootGetResponseUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? statusCode = freezed,
    Object? responseData = freezed,
  }) {
    return _then(_$RootGetResponseUnknown(
      statusCode: freezed == statusCode
          ? _value.statusCode
          : statusCode // ignore: cast_nullable_to_non_nullable
              as int?,
      responseData:
          freezed == responseData ? _value.responseData : responseData,
    ));
  }
}

/// @nodoc

class _$RootGetResponseUnknown extends RootGetResponseUnknown {
  const _$RootGetResponseUnknown({this.statusCode, required this.responseData})
      : super._();

  @override
  final int? statusCode;
  @override
  final Object? responseData;

  @override
  String toString() {
    return 'RootGetData.unknown(statusCode: $statusCode, responseData: $responseData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RootGetResponseUnknown &&
            (identical(other.statusCode, statusCode) ||
                other.statusCode == statusCode) &&
            const DeepCollectionEquality()
                .equals(other.responseData, responseData));
  }

  @override
  int get hashCode => Object.hash(runtimeType, statusCode,
      const DeepCollectionEquality().hash(responseData));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RootGetResponseUnknownCopyWith<_$RootGetResponseUnknown> get copyWith =>
      __$$RootGetResponseUnknownCopyWithImpl<_$RootGetResponseUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Fruit responseData) as200,
    required TResult Function(int? statusCode, Object? responseData) unknown,
  }) {
    return unknown(statusCode, responseData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Fruit responseData)? as200,
    TResult? Function(int? statusCode, Object? responseData)? unknown,
  }) {
    return unknown?.call(statusCode, responseData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Fruit responseData)? as200,
    TResult Function(int? statusCode, Object? responseData)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(statusCode, responseData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RootGetDataAs200 value) as200,
    required TResult Function(RootGetResponseUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RootGetDataAs200 value)? as200,
    TResult? Function(RootGetResponseUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RootGetDataAs200 value)? as200,
    TResult Function(RootGetResponseUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class RootGetResponseUnknown extends RootGetData {
  const factory RootGetResponseUnknown(
      {final int? statusCode,
      required final Object? responseData}) = _$RootGetResponseUnknown;
  const RootGetResponseUnknown._() : super._();

  int? get statusCode;
  @override
  Object? get responseData;
  @JsonKey(ignore: true)
  _$$RootGetResponseUnknownCopyWith<_$RootGetResponseUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TestData {
  Object? get responseData => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? responseData) as204Void,
    required TResult Function(int? statusCode, Object? responseData) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? responseData)? as204Void,
    TResult? Function(int? statusCode, Object? responseData)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? responseData)? as204Void,
    TResult Function(int? statusCode, Object? responseData)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TestDataAs204Void value) as204Void,
    required TResult Function(TestResponseUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TestDataAs204Void value)? as204Void,
    TResult? Function(TestResponseUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TestDataAs204Void value)? as204Void,
    TResult Function(TestResponseUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TestDataCopyWith<TestData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TestDataCopyWith<$Res> {
  factory $TestDataCopyWith(TestData value, $Res Function(TestData) then) =
      _$TestDataCopyWithImpl<$Res, TestData>;
  @useResult
  $Res call({Object? responseData});
}

/// @nodoc
class _$TestDataCopyWithImpl<$Res, $Val extends TestData>
    implements $TestDataCopyWith<$Res> {
  _$TestDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? responseData = freezed,
  }) {
    return _then(_value.copyWith(
      responseData:
          freezed == responseData ? _value.responseData : responseData,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TestDataAs204VoidCopyWith<$Res>
    implements $TestDataCopyWith<$Res> {
  factory _$$TestDataAs204VoidCopyWith(
          _$TestDataAs204Void value, $Res Function(_$TestDataAs204Void) then) =
      __$$TestDataAs204VoidCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Object? responseData});
}

/// @nodoc
class __$$TestDataAs204VoidCopyWithImpl<$Res>
    extends _$TestDataCopyWithImpl<$Res, _$TestDataAs204Void>
    implements _$$TestDataAs204VoidCopyWith<$Res> {
  __$$TestDataAs204VoidCopyWithImpl(
      _$TestDataAs204Void _value, $Res Function(_$TestDataAs204Void) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? responseData = freezed,
  }) {
    return _then(_$TestDataAs204Void(
      responseData:
          freezed == responseData ? _value.responseData : responseData,
    ));
  }
}

/// @nodoc

class _$TestDataAs204Void extends TestDataAs204Void {
  const _$TestDataAs204Void({required this.responseData}) : super._();

  @override
  final Object? responseData;

  @override
  String toString() {
    return 'TestData.as204Void(responseData: $responseData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TestDataAs204Void &&
            const DeepCollectionEquality()
                .equals(other.responseData, responseData));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(responseData));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TestDataAs204VoidCopyWith<_$TestDataAs204Void> get copyWith =>
      __$$TestDataAs204VoidCopyWithImpl<_$TestDataAs204Void>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? responseData) as204Void,
    required TResult Function(int? statusCode, Object? responseData) unknown,
  }) {
    return as204Void(responseData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? responseData)? as204Void,
    TResult? Function(int? statusCode, Object? responseData)? unknown,
  }) {
    return as204Void?.call(responseData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? responseData)? as204Void,
    TResult Function(int? statusCode, Object? responseData)? unknown,
    required TResult orElse(),
  }) {
    if (as204Void != null) {
      return as204Void(responseData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TestDataAs204Void value) as204Void,
    required TResult Function(TestResponseUnknown value) unknown,
  }) {
    return as204Void(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TestDataAs204Void value)? as204Void,
    TResult? Function(TestResponseUnknown value)? unknown,
  }) {
    return as204Void?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TestDataAs204Void value)? as204Void,
    TResult Function(TestResponseUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (as204Void != null) {
      return as204Void(this);
    }
    return orElse();
  }
}

abstract class TestDataAs204Void extends TestData {
  const factory TestDataAs204Void({required final Object? responseData}) =
      _$TestDataAs204Void;
  const TestDataAs204Void._() : super._();

  @override
  Object? get responseData;
  @override
  @JsonKey(ignore: true)
  _$$TestDataAs204VoidCopyWith<_$TestDataAs204Void> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TestResponseUnknownCopyWith<$Res>
    implements $TestDataCopyWith<$Res> {
  factory _$$TestResponseUnknownCopyWith(_$TestResponseUnknown value,
          $Res Function(_$TestResponseUnknown) then) =
      __$$TestResponseUnknownCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? statusCode, Object? responseData});
}

/// @nodoc
class __$$TestResponseUnknownCopyWithImpl<$Res>
    extends _$TestDataCopyWithImpl<$Res, _$TestResponseUnknown>
    implements _$$TestResponseUnknownCopyWith<$Res> {
  __$$TestResponseUnknownCopyWithImpl(
      _$TestResponseUnknown _value, $Res Function(_$TestResponseUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? statusCode = freezed,
    Object? responseData = freezed,
  }) {
    return _then(_$TestResponseUnknown(
      statusCode: freezed == statusCode
          ? _value.statusCode
          : statusCode // ignore: cast_nullable_to_non_nullable
              as int?,
      responseData:
          freezed == responseData ? _value.responseData : responseData,
    ));
  }
}

/// @nodoc

class _$TestResponseUnknown extends TestResponseUnknown {
  const _$TestResponseUnknown({this.statusCode, required this.responseData})
      : super._();

  @override
  final int? statusCode;
  @override
  final Object? responseData;

  @override
  String toString() {
    return 'TestData.unknown(statusCode: $statusCode, responseData: $responseData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TestResponseUnknown &&
            (identical(other.statusCode, statusCode) ||
                other.statusCode == statusCode) &&
            const DeepCollectionEquality()
                .equals(other.responseData, responseData));
  }

  @override
  int get hashCode => Object.hash(runtimeType, statusCode,
      const DeepCollectionEquality().hash(responseData));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TestResponseUnknownCopyWith<_$TestResponseUnknown> get copyWith =>
      __$$TestResponseUnknownCopyWithImpl<_$TestResponseUnknown>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? responseData) as204Void,
    required TResult Function(int? statusCode, Object? responseData) unknown,
  }) {
    return unknown(statusCode, responseData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? responseData)? as204Void,
    TResult? Function(int? statusCode, Object? responseData)? unknown,
  }) {
    return unknown?.call(statusCode, responseData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? responseData)? as204Void,
    TResult Function(int? statusCode, Object? responseData)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(statusCode, responseData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TestDataAs204Void value) as204Void,
    required TResult Function(TestResponseUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TestDataAs204Void value)? as204Void,
    TResult? Function(TestResponseUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TestDataAs204Void value)? as204Void,
    TResult Function(TestResponseUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class TestResponseUnknown extends TestData {
  const factory TestResponseUnknown(
      {final int? statusCode,
      required final Object? responseData}) = _$TestResponseUnknown;
  const TestResponseUnknown._() : super._();

  int? get statusCode;
  @override
  Object? get responseData;
  @override
  @JsonKey(ignore: true)
  _$$TestResponseUnknownCopyWith<_$TestResponseUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

Apple _$AppleFromJson(Map<String, dynamic> json) {
  return _Apple.fromJson(json);
}

/// @nodoc
mixin _$Apple {
  @JsonKey(name: r'kind')
  String? get kind => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppleCopyWith<Apple> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppleCopyWith<$Res> {
  factory $AppleCopyWith(Apple value, $Res Function(Apple) then) =
      _$AppleCopyWithImpl<$Res, Apple>;
  @useResult
  $Res call({@JsonKey(name: r'kind') String? kind});
}

/// @nodoc
class _$AppleCopyWithImpl<$Res, $Val extends Apple>
    implements $AppleCopyWith<$Res> {
  _$AppleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? kind = freezed,
  }) {
    return _then(_value.copyWith(
      kind: freezed == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppleCopyWith<$Res> implements $AppleCopyWith<$Res> {
  factory _$$_AppleCopyWith(_$_Apple value, $Res Function(_$_Apple) then) =
      __$$_AppleCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: r'kind') String? kind});
}

/// @nodoc
class __$$_AppleCopyWithImpl<$Res> extends _$AppleCopyWithImpl<$Res, _$_Apple>
    implements _$$_AppleCopyWith<$Res> {
  __$$_AppleCopyWithImpl(_$_Apple _value, $Res Function(_$_Apple) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? kind = freezed,
  }) {
    return _then(_$_Apple(
      kind: freezed == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Apple extends _Apple {
  const _$_Apple({@JsonKey(name: r'kind') this.kind}) : super._();

  factory _$_Apple.fromJson(Map<String, dynamic> json) =>
      _$$_AppleFromJson(json);

  @override
  @JsonKey(name: r'kind')
  final String? kind;

  @override
  String toString() {
    return 'Apple(kind: $kind)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Apple &&
            (identical(other.kind, kind) || other.kind == kind));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, kind);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppleCopyWith<_$_Apple> get copyWith =>
      __$$_AppleCopyWithImpl<_$_Apple>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppleToJson(
      this,
    );
  }
}

abstract class _Apple extends Apple {
  const factory _Apple({@JsonKey(name: r'kind') final String? kind}) = _$_Apple;
  const _Apple._() : super._();

  factory _Apple.fromJson(Map<String, dynamic> json) = _$_Apple.fromJson;

  @override
  @JsonKey(name: r'kind')
  String? get kind;
  @override
  @JsonKey(ignore: true)
  _$$_AppleCopyWith<_$_Apple> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Fruit {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Grape> listGrapeValue) asListGrape,
    required TResult Function(Map<String, Apple> mapStringAppleValue)
        asMapStringApple,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Fruit> deserializedModels)
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Grape> listGrapeValue)? asListGrape,
    TResult? Function(Map<String, Apple> mapStringAppleValue)? asMapStringApple,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Fruit> deserializedModels)?
        unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Grape> listGrapeValue)? asListGrape,
    TResult Function(Map<String, Apple> mapStringAppleValue)? asMapStringApple,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Fruit> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitAsListGrape value) asListGrape,
    required TResult Function(FruitAsMapStringApple value) asMapStringApple,
    required TResult Function(FruitUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitAsListGrape value)? asListGrape,
    TResult? Function(FruitAsMapStringApple value)? asMapStringApple,
    TResult? Function(FruitUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitAsListGrape value)? asListGrape,
    TResult Function(FruitAsMapStringApple value)? asMapStringApple,
    TResult Function(FruitUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FruitCopyWith<$Res> {
  factory $FruitCopyWith(Fruit value, $Res Function(Fruit) then) =
      _$FruitCopyWithImpl<$Res, Fruit>;
}

/// @nodoc
class _$FruitCopyWithImpl<$Res, $Val extends Fruit>
    implements $FruitCopyWith<$Res> {
  _$FruitCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FruitAsListGrapeCopyWith<$Res> {
  factory _$$FruitAsListGrapeCopyWith(
          _$FruitAsListGrape value, $Res Function(_$FruitAsListGrape) then) =
      __$$FruitAsListGrapeCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Grape> listGrapeValue});
}

/// @nodoc
class __$$FruitAsListGrapeCopyWithImpl<$Res>
    extends _$FruitCopyWithImpl<$Res, _$FruitAsListGrape>
    implements _$$FruitAsListGrapeCopyWith<$Res> {
  __$$FruitAsListGrapeCopyWithImpl(
      _$FruitAsListGrape _value, $Res Function(_$FruitAsListGrape) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? listGrapeValue = null,
  }) {
    return _then(_$FruitAsListGrape(
      listGrapeValue: null == listGrapeValue
          ? _value._listGrapeValue
          : listGrapeValue // ignore: cast_nullable_to_non_nullable
              as List<Grape>,
    ));
  }
}

/// @nodoc

class _$FruitAsListGrape extends FruitAsListGrape {
  const _$FruitAsListGrape({required final List<Grape> listGrapeValue})
      : _listGrapeValue = listGrapeValue,
        super._();

  final List<Grape> _listGrapeValue;
  @override
  List<Grape> get listGrapeValue {
    if (_listGrapeValue is EqualUnmodifiableListView) return _listGrapeValue;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_listGrapeValue);
  }

  @override
  String toString() {
    return 'Fruit.asListGrape(listGrapeValue: $listGrapeValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitAsListGrape &&
            const DeepCollectionEquality()
                .equals(other._listGrapeValue, _listGrapeValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_listGrapeValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitAsListGrapeCopyWith<_$FruitAsListGrape> get copyWith =>
      __$$FruitAsListGrapeCopyWithImpl<_$FruitAsListGrape>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Grape> listGrapeValue) asListGrape,
    required TResult Function(Map<String, Apple> mapStringAppleValue)
        asMapStringApple,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Fruit> deserializedModels)
        unknown,
  }) {
    return asListGrape(listGrapeValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Grape> listGrapeValue)? asListGrape,
    TResult? Function(Map<String, Apple> mapStringAppleValue)? asMapStringApple,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Fruit> deserializedModels)?
        unknown,
  }) {
    return asListGrape?.call(listGrapeValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Grape> listGrapeValue)? asListGrape,
    TResult Function(Map<String, Apple> mapStringAppleValue)? asMapStringApple,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Fruit> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asListGrape != null) {
      return asListGrape(listGrapeValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitAsListGrape value) asListGrape,
    required TResult Function(FruitAsMapStringApple value) asMapStringApple,
    required TResult Function(FruitUnknown value) unknown,
  }) {
    return asListGrape(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitAsListGrape value)? asListGrape,
    TResult? Function(FruitAsMapStringApple value)? asMapStringApple,
    TResult? Function(FruitUnknown value)? unknown,
  }) {
    return asListGrape?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitAsListGrape value)? asListGrape,
    TResult Function(FruitAsMapStringApple value)? asMapStringApple,
    TResult Function(FruitUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asListGrape != null) {
      return asListGrape(this);
    }
    return orElse();
  }
}

abstract class FruitAsListGrape extends Fruit {
  const factory FruitAsListGrape({required final List<Grape> listGrapeValue}) =
      _$FruitAsListGrape;
  const FruitAsListGrape._() : super._();

  List<Grape> get listGrapeValue;
  @JsonKey(ignore: true)
  _$$FruitAsListGrapeCopyWith<_$FruitAsListGrape> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitAsMapStringAppleCopyWith<$Res> {
  factory _$$FruitAsMapStringAppleCopyWith(_$FruitAsMapStringApple value,
          $Res Function(_$FruitAsMapStringApple) then) =
      __$$FruitAsMapStringAppleCopyWithImpl<$Res>;
  @useResult
  $Res call({Map<String, Apple> mapStringAppleValue});
}

/// @nodoc
class __$$FruitAsMapStringAppleCopyWithImpl<$Res>
    extends _$FruitCopyWithImpl<$Res, _$FruitAsMapStringApple>
    implements _$$FruitAsMapStringAppleCopyWith<$Res> {
  __$$FruitAsMapStringAppleCopyWithImpl(_$FruitAsMapStringApple _value,
      $Res Function(_$FruitAsMapStringApple) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mapStringAppleValue = null,
  }) {
    return _then(_$FruitAsMapStringApple(
      mapStringAppleValue: null == mapStringAppleValue
          ? _value._mapStringAppleValue
          : mapStringAppleValue // ignore: cast_nullable_to_non_nullable
              as Map<String, Apple>,
    ));
  }
}

/// @nodoc

class _$FruitAsMapStringApple extends FruitAsMapStringApple {
  const _$FruitAsMapStringApple(
      {required final Map<String, Apple> mapStringAppleValue})
      : _mapStringAppleValue = mapStringAppleValue,
        super._();

  final Map<String, Apple> _mapStringAppleValue;
  @override
  Map<String, Apple> get mapStringAppleValue {
    if (_mapStringAppleValue is EqualUnmodifiableMapView)
      return _mapStringAppleValue;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_mapStringAppleValue);
  }

  @override
  String toString() {
    return 'Fruit.asMapStringApple(mapStringAppleValue: $mapStringAppleValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitAsMapStringApple &&
            const DeepCollectionEquality()
                .equals(other._mapStringAppleValue, _mapStringAppleValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_mapStringAppleValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitAsMapStringAppleCopyWith<_$FruitAsMapStringApple> get copyWith =>
      __$$FruitAsMapStringAppleCopyWithImpl<_$FruitAsMapStringApple>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Grape> listGrapeValue) asListGrape,
    required TResult Function(Map<String, Apple> mapStringAppleValue)
        asMapStringApple,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Fruit> deserializedModels)
        unknown,
  }) {
    return asMapStringApple(mapStringAppleValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Grape> listGrapeValue)? asListGrape,
    TResult? Function(Map<String, Apple> mapStringAppleValue)? asMapStringApple,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Fruit> deserializedModels)?
        unknown,
  }) {
    return asMapStringApple?.call(mapStringAppleValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Grape> listGrapeValue)? asListGrape,
    TResult Function(Map<String, Apple> mapStringAppleValue)? asMapStringApple,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Fruit> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (asMapStringApple != null) {
      return asMapStringApple(mapStringAppleValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitAsListGrape value) asListGrape,
    required TResult Function(FruitAsMapStringApple value) asMapStringApple,
    required TResult Function(FruitUnknown value) unknown,
  }) {
    return asMapStringApple(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitAsListGrape value)? asListGrape,
    TResult? Function(FruitAsMapStringApple value)? asMapStringApple,
    TResult? Function(FruitUnknown value)? unknown,
  }) {
    return asMapStringApple?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitAsListGrape value)? asListGrape,
    TResult Function(FruitAsMapStringApple value)? asMapStringApple,
    TResult Function(FruitUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (asMapStringApple != null) {
      return asMapStringApple(this);
    }
    return orElse();
  }
}

abstract class FruitAsMapStringApple extends Fruit {
  const factory FruitAsMapStringApple(
          {required final Map<String, Apple> mapStringAppleValue}) =
      _$FruitAsMapStringApple;
  const FruitAsMapStringApple._() : super._();

  Map<String, Apple> get mapStringAppleValue;
  @JsonKey(ignore: true)
  _$$FruitAsMapStringAppleCopyWith<_$FruitAsMapStringApple> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FruitUnknownCopyWith<$Res> {
  factory _$$FruitUnknownCopyWith(
          _$FruitUnknown value, $Res Function(_$FruitUnknown) then) =
      __$$FruitUnknownCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      Map<String, dynamic> json,
      DeserializationErrorType errorType,
      List<Type> possibleTypes,
      List<Fruit> deserializedModels});
}

/// @nodoc
class __$$FruitUnknownCopyWithImpl<$Res>
    extends _$FruitCopyWithImpl<$Res, _$FruitUnknown>
    implements _$$FruitUnknownCopyWith<$Res> {
  __$$FruitUnknownCopyWithImpl(
      _$FruitUnknown _value, $Res Function(_$FruitUnknown) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? json = null,
    Object? errorType = null,
    Object? possibleTypes = null,
    Object? deserializedModels = null,
  }) {
    return _then(_$FruitUnknown(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      json: null == json
          ? _value._json
          : json // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      errorType: null == errorType
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as DeserializationErrorType,
      possibleTypes: null == possibleTypes
          ? _value._possibleTypes
          : possibleTypes // ignore: cast_nullable_to_non_nullable
              as List<Type>,
      deserializedModels: null == deserializedModels
          ? _value._deserializedModels
          : deserializedModels // ignore: cast_nullable_to_non_nullable
              as List<Fruit>,
    ));
  }
}

/// @nodoc

class _$FruitUnknown extends FruitUnknown {
  const _$FruitUnknown(
      {this.message = 'Json does not satisfy any available types',
      required final Map<String, dynamic> json,
      this.errorType = DeserializationErrorType.UnKnownType,
      final List<Type> possibleTypes = const <Type>[
        List<Grape>,
        Map<String, Apple>
      ],
      final List<Fruit> deserializedModels = const <Fruit>[]})
      : _json = json,
        _possibleTypes = possibleTypes,
        _deserializedModels = deserializedModels,
        super._();

  @override
  @JsonKey()
  final String message;
  final Map<String, dynamic> _json;
  @override
  Map<String, dynamic> get json {
    if (_json is EqualUnmodifiableMapView) return _json;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_json);
  }

  @override
  @JsonKey()
  final DeserializationErrorType errorType;
  final List<Type> _possibleTypes;
  @override
  @JsonKey()
  List<Type> get possibleTypes {
    if (_possibleTypes is EqualUnmodifiableListView) return _possibleTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_possibleTypes);
  }

  final List<Fruit> _deserializedModels;
  @override
  @JsonKey()
  List<Fruit> get deserializedModels {
    if (_deserializedModels is EqualUnmodifiableListView)
      return _deserializedModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deserializedModels);
  }

  @override
  String toString() {
    return 'Fruit.unknown(message: $message, json: $json, errorType: $errorType, possibleTypes: $possibleTypes, deserializedModels: $deserializedModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FruitUnknown &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._json, _json) &&
            (identical(other.errorType, errorType) ||
                other.errorType == errorType) &&
            const DeepCollectionEquality()
                .equals(other._possibleTypes, _possibleTypes) &&
            const DeepCollectionEquality()
                .equals(other._deserializedModels, _deserializedModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      message,
      const DeepCollectionEquality().hash(_json),
      errorType,
      const DeepCollectionEquality().hash(_possibleTypes),
      const DeepCollectionEquality().hash(_deserializedModels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FruitUnknownCopyWith<_$FruitUnknown> get copyWith =>
      __$$FruitUnknownCopyWithImpl<_$FruitUnknown>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Grape> listGrapeValue) asListGrape,
    required TResult Function(Map<String, Apple> mapStringAppleValue)
        asMapStringApple,
    required TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Fruit> deserializedModels)
        unknown,
  }) {
    return unknown(message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Grape> listGrapeValue)? asListGrape,
    TResult? Function(Map<String, Apple> mapStringAppleValue)? asMapStringApple,
    TResult? Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Fruit> deserializedModels)?
        unknown,
  }) {
    return unknown?.call(
        message, json, errorType, possibleTypes, deserializedModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Grape> listGrapeValue)? asListGrape,
    TResult Function(Map<String, Apple> mapStringAppleValue)? asMapStringApple,
    TResult Function(
            String message,
            Map<String, dynamic> json,
            DeserializationErrorType errorType,
            List<Type> possibleTypes,
            List<Fruit> deserializedModels)?
        unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(
          message, json, errorType, possibleTypes, deserializedModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FruitAsListGrape value) asListGrape,
    required TResult Function(FruitAsMapStringApple value) asMapStringApple,
    required TResult Function(FruitUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FruitAsListGrape value)? asListGrape,
    TResult? Function(FruitAsMapStringApple value)? asMapStringApple,
    TResult? Function(FruitUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FruitAsListGrape value)? asListGrape,
    TResult Function(FruitAsMapStringApple value)? asMapStringApple,
    TResult Function(FruitUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class FruitUnknown extends Fruit {
  const factory FruitUnknown(
      {final String message,
      required final Map<String, dynamic> json,
      final DeserializationErrorType errorType,
      final List<Type> possibleTypes,
      final List<Fruit> deserializedModels}) = _$FruitUnknown;
  const FruitUnknown._() : super._();

  String get message;
  Map<String, dynamic> get json;
  DeserializationErrorType get errorType;
  List<Type> get possibleTypes;
  List<Fruit> get deserializedModels;
  @JsonKey(ignore: true)
  _$$FruitUnknownCopyWith<_$FruitUnknown> get copyWith =>
      throw _privateConstructorUsedError;
}

Grape _$GrapeFromJson(Map<String, dynamic> json) {
  return _Grape.fromJson(json);
}

/// @nodoc
mixin _$Grape {
  @JsonKey(name: r'color')
  String? get color => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GrapeCopyWith<Grape> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GrapeCopyWith<$Res> {
  factory $GrapeCopyWith(Grape value, $Res Function(Grape) then) =
      _$GrapeCopyWithImpl<$Res, Grape>;
  @useResult
  $Res call({@JsonKey(name: r'color') String? color});
}

/// @nodoc
class _$GrapeCopyWithImpl<$Res, $Val extends Grape>
    implements $GrapeCopyWith<$Res> {
  _$GrapeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? color = freezed,
  }) {
    return _then(_value.copyWith(
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_GrapeCopyWith<$Res> implements $GrapeCopyWith<$Res> {
  factory _$$_GrapeCopyWith(_$_Grape value, $Res Function(_$_Grape) then) =
      __$$_GrapeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: r'color') String? color});
}

/// @nodoc
class __$$_GrapeCopyWithImpl<$Res> extends _$GrapeCopyWithImpl<$Res, _$_Grape>
    implements _$$_GrapeCopyWith<$Res> {
  __$$_GrapeCopyWithImpl(_$_Grape _value, $Res Function(_$_Grape) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? color = freezed,
  }) {
    return _then(_$_Grape(
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Grape extends _Grape {
  const _$_Grape({@JsonKey(name: r'color') this.color}) : super._();

  factory _$_Grape.fromJson(Map<String, dynamic> json) =>
      _$$_GrapeFromJson(json);

  @override
  @JsonKey(name: r'color')
  final String? color;

  @override
  String toString() {
    return 'Grape(color: $color)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Grape &&
            (identical(other.color, color) || other.color == color));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, color);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GrapeCopyWith<_$_Grape> get copyWith =>
      __$$_GrapeCopyWithImpl<_$_Grape>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GrapeToJson(
      this,
    );
  }
}

abstract class _Grape extends Grape {
  const factory _Grape({@JsonKey(name: r'color') final String? color}) =
      _$_Grape;
  const _Grape._() : super._();

  factory _Grape.fromJson(Map<String, dynamic> json) = _$_Grape.fromJson;

  @override
  @JsonKey(name: r'color')
  String? get color;
  @override
  @JsonKey(ignore: true)
  _$$_GrapeCopyWith<_$_Grape> get copyWith =>
      throw _privateConstructorUsedError;
}
